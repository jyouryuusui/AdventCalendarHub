{
  "title": "houdini advent calendar hub",
  "summary": "houdini advent calendar articles",
  "lastUpdated": "2023-11-28T12:34:56+09:00",
  "categories": "Houdini",
  "tags": "Recommend SOP VOP ROP DOP COP CHOP VEX Wrangle HoudiniEngine HScript Python",
  "data": [
    {
      "thumbnailUrl": "2016120101.jpg",
      "creationDate": "2016-12-01",
      "author": {
          "name": "@jyouryuusui",
          "twitterIcon": "jyouryuusui.jpg",
          "qiitaUrl": "https://qiita.com/jyouryuusui",
          "twitterUrl": "https://twitter.com/jyouryuusui"
      },
      "title": {
          "ja": "Copy/Stampを卒業しよう！",
          "en": "Let's graduate to Copy/Stamp!"
      },
      "articleUrl": "https://qiita.com/jyouryuusui/items/d1fc4bc521f079ab6be6",
      "categories": "Houdini",
      "tags": "SOP VEX Wrangle",
      "articleId": 2016120101,
      "summary": {
          "ja": "この記事では、HoudiniのCopy/Stamp機能を使った3Dモデリング手法を紹介しています。特に、PointAttributeを利用した効率的なモデリング方法を詳細に説明しており、移動、スケール、回転などの基本操作をカバーしています。また、CopySOPのstamp機能の代わりにPointAttributeを利用することで、処理の効率化とノードの簡素化が可能であることを強調しています​",
          "en": "This article introduces 3D modeling techniques using Houdini's Copy/Stamp feature. In particular, it details an efficient modeling method using PointAttribute, covering basic operations such as translation, scale, and rotation. It also emphasizes that using PointAttribute instead of CopySOP's stamp function can streamline the process and simplify the nodes."
      }
  },
  {
      "thumbnailUrl": "2016120201.jpg",
      "creationDate": "2016-12-02",
      "author": {
          "name": "@jyouryuusui",
          "twitterIcon": "jyouryuusui.jpg",
          "qiitaUrl": "https://qiita.com/jyouryuusui",
          "twitterUrl": "https://twitter.com/jyouryuusui"
      },
      "title": {
          "ja": "パラメーターには何が入るのか？Edit String＆Expression",
          "en": "What goes in the parametersEdit String & Expression"
      },
      "articleUrl": "https://qiita.com/jyouryuusui/items/08090811fec7177afc45",
      "categories": "Houdini",
      "tags": "Python HScript",
      "articleId": 2016120201,
      "summary": {
          "ja": "この記事では、Houdini内のパラメーターへのExpression（式）の入力に関する詳細なガイドを提供しています。Expressionの基本から、Edit Stringを使った高度なテクニックまでを説明し、パラメーターのカスタマイズ方法に焦点を当てています。また、Expressionの関数やローカル変数の使い方についても詳しく解説しており、Houdiniのパラメーター管理の深い理解に役立つ内容となっています",
          "en": "This article provides a detailed guide to entering Expressions into parameters within Houdini, from the basics of Expression to advanced techniques using Edit String, focusing on how to customize parameters. It also details the use of Expression functions and local variables to help you gain a deeper understanding of parameter management in Houdini!"
      }
  },
  {
      "thumbnailUrl": "2016120301.jpg",
      "creationDate": "2016-12-03",
      "author": {
          "name": "@jyouryuusui",
          "twitterIcon": "jyouryuusui.jpg",
          "qiitaUrl": "https://qiita.com/jyouryuusui",
          "twitterUrl": "https://twitter.com/jyouryuusui"
      },
      "title": {
          "ja": "TraceとFind Shortest Pathで迷路の答えを導こう",
          "en": "Use Trace and Find Shortest Path to guide you to the answer to the maze!"
      },
      "articleUrl": "https://qiita.com/jyouryuusui/items/b5ea02dc3457c35416c9",
      "categories": "Houdini",
      "tags": "SOP COP",
      "articleId": 2016120301,
      "summary": {
          "ja": "この記事では、Houdiniを使用して迷路の画像から脱出経路を求める方法を説明しています。Trace SOP、Group SOP、Find Shortest Path SOPの使用方法に焦点を当て、迷路画像のトレース、スタートとゴール地点の設定、最短経路の検出などのステップを詳しく説明しています。記事はHoudiniのこれらのツールを使用して複雑な問題を解決する方法を示しています​",
          "en": "This article explains how to use Houdini to find escape routes from a maze image, focusing on the use of the Trace SOP, Group SOP, and Find Shortest Path SOP and detailing the steps involved in tracing a maze image, setting start and finish points, and finding the shortest path. The steps are explained in detail. The article shows how to use these tools in Houdini to solve complex problems."
      }
  },
  {
      "thumbnailUrl": "2016120401.jpg",
      "creationDate": "2016-12-04",
      "author": {
          "name": "@jyouryuusui",
          "twitterIcon": "jyouryuusui.jpg",
          "qiitaUrl": "https://qiita.com/jyouryuusui",
          "twitterUrl": "https://twitter.com/jyouryuusui"
      },
      "title": {
          "ja": "Wire SolverでなくFor-Eachを利用したワイヤー表現",
          "en": "Wire representation using For-Each instead of Wire Solver"
      },
      "articleUrl": "https://qiita.com/jyouryuusui/items/7d67a37031a090f7c9e2",
      "categories": "Houdini",
      "tags": "SOP Wrangle",
      "articleId": 2016120401,
      "summary": {
          "ja": "この記事では、HoudiniでWire Solverの代わりにFor-Eachを用いてワイヤーを表現する方法について説明しています。Stroke SOP、Ray SOP、PolyFrame SOPなどを組み合わせて、ワイヤーの形状を作成し、動きを表現する手順が詳細に説明されています。For-Eachを使用することで、より制御が容易で効率的なワイヤー表現が可能になることを示しています",
          "en": "This article explains how to use For-Each instead of Wire Solver to represent wires in Houdini, detailing how to combine Stroke SOPs, Ray SOPs, PolyFrame SOPs, etc. to create wire shapes and represent movement. It shows how For-Each can be used to create more controllable and efficient wire expressions."
      }
  },
  {
      "thumbnailUrl": "2016120501.jpg",
      "creationDate": "2016-12-05",
      "author": {
          "name": "@yone80@github",
          "twitterIcon": "yone80@github.jpg",
          "qiitaUrl": "https://qiita.com/yone80@github",
          "twitterUrl": "https://twitter.com/yone80"
      },
      "title": {
          "ja": "[記事削除済み] Vex で Curve に沿って変形するやつ",
          "en": "[Article deleted] The one that deforms along a Curve in Vex."
      },
      "articleUrl": "http://qiita.com/yone80@github/items/d0580bc71a6a47ec567f",
      "categories": "Houdini",
      "tags": "SOP VEX Wrangle",
      "articleId": 2016120501,
      "summary": {
          "ja": "この記事では、Houdiniを使用してCurveに沿ってジオメトリを変形させる方法を説明していました。Curveに方向を示すNとupベクトルを作成し、Sweep SOPを使うことを推奨しています。その後、Attribute Wrangle SOPを使用して変形させたいジオメトリをCurve上に配置し、primuv()関数を使ってプリミティブのUV座標で属性を取得します。CurveがPolylineまたはNurbsの場合のサイズ調整方法についても説明し、Curveを延長する方法を示しています。",
          "en": "This article explained how to deform geometry along a Curve using Houdini, recommending creating N and up vectors for the direction on the Curve and using the Sweep SOP. Then, the Attribute Wrangle SOP is used to place the geometry to be deformed on the Curve, and the primuv() function is used to get the attributes in the primitive's UV coordinates, shows how to extend the Curve."
      }
  },
  {
      "thumbnailUrl": "2016120601.jpg",
      "creationDate": "2016-12-06",
      "author": {
          "name": "@ikatnek",
          "twitterIcon": "ikatnek.jpg",
          "qiitaUrl": "https://qiita.com/ikatnek",
          "twitterUrl": "https://twitter.com/ikatnek"
      },
      "title": {
          "ja": "Pyro のレンダリング",
          "en": "Pyro Rendering"
      },
      "articleUrl": "https://ikatnek.blogspot.jp/p/pyro-rendering.html",
      "categories": "Houdini",
      "tags": "Pyro DOP ROP Mantra",
      "articleId": 2016120601,
      "summary": {
          "ja": "この記事は、HoudiniのPyro FXをMantraでレンダリングする際にノイズを低減する方法について説明しています。まず、Houdiniで元のシーンを作成し、カメラ位置を設定し、トーラス形状から炎をシミュレートします。レンダリング精度を向上させるために、Volume QualityとStochastic Samplesの値を調整し、RGBとアルファチャンネルの画質を比較します。結論として、Pyroボリュームのレンダリング品質はVolume QualityとStochastic Samplesに大きく依存し、これらのパラメータを高めに設定することでノイズを低減できることが示されています。",
          "en": "This article explains how to reduce noise when rendering Pyro FX in Houdini with Mantra. First, create the original scene in Houdini, set the camera position, and simulate a flame from a torus shape. To improve the rendering accuracy, we adjust the values of Volume Quality and Stochastic Samples and compare the image quality of the RGB and alpha channels. In conclusion, it is shown that the rendering quality of a Pyro volume is highly dependent on Volume Quality and Stochastic Samples, and that setting these parameters higher can reduce noise."
      }
  },
  {
      "thumbnailUrl": "2016120701.jpg",
      "creationDate": "2016-12-07",
      "author": {
          "name": "@fujitarium",
          "twitterIcon": "fujitarium.jpg",
          "qiitaUrl": "https://qiita.com/fujitarium",
          "twitterUrl": "https://twitter.com/fujitarium"
      },
      "title": {
          "ja": "火花などのライン化した擬似モーションブラーとレンダーのモーションブラーの共存",
          "en": "Coexistence of linealized pseudo-motion blur such as sparks and rendered motion blur"
      },
      "articleUrl": "https://qiita.com/fujitarium/items/041e42af884bf32a7619",
      "categories": "Houdini",
      "tags": "SOP NDC ROP",
      "articleId": 2016120701,
      "summary": {
          "ja": "この記事では、Houdiniを使用して動いているカメラから見たモーションラインを作成する方法について説明しています。特に、動いているポイントに対するカメラのモーションラインの作成や、レンダリング時のモーションブラーの打ち消しについて詳しく説明しています​",
          "en": "This article describes how to use Houdini to create motion lines as seen from a moving camera. In particular, it details the creation of motion lines for a camera relative to a moving point and how to cancel motion blur during rendering."
      }
  },
  {
      "thumbnailUrl": "2016120801.jpg",
      "creationDate": "2016-12-08",
      "author": {
          "name": "@it_ks",
          "twitterIcon": "it_ks.jpg",
          "qiitaUrl": "https://qiita.com/it_ks",
          "twitterUrl": "https://twitter.com/it_ks"
      },
      "title": {
          "ja": "Houdiniの文字モジしたUIたち",
          "en": "Houdini's Lettered UIs"
      },
      "articleUrl": "https://qiita.com/it_ks/items/be1e646e8ecec10ba154",
      "categories": "Houdini",
      "tags": "Hscript Python",
      "articleId": 2016120801,
      "summary": {
          "ja": "この記事では、HoudiniのTextport、Python Shell、Python Source Editor、Python Panel EditorといったUIコンポーネントについて詳しく解説しています。これらのUIはHoudiniとのやり取りに使われ、Pythonを含む様々なスクリプト言語のサポートが提供されています。また、HoudiniのPython環境で利用可能なライブラリについても触れています",
          "en": "This article details Houdini's UI components such as Textport, Python Shell, Python Source Editor, and Python Panel Editor. These UIs are used to interact with Houdini and provide support for a variety of scripting languages, including Python. It also discusses the libraries available in Houdini's Python environment."
      }
  },
  {
      "thumbnailUrl": "2016120901.jpg",
      "creationDate": "2016-12-09",
      "author": {
          "name": "@takavfx",
          "twitterIcon": "takavfx.jpg",
          "qiitaUrl": "https://qiita.com/takavfx",
          "twitterUrl": "https://twitter.com/takavfx"
      },
      "title": {
          "ja": "Bento Toolsetを紹介してみる。",
          "en": "Let me introduce Bento Toolset."
      },
      "articleUrl": "https://qiita.com/takavfx/items/a3e92bb2edd3f7d30f0f",
      "categories": "Houdini",
      "tags": "Python Git GitHub gitkraken",
      "articleId": 2016120901,
      "summary": {
          "ja": "この記事は、GitHubで公開されているHoudini Toolset「Bento」を紹介しています。Bentoは、Cache Dependency、Create Delayed Load Procedural、Cache Managerなどのツールを含むオープンソースのツールセットです。各ツールの機能やインストール方法についても説明しています​",
          "en": "This article introduces the Houdini Toolset \"Bento\" available on GitHub, Bento is an open source Cache Dependency, Create Delayed Load Procedural, Cache Manager, and more. It also explains the function of each tool and how to install them."
      }
  },
  {
      "thumbnailUrl": "2016121001.jpg",
      "creationDate": "2016-12-10",
      "author": {
          "name": "@_ShoHey_",
          "twitterIcon": "_ShoHey_.jpg",
          "qiitaUrl": "https://qiita.com/_ShoHey_",
          "twitterUrl": "https://twitter.com/_ShoHey_"
      },
      "title": {
          "ja": "Wrangleを使おう3 「Replace \"For Loop Sop\"」",
          "en": "Using Wrangle 3 - Replace ForLoop"
      },
      "articleUrl": "http://fxnomemo.blogspot.jp/2016/12/wrangle-3-replace-forloop.html",
      "categories": "Houdini",
      "tags": "SOP Wrangle",
      "articleId": 2016121001,
      "summary": {
          "ja": "この記事では、Houdini内でのWrangleの使用方法とその効率化について説明しています。特に、For LoopとAttribute Promoteノードの代わりにWrangleを使用することで、処理速度を向上させる方法を解説しています。Voronoiで分割された各ピースの面積計算を例に、nuniqueval()、uniqueval()、findattribvalcount()、findattribval()などの関数を用いてWrangleで処理を実行する方法を紹介し、その速度の向上を具体的なデータで示しています。記事は、Wrangleの有効利用と処理の最適化に重点を置いています。",
          "en": "This article describes how to use Wrangle within Houdini and how to make it more efficient. In particular, it explains how to increase processing speed by using Wrangle instead of the For Loop and Attribute Promote nodes, using the calculation of the area of each piece divided in Voronoi as an example, nuniqueval(), uniqueval(), findattribvalcount(), findattribval(), and other functions to perform the process in Wrangle, and shows the improvement in speed with concrete data. The article focuses on the effective use of Wrangle and optimizing processing."
      }
  },
  {
      "thumbnailUrl": "2016121101.jpg",
      "creationDate": "2016-12-11",
      "author": {
          "name": "@satoruhiga",
          "twitterIcon": "satoruhiga.jpg",
          "qiitaUrl": "https://qiita.com/satoruhiga",
          "twitterUrl": "https://twitter.com/satoruhiga"
      },
      "title": {
          "ja": "HDKについて",
          "en": "About HDK"
      },
      "articleUrl": "https://qiita.com/satoruhiga/items/49f8fa93307350e3c662",
      "categories": "Houdini",
      "tags": "HDK C++ Python",
      "articleId": 2016121101,
      "summary": {
          "ja": "HDKはHoudiniのC++ベースのプログラミング環境で、ノードプラグインの作成に利用される。記事では、開発環境のセットアップ方法、サンプルプロジェクトのビルド手順、Visual Studioを使ったプロジェクトの作成とカスタムプラグインのビルド方法を詳細に説明。HDKのポテンシャルとして、C++のライブラリ活用や他のアプリケーションとの高速連携が挙げられる​",
          "en": "An in-depth guide on HDK, a C++ based programming environment in Houdini for creating node plugins. Covers setting up development environment, building sample projects, and creating custom plugins using Visual Studio. Highlights the potential of HDK in utilizing C++ libraries and fast integration with other applications​​."
      }
  },
  {
      "thumbnailUrl": "2016121201.jpg",
      "creationDate": "2016-12-12",
      "author": {
          "name": "@sugiggy",
          "twitterIcon": "sugiggy.jpg",
          "qiitaUrl": "https://qiita.com/sugiggy",
          "twitterUrl": "https://twitter.com/sugiggy"
      },
      "title": {
          "ja": "触ったものから動きだすキッカケを作る２つの方法。",
          "en": "Two Methods to Make Objects Move When Touched "
      },
      "articleUrl": "http://sugi-iggy.blogspot.ca/2016/12/blog-post.html",
      "categories": "Houdini",
      "tags": "SOP CHOP",
      "articleId": 2016121201,
      "summary": {
          "ja": "Houdiniでオブジェクトが触れられた順に動き出すアニメーションを作る2つの手法を紹介。1つ目はsolver sopを使った方法、2つ目はchopを利用した方法。それぞれの手順と必要なノードの設定方法が詳しく解説されている​",
          "en": "Presents two methods in Houdini for creating animations where objects move when touched. The first method uses solver sop, and the second utilizes chop, with detailed steps and node configuration for each​​."
      }
  },
  {
      "thumbnailUrl": "2016121301.jpg",
      "creationDate": "2016-12-13",
      "author": {
          "name": "@kit2cuz",
          "twitterIcon": "kit2cuz.jpg",
          "qiitaUrl": "https://qiita.com/kit2cuz",
          "twitterUrl": "https://twitter.com/kit2cuz"
      },
      "title": {
          "ja": "PythonによるAlembicの情報取得",
          "en": "Retrieving Alembic Information with Python"
      },
      "articleUrl": "https://qiita.com/kit2cuz/items/f1704b3c9205dbb47775",
      "categories": "Houdini",
      "tags": "Alembic Python",
      "articleId": 2016121301,
      "summary": {
          "ja": "HoudiniのPythonを使ってAlembicファイルのデータを取得する方法。_alembic_hom_extensionsモジュールを利用し、オブジェクトの階層構造、アニメーション範囲、トランスフォーム情報を抽出する手法を解説。さらに、カスタム関数をシーンファイルに登録し、Alembicオブジェクトのアニメーションカーブを操作する方法が紹介されている​",
          "en": "Describes using Python in Houdini to extract data from Alembic files, focusing on _alembic_hom_extensions module. Explains extracting object hierarchy, animation ranges, and transform information. Additionally, shows how to register custom functions in scene files for manipulating animation curves of Alembic objects​​."
      }
  },
  {
      "thumbnailUrl": "2016121401.jpg",
      "creationDate": "2016-12-14",
      "author": {
          "name": "@yuya_torii",
          "twitterIcon": "yuya_torii.jpg",
          "qiitaUrl": "https://qiita.com/yuya_torii",
          "twitterUrl": "https://twitter.com/yuya_torii"
      },
      "title": {
          "ja": "Wrangle + SolverSOPでツタを這わせる",
          "en": "Creating Climbing Ivy Animation with Wrangle + SolverSOP"
      },
      "articleUrl": "https://qiita.com/yuya_torii/items/fd34f265e8d4a3887eee",
      "categories": "Houdini",
      "tags": "SOP Wrangle",
      "articleId": 2016121401,
      "summary": {
        "ja": "Houdiniでツタが成長するアニメーションを作るプロセスを解説。SolverSOPとwrangleを用いて、ツタの成長方向の制御、分岐の作成、動きのブレを加える手法などが紹介されている。ツタの自然な成長をシミュレートするためのさまざまなステップが説明されている",
        "en": "Explains creating ivy growth animations in Houdini using SolverSOP and wrangle. Discusses controlling growth direction, creating branches, and adding movement variation. Various steps to simulate natural ivy growth are detailed​​."
    }
  },
  {
      "thumbnailUrl": "2016121501.jpg",
      "creationDate": "2016-12-15",
      "author": {
          "name": "@shige_ktgw",
          "twitterIcon": "shige_ktgw.jpg",
          "qiitaUrl": "https://qiita.com/shige_ktgw",
          "twitterUrl": "https://twitter.com/shige_ktgw"
      },
      "title": {
          "ja": "L-system概要と作例01",
          "en": "L-system Overview and Example 01"
      },
      "articleUrl": "http://nomoreretake.net/2016/12/15/houdini_l-system_intro/",
      "categories": "Houdini",
      "tags": "Lsystem SOP",
      "articleId": 2016121501,
      "summary": {
        "ja": "記事では、HoudiniのL-Systemノードについて解説しています。L-Systemは、特定のルールに基づいて反復処理を行い、枝分かれする現象を表現できるツールです。この記事では、L-Systemの作成に必要な3つの工程、ルールの設定、数値の設定、反復回数の決定について詳しく説明しています。また、標準プリセットにない様々なL-Systemの例を紹介しています。",
        "en": "The article discusses Houdini's L-System node, a tool that allows you to iterate based on specific rules to represent branching phenomena. This article details the three steps required to create an L-System: setting the rules, setting the values, and determining the number of iterations. It also provides examples of various L-Systems that are not in the standard presets."
      }
  },
  {
      "thumbnailUrl": "2016121601.jpg",
      "creationDate": "2016-12-16",
      "author": {
          "name": "@shige_ktgw",
          "twitterIcon": "shige_ktgw.jpg",
          "qiitaUrl": "https://qiita.com/shige_ktgw",
          "twitterUrl": "https://twitter.com/shige_ktgw"
      },
      "title": {
          "ja": "L-system 作例02",
          "en": "L-system Overview and Example 02"
      },
      "articleUrl": "http://nomoreretake.net/2016/12/16/houdinil_system_sample02/",
      "categories": "Houdini",
      "tags": "Lsystem SOP",
      "articleId": 2016121601,
      "summary": {
          "ja": "この記事では、HoudiniのL-Systemを使用した様々な作例を紹介しています。例えば、2次元および3次元のヒルベルト曲線、複数のコッホ曲線バリエーション、シェルピンスキーのギャレットなどがあります。また、雪の結晶のような図形を作成する方法や、Copy(SOP)を使ったパターンの回転と増加についても説明しています。各サンプルでは、Premise、Rule、Angle、Generationsなどのパラメータが設定されています。これらの作例は、L-Systemの柔軟性と多様性を示しています。",
          "en": "This article presents various examples of work using Houdini's L-System. Examples include 2D and 3D Hilbert curves, multiple Koch curve variations, and Sierpinski's Garrett. It also explains how to create snowflake-like shapes and how to rotate and increase patterns using Copy(SOP). Each sample has parameters such as Premise, Rule, Angle, and Generations. These examples demonstrate the flexibility and versatility of the L-System."
      }
  },
  {
      "thumbnailUrl": "2016121701.jpg",
      "creationDate": "2016-12-17",
      "author": {
          "name": "@kit2cuz",
          "twitterIcon": "kit2cuz.jpg",
          "qiitaUrl": "https://qiita.com/kit2cuz",
          "twitterUrl": "https://twitter.com/kit2cuz"
      },
      "title": {
          "ja": "VEXスニペットの登録の方法と内積について",
          "en": "Registering VEX Snippets and Understanding Dot Products"
      },
      "articleUrl": "https://qiita.com/kit2cuz/items/ba67b8dee3fd5d0de479",
      "categories": "Houdini",
      "tags": "SOP VEX Wrangle",
      "articleId": 2016121701,
      "summary": {
          "ja": "VEXスニペットの登録方法について解説。VEXスニペットは、WrangleノードのVEXpressionパラメータ横のリストに表示されるコードで、ユーザー設定フォルダにあるVEXpressions.txtファイルにコードを記述して独自のスニペットを作成できる。また、内積の使い方を説明し、ベクトルの方向や距離に基づいてポイントの捻りを表現する方法を紹介",
          "en": " Explains how to register VEX snippets in Houdini. VEX snippets are code listed next to the VEXpression parameter in Wrangle nodes, and users can create their snippets by writing code in the VEXpressions.txt file located in the user settings folder. The article also explains the use of dot products to represent twists in points based on vector direction and distance."
      }
  },
  {
      "thumbnailUrl": "2016121801.jpg",
      "creationDate": "2016-12-18",
      "author": {
          "name": "@Yamabe_Michiyoshi",
          "twitterIcon": "Yamabe_Michiyoshi.jpg",
          "qiitaUrl": "https://qiita.com/Yamabe_Michiyoshi",
          "twitterUrl": "https://twitter.com/Yamabe_Michiyoshi"
      },
      "title": {
          "ja": "Interactive Houdini",
          "en": "Interactive Houdini"
      },
      "articleUrl": "http://www.technical-artist.net/?p=1217",
      "categories": "Houdini",
      "tags": "SOP CHOP",
      "articleId": 2016121801,
      "summary": {
          "ja": "Houdiniで外部デバイスからのデータをインタラクティブに取り込む方法を解説。マウス、ペンタブレット、キーボード、MIDIコントローラを使用してHoudiniにデータを入力する例を提示。CHOP（Channel Operator）を用いてデータを記録し、再生するプロセスを説明し、これを応用して様々なインタラクティブなビジュアルを作成することが可能であることを示している",
          "en": "Explains how to interactively import data from external devices in Houdini. Provides examples of using a mouse, pen tablet, keyboard, and MIDI controller to input data into Houdini; describes the process of recording and playing back data using CHOP (Channel Operator), and shows how this can be applied to create a variety of interactive visuals. The presentation shows how this can be applied to create a variety of interactive visuals."
      }
  },
  {
      "thumbnailUrl": "2016121901.jpg",
      "creationDate": "2016-12-19",
      "author": {
          "name": "@it_ks",
          "twitterIcon": "it_ks.jpg",
          "qiitaUrl": "https://qiita.com/it_ks",
          "twitterUrl": "https://twitter.com/it_ks"
      },
      "title": {
          "ja": "ノードっていくつあるんですか？",
          "en": "How many nodes are there?"
      },
      "articleUrl": "https://qiita.com/it_ks/items/08f6027ffd0aa9fab079",
      "categories": "Houdini",
      "tags": "Python",
      "articleId": 2016121901,
      "summary": {
          "ja": "Houdiniのノード数をカウントする方法について解説。houモジュールとNodeTypeを用いて、各ノードカテゴリ内のノード数を確認し、その結果を数値で示している。具体的には、CHOPノードカテゴリ内のノード数が103であることを例に挙げ、プログラミングを通してHoudini内のノード構成を分析している",
          "en": "Describes a method to count the number of nodes in Houdini. Using the hou module and NodeType, it checks the number of nodes in each node category and presents the results numerically. For example, it identifies 103 nodes within the CHOP node category, analyzing Houdini's node structure through programming."
      }
  },
  {
      "thumbnailUrl": "2016122001.jpg",
      "creationDate": "2016-12-20",
      "author": {
          "name": "@yone80@github",
          "twitterIcon": "yone80@github.jpg",
          "qiitaUrl": "https://qiita.com/yone80@github",
          "twitterUrl": "https://twitter.com/yone80"
      },
      "title": {
          "ja": "[記事削除済み] 四角ポリゴンに合わせて変形",
          "en": "[Article deleted] Transform to fit square polygons"
      },
      "articleUrl": "http://qiita.com/yone80@github/items/e373c104520c38bd9610",
      "categories": "Houdini",
      "tags": "SOP Wrangle",
      "articleId": 2016122001,
      "summary": {
          "ja": "この記事では、Houdiniを使用してジオメトリの複製と変形を行う方法を紹介していました。基本構成はシンプルで、GEO、REST、REFERENCEというNull SOPが使用されています。変形にはMatch Size SOPでサイズ調整、Attribute Wrangle SOPで必要な属性を設定し、Normal SOPでポイントのNを生成します。その後、Match Topology SOPと「deform」Attribute Wrangle SOPによってジオメトリを変形し、「check_geo」Attribute Wrangle SOPとSwitch SOPで形状の一致をチェックしています。",
          "en": "This article showed how to duplicate and deform geometry using Houdini. The basic structure is simple: the Null SOPs GEO, REST, and REFERENCE are used. For deformation, the Match Size SOP is used to adjust the size, the Attribute Wrangle SOP is used to set the necessary attributes, and the Normal SOP generates the N for the points. The geometry is then deformed by the Match Topology SOP and \"deform\" Attribute Wrangle SOP, and the shape match is checked by the \"check_geo\" Attribute Wrangle SOP and Switch SOP."
      }
  },
  {
      "thumbnailUrl": "2016122101.jpg",
      "creationDate": "2016-12-21",
      "author": {
          "name": "@jyouryuusui",
          "twitterIcon": "jyouryuusui.jpg",
          "qiitaUrl": "https://qiita.com/jyouryuusui",
          "twitterUrl": "https://twitter.com/jyouryuusui"
      },
      "title": {
          "ja": "隣の面をハーフエッジやバーテックスから求める",
          "en": "Finding Adjacent Faces Using Half-Edges and Vertices"
      },
      "articleUrl": "https://qiita.com/jyouryuusui/items/bddbb3e249f37c2a3cab",
      "categories": "Houdini",
      "tags": "SOP Wrangle",
      "articleId": 2016122101,
      "summary": {
          "ja": "Houdiniにおいて、隣接する面を特定する方法を解説。groupSOPを利用した方法やハーフエッジ、バーテックスを用いた方法を通じて、ポリゴンの隣接関係を解析する。四角形ポリゴンに限定されるが、ポイントとバーテックスの関係を用いて隣接するプリミティブを特定する手法を提供している",
          "en": "Explains how to identify adjacent faces in Houdini. Discusses methods using groupSOP, half-edges, and vertices to analyze polygon adjacency. Although limited to quadrilateral polygons, the article offers methods to identify neighboring primitives using relationships between points and vertices."
      }
  },
  {
      "thumbnailUrl": "2016122201.jpg",
      "creationDate": "2016-12-22",
      "author": {
          "name": "@hiroakit",
          "twitterIcon": "hiroakit.jpg",
          "qiitaUrl": "https://qiita.com/hiroakit",
          "twitterUrl": "https://twitter.com/hiroakit"
      },
      "title": {
          "ja": "HoudiniをAzure NV仮想マシンで動かす",
          "en": "Running Houdini in an Azure NV virtual machine"
      },
      "articleUrl": "https://qiita.com/hiroakit/items/54f7eeb43cb232f8cbde",
      "categories": "Houdini",
      "tags": "Azure",
      "articleId": 2016122201,
      "summary": {
          "ja": "この記事では、エフェクト作成時の待機時間を高性能なマシンで短縮する方法について説明しています。MicrosoftのAzure NV仮想マシンを使用し、NVIDIA Tesla M60 GPUを搭載した仮想マシンでHoudiniを動かします。料金は従量課金制で、具体的な料金表も提示されています。Houdiniの処理時間をNV6とNV24で比較し、コア数が増えると所要時間が短縮されることを実証しています。最後には、Azure NV仮想マシンのセットアップ方法を簡単に説明しています。",
          "en": "The article discusses reducing the waiting time during effect creation using high-performance machines. It explains using Microsoft's Azure NV virtual machines, equipped with NVIDIA Tesla M60 GPUs, to run Houdini. The pricing is pay-as-you-go, with detailed rates provided. A comparison between Houdini's processing times on NV6 and NV24 shows reduced times with increased core numbers. The article also briefly describes how to set up an Azure NV virtual machine."
      }
  },
  {
      "thumbnailUrl": "2016122301.jpg",
      "creationDate": "2016-12-23",
      "author": {
          "name": "@yone80@github",
          "twitterIcon": "yone80@github.jpg",
          "qiitaUrl": "https://qiita.com/yone80@github",
          "twitterUrl": "https://twitter.com/yone80"
      },
      "title": {
          "ja": "[記事削除済み] アトリビュートの型修飾子 (Type qualifire) について",
          "en": "[Article deleted] About Attribute Type Qualifiers (Type qualifire)"
      },
      "articleUrl": "http://qiita.com/yone80@github/items/65e0104e80519ca55c4b",
      "categories": "Houdini",
      "tags": "SOP VEX",
      "articleId": 2016122301,
      "summary": {
          "ja": "この記事では、Houdiniでの型修飾子(Type qualifier)の役割と使用方法について解説していました。型修飾子は、変形時のアトリビュートの扱い方を決定する情報で、Attribute Create SOPのTypeパラメータやVEXのsetattribtypeinfo()関数で設定可能です。変形の影響を受けるかどうかに応じて、Position、Vector、Normal、Color、Quaternion、Transform Matrixなどの型修飾子があります。ただし、Wrangle SOPやVOP SOPで変形する際は型修飾子が付いているアトリビュートを変形しない場合があるため、Normal SOPやAttribute Reorient SOP、Deformation Wrangle SOPを適切に使用することが推奨されています。",
          "en": "This article explained the role and use of type qualifiers (Type qualifier) in Houdini. Type qualifiers are information that determines how attributes are handled during deformation, and can be set using the Type parameter of the Attribute Create SOP or the VEX setattribtypeinfo() function. Depending on whether or not the transformation is affected, there are several type modifiers, including Position, Vector, Normal, Color, Quaternion, and Transform Matrix. However, it is recommended to use the Normal SOP, Attribute Reorient SOP, and Deformation Wrangle SOP appropriately, as the Wrangle SOP and VOP SOP may not deform attributes with type modifiers when deforming with them The Normal SOP, Attribute Reorient SOP and Deformation Wrangle SOP are recommended to be used properly."
      }
  },
  {
      "thumbnailUrl": "2016122401.jpg",
      "creationDate": "2016-12-24",
      "author": {
          "name": "@flatwellrichsum",
          "twitterIcon": "flatwellrichsum.jpg",
          "qiitaUrl": "https://qiita.com/flatwellrichsum",
          "twitterUrl": "https://twitter.com/hiraitoyokazu"
      },
      "title": {
          "ja": "[記事削除済み] SOP作例の一例",
          "en": "[Article deleted] An example of a SOP"
      },
      "articleUrl": "http://graberry.blog70.fc2.com/blog-entry-196.html",
      "categories": "Houdini",
      "tags": "SOP",
      "articleId": 2016122401,
      "summary": {
          "ja": "著者は数ヶ月前からSOPの作例集を作成し、新入社員にSOPの感覚を鍛えさせている。例として「粘着式クリーナー（コロコロ）」の作成方法を紹介。これはxyzdist()とprimuv()関数を用いて実装されており、他の方法も可能とのこと。",
          "en": "The author has been creating a collection of SOP examples for several months to train new employees in the sense of SOP. As an example, he shows how to create an \"adhesive cleaner (korokoro)\". This is implemented using the xyzdist() and primuv() functions, and he says other methods are possible."
      }
  },
  {
      "thumbnailUrl": "2016122501.jpg",
      "creationDate": "2016-12-25",
      "author": {
          "name": "@ikatnek",
          "twitterIcon": "ikatnek.jpg",
          "qiitaUrl": "https://qiita.com/ikatnek",
          "twitterUrl": "https://twitter.com/ikatnek"
      },
      "title": {
          "ja": "二つのシミュレーションを作成、片方をもう一方でコントロールする方法",
          "en": "Create two simulations, one controlled by the other"
      },
      "articleUrl": "https://ikatnek.blogspot.ca/p/setting-2-sims.html",
      "categories": "Houdini",
      "tags": "DOP Pyro",
      "articleId": 2016122501,
      "summary": {
          "ja": "この記事では、Pyro（流体）による煙のシミュレーションと独立したパーティクルシミュレーションを作成し、煙がパーティクルをコントロールする方法を紹介しています。まず、Pyro Smokeを使って煙を生成し、独立したパーティクルシミュレーションを別途追加します。パーティクルは最初重力の影響を受けますが、後に重力の効果を無効にして全方向に放射されるようにします。最終的に、POP Advect by Volumesノードを使用してパーティクルが煙の動きに従うように設定します。記事の最後にはシーンファイルへのリンクが含まれています。",
          "en": "This article shows how to create a Pyro (fluid) smoke simulation and an independent particle simulation, where the smoke controls the particles. First, smoke is generated using Pyro Smoke and an independent particle simulation is added separately. The particles are initially affected by gravity, but later the effect of gravity is disabled so that they radiate in all directions. Finally, use the POP Advect by Volumes node to set the particles to follow the motion of the smoke. A link to the scene file is included at the end of the article."
      }
  }






  ,{
    "thumbnailUrl": "2017120101.jpg",
    "creationDate": "2017-12-01",
    "author": {
        "name": "@jyouryuusui",
        "twitterIcon": "jyouryuusui.jpg",
        "qiitaUrl": "https://qiita.com/jyouryuusui",
        "twitterUrl": "https://twitter.com/jyouryuusui"
    },
    "title": {
        "ja": "Step Up Houdini！階段をつくろう",
        "en": "Step Up Houdini! Let's make a staircase!"
    },
    "articleUrl": "https://qiita.com/jyouryuusui/items/ae0e45b6f6acec0bf5c5",
    "categories": "Houdini",
    "tags": "SOP Wrangle",
    "articleId": 2017120101,
    "summary": {
        "ja": "この記事では、Houdiniを使って様々な種類の階段を作成する方法を紹介しています。具体的には、「普通の階段」、「らせん階段」、「ぐにゃぐにゃ階段」、「岩の階段」、「エスカレーター」という5つの異なるタイプの階段の作り方を解説しています。それぞれの階段の作成には、特定のSOPが使用されており、その利用方法についても触れています。この記事は、Houdiniの機能を探求する過程での発見として共有されています。",
        "en": "The article introduces methods to create various types of stairs using Houdini. It covers five different types: Normal Stairs, Spiral Stairs, Wavy Stairs,Rock Stairs, and Escalators. Each type of stair creation uses SOPs, and the article discusses how to use them. The article shares these methods as discoveries made while exploring Houdini's capabilities."
    }
},
{
    "thumbnailUrl": "2017120201.jpg",
    "creationDate": "2017-12-02",
    "author": {
        "name": "@satoruhiga",
        "twitterIcon": "satoruhiga.jpg",
        "qiitaUrl": "https://qiita.com/satoruhiga",
        "twitterUrl": "https://twitter.com/satoruhiga"
    },
    "title": {
        "ja": "HoudiniをOSCタイムラインとして使う",
        "en": "Using Houdini as an OSC Timeline"
    },
    "articleUrl": "https://qiita.com/satoruhiga/items/63fea9616d5135a328d3",
    "categories": "Houdini",
    "tags": "CHOP OSC",
    "articleId": 2017120201,
    "summary": {
        "ja": "この記事では、HoudiniをOSC（OpenSound Control）タイムラインとして使う方法について説明しています。作者はHoudiniのカーブエディタの操作感が好きで、それをリアルタイム系のタイムライン操作に応用したいと考えていました。作成したHDA（Houdini Digital Asset）をObjレベルに設置し、OSCメッセージを送信する設定を行います。TouchDesignerにOSCメッセージを送る例が示されており、インストール方法やOSCの基本的な説明も含まれています。HoudiniのタイムラインをOSCタイムラインとして使うメリットとして、無料であり、カーブエディタの使い勝手が良い点が挙げられています。",
        "en": "The article explains how to use Houdini as an OSC (OpenSound Control) timeline. The author, fond of Houdini's curve editor, wanted to apply it to real-time timeline manipulation. They created an HDA (Houdini Digital Asset) for OSC message transmission, demonstrated with an example of sending OSC messages to TouchDesigner. The article includes the installation process and a basic explanation of OSC. Benefits of using Houdini's timeline as an OSC timeline include it being free and the user-friendly curve editor."
    }
},
{
    "thumbnailUrl": "2017120301.jpg",
    "creationDate": "2017-12-03",
    "author": {
        "name": "@daxanya1",
        "twitterIcon": "daxanya1.jpg",
        "qiitaUrl": "https://qiita.com/daxanya1",
        "twitterUrl": "https://twitter.com/daxanya1"
    },
    "title": {
        "ja": "NetworkEditorをPythonで操作する",
        "en": "Working with NetworkEditor in Python"
    },
    "articleUrl": "https://qiita.com/daxanya1/items/2c3e23cd3cd0eb69eb17",
    "categories": "Houdini",
    "tags": "NetworkEditor Python",
    "articleId": 2017120301,
    "summary": {
        "ja": "この記事では、HoudiniのNetworkEditorをPythonで操作する方法について説明しています。ノードを手動で配置する際のレイアウトの問題を解決するために、Pythonを使用してNetworkEditorを制御する方法を紹介しています。記事では、階層の移動、フラッシュメッセージの表示、背景画像の表示、座標系の確認とノードの配置操作など、NetworkEditorのさまざまな機能をPythonで操作する方法を示しています。これには、特定のPythonスクリプトを実行することで、ノードを自動的に配置し、繋げて動かす方法も含まれています。",
        "en": "The article explains how to operate Houdini's NetworkEditor using Python. It introduces a method to control the NetworkEditor with Python to solve layout issues when manually placing nodes. The article shows how to use Python to perform various functions in the NetworkEditor, including moving hierarchies, displaying flash messages, showing background images, and managing coordinates and node placement. It includes methods to automatically place, connect, and move nodes by executing specific Python scripts."
    }
},
{
    "thumbnailUrl": "2017120401.jpg",
    "creationDate": "2017-12-04",
    "author": {
        "name": "@fujitarium",
        "twitterIcon": "fujitarium.jpg",
        "qiitaUrl": "https://qiita.com/fujitarium",
        "twitterUrl": "https://twitter.com/fujitarium"
    },
    "title": {
        "ja": "動くオブジェクトへのSDFスティッキーコリジョン",
        "en": "SDF sticky collision to moving objects"
    },
    "articleUrl": "http://blog.livedoor.jp/fujitarium/archives/52440138.html",
    "categories": "Houdini",
    "tags": "SOP DOP SDF",
    "articleId": 2017120401,
    "summary": {
        "ja": "この記事では、非常に速い動きのアニメーションにパーティクルを付与する方法について説明されています。使用される技術にはSDFコリジョンが含まれます。著者は標準コリジョンの使い方を知らないため、既存の知識で望ましい結果を得る方法を好んでいます。加速を考慮した摩擦を含むスティッキーコリジョンの実践経験はなく、一定の速度でオブジェクトに沿わせる方法がコントロールしやすいと述べています。最後に、Solver内の要素の順序を意識することの重要性について強調しています。",
        "en": "This article describes how to add particles to a very fast-moving animation. Techniques used include SDF collisions. The author does not know how to use standard collisions and prefers to use existing knowledge to achieve the desired results. He has no practical experience with sticky collisions that include friction to account for acceleration and states that the method of following an object at a constant speed is easier to control. Finally, he stresses the importance of being aware of the order of elements within Solver."
    }
},
{
    "thumbnailUrl": "2017120501.jpg",
    "creationDate": "2017-12-05",
    "author": {
        "name": "@eiji_s",
        "twitterIcon": "eiji_s.jpg",
        "qiitaUrl": "https://qiita.com/eiji_s",
        "twitterUrl": "https://twitter.com/eiji_s"
    },
    "title": {
        "ja": "前回IFDワークフローで説明できなかったスタイルシートとCVEXを使ったランダマイズの仕方について説明します",
        "en": "This section explains how to use style sheets and CVEX for randomization, which was not explained in the previous IFD workflow."
    },
    "articleUrl": "http://houdini.indyzone.jp/blog/stylesheet_cvex/",
    "categories": "Houdini",
    "tags": "MAT SHOP CVEX",
    "articleId": 2017120501,
    "summary": {
        "ja": "この記事では、Houdiniのスタイルシートを使用してCVEXシェーダーを用いてパラメータをランダマイズする方法について説明されています。まず、オブジェクトをコピーし、スタイルシートでシェーダーを割り当てます。次に、CVEXシェーダーを作成し、指定したパラメータに基づいてランダムな色を生成します。スタイルシートでは、オーバーライドスクリプトを使って基本色を変更し、CVEXシェーダーを指定します。さらに、CVEXシェーダーの出力を２つ作成し、レンダリングプロパティもランダムに変更しています。この方法で、シェーディング品質をランダマイズし、ディスプレイスメントの解像度を変更することができます。記事の最後には、スタイルシートとCVEXのデータフローを示す図が掲載されています。著者は、この手法が実用的でないかもしれないが、スタイルシートの使い方を覚えるのに役立つと述べています。",
        "en": "This article describes how to use a Houdini stylesheet to randomize parameters using CVEX shaders. First, copy the object and assign shaders in the stylesheet. Next, a CVEX shader is created to generate random colors based on the specified parameters. In the style sheet, use an override script to change the base color and specify the CVEX shader. It also creates two outputs of the CVEX shader and randomly changes the rendering properties. In this way, we can randomize the shading quality and change the resolution of the displacement. The article ends with a diagram showing the data flow of the stylesheet and CVEX. The author states that this technique may not be practical, but it is helpful to learn how to use style sheets."
    }
},
{
    "thumbnailUrl": "2017120601.jpg",
    "creationDate": "2017-12-06",
    "author": {
        "name": "@sugiggy",
        "twitterIcon": "sugiggy.jpg",
        "qiitaUrl": "https://qiita.com/sugiggy",
        "twitterUrl": "https://twitter.com/sugiggy"
    },
    "title": {
        "ja": "好きな方向にグラデーションを。",
        "en": "Gradient in any direction."
    },
    "articleUrl": "http://sugi-iggy.blogspot.ca/2017/12/blog-post.html",
    "categories": "Houdini",
    "tags": "SOP Wrangle",
    "articleId": 2017120601,
    "summary": {
        "ja": "この記事では、動くオブジェクトに対して特定の方向にグラデーションを適用する方法を紹介しています。例として、自転しながら動くオブジェクトに0から1.0の値のグラデーションを作る方法を説明します。このプロセスには、オブジェクトの中心座標から各ポイントの位置を引いて、得られたローカルポジションとある方向のベクトル（'dir'）を内積することで、ポイント毎にその方向の成分を計算します。内積の結果は正規化されておらず、全体の最大値と最小値を用いて適切なグラデーションの範囲に調整します。この方法により、どんな複雑な形状や動きをしているオブジェクトにも、望む方向にグラデーションを適用できます。",
        "en": "This article shows how to apply a gradient to a moving object in a specific direction. As an example, we will show how to create a gradient with a value from 0 to 1.0 on a moving object as it spins. The process involves subtracting the position of each point from the object's center coordinates and then inner-producting the resulting local position with a vector in a certain direction ('dir') to compute a component in that direction for each point. The result of the inner product is not normalized and is adjusted to the appropriate gradient range using the overall maximum and minimum values. This method allows you to apply a gradient in any desired direction to any object of any complex shape or motion."
    }
},
{
    "thumbnailUrl": "2017120701.jpg",
    "creationDate": "2017-12-07",
    "author": {
        "name": "@kit2cuz",
        "twitterIcon": "kit2cuz.jpg",
        "qiitaUrl": "https://qiita.com/kit2cuz",
        "twitterUrl": "https://twitter.com/kit2cuz"
    },
    "title": {
        "ja": "Wren ROPの使い方とSOHOによる外部アプリとのパイプ",
        "en": "How to use Wren ROP and pipe with external apps by SOHO"
    },
    "articleUrl": "https://qiita.com/kit2cuz/items/0acc5b6352129db587cb",
    "categories": "Houdini",
    "tags": "SOP ROP Python SOHO",
    "articleId": 2017120701,
    "summary": {
        "ja": "この記事では、HoudiniのベクトルレンダラーWren ROPの使用法とSOHOによる外部アプリとの連携について解説しています。主要な手順には、Houdiniの3Dシーンからベクトルデータを生成し、他のソフトウェアで読み込む方法、ポリゴンカーブをNURBSカーブに変換するプロセス、そしてHoudiniからFreeCADへのパイプを組み込んでSVGに変換する方法が含まれます。また、HoudiniとMaya間の接続方法や、Wren ROPの特徴、Postscriptファイルの扱いに関する技術的詳細も提供されています。",
        "en": "This article describes the use of Houdini's vector renderer Wren ROP and its integration with external applications through SOHO. Key steps include how to generate vector data from a Houdini 3D scene and load it into other software, the process of converting polygon curves to NURBS curves, and how to incorporate a pipe from Houdini to FreeCAD to convert to SVG. Also provided are technical details on how to connect between Houdini and Maya, Wren ROP features, and postscript file handling."
    }
},
{
    "thumbnailUrl": "2017120801.jpg",
    "creationDate": "2017-12-08",
    "author": {
        "name": "@yone80@github",
        "twitterIcon": "yone80@github.jpg",
        "qiitaUrl": "https://qiita.com/yone80@github",
        "twitterUrl": "https://twitter.com/yone80"
    },
    "title": {
        "ja": "[記事削除済み] Group の作り方いろいろ",
        "en": "[Article deleted] Various ways to create groups"
    },
    "articleUrl": "https://qiita.com/yone80@github/items/4f77b20e17fa63390e40",
    "categories": "Houdini",
    "tags": "SOP VEX",
    "articleId": 2017120801,
    "summary": {
        "ja": "この記事ではHoudiniでのGroupの作り方についてVEXも交えながら解説されていました。",
        "en": "This article explained how to create a Group in Houdini, including VEX."
    }
},
{
    "thumbnailUrl": "2017120901.jpg",
    "creationDate": "2017-12-09",
    "author": {
        "name": "@hasegawa_t",
        "twitterIcon": "hasegawa_t.jpg",
        "qiitaUrl": "https://qiita.com/hasegawa_t",
        "twitterUrl": "https://twitter.com/hasegawa_t"
    },
    "title": {
        "ja": "HoudiniでData Visualization",
        "en": "Data Visualization in Houdini"
    },
    "articleUrl": "https://qiita.com/hasegawa_t/items/ad7fa5d67bdd9f7b864a",
    "categories": "Houdini",
    "tags": "SOP Python Wrangle",
    "articleId": 2017120901,
    "summary": {
        "ja": "この記事は、Houdiniを使用してデータ可視化を行う方法について解説しています。特に地球上の異なる地点間の移動軌跡をアニメーション化する手法が紹介されています。このプロセスには、HoudiniにCSVデータを読み込み、緯度経度を球面座標に変換し、始点から終点に向かって弧を描く尾を持つポイントをアニメーションする手順が含まれます。",
        "en": "This article describes how to use Houdini to perform data visualization. In particular, a method for animating the trajectory of movement between different points on the earth is presented. The process involves loading CSV data into Houdini, converting latitude and longitude to spherical coordinates, and then animating the points with an arc tail from the start point to the end point."
    }
},
{
    "thumbnailUrl": "2017121001.jpg",
    "creationDate": "2017-12-10",
    "author": {
        "name": "@jhorikawa_err",
        "twitterIcon": "jhorikawa_err.jpg",
        "qiitaUrl": "https://qiita.com/jhorikawa_err",
        "twitterUrl": "https://twitter.com/jhorikawa_err"
    },
    "title": {
        "ja": "Houdiniでアルゴリズミック・デザイン～Isosurface編",
        "en": "Algorithmic Design with Houdini - Isosurface Edition"
    },
    "articleUrl": "https://qiita.com/jhorikawa_err/items/66289d6c0ce3f7d5a338",
    "categories": "Houdini",
    "tags": "algorithm VEX isosurface",
    "articleId": 2017121001,
    "summary": {
        "ja": "この記事では、Houdiniを使用してIsosurfaceを作成するプロセスについて詳述されています。Isosurfaceは、空間に分布する点群の数値に基づいて作成される面で、特に建築分野でよく用いられます。この方法では、ボクセル空間に数値を割り当て、Marching Cubeアルゴリズムを用いてメッシュを作成します。手順には、ボクセル空間の作成、数値の割り当て、Houdiniのノードのセットアップ、関数の入力、そして色付けが含まれています。最終的に、数理的に操作されたボクセル空間から興味深い造形を作成できることが強調されています",
        "en": "This article details the process of creating an Isosurface using Houdini; an Isosurface is a surface created based on numerical values of a group of points distributed in space, often used especially in architecture. The method involves assigning numerical values to voxel space and creating a mesh using the Marching Cube algorithm. The procedure includes creating the voxel space, assigning numerical values, setting up the Houdini nodes, entering functions, and coloring. Finally, it is emphasized that interesting shapes can be created from mathematically manipulated voxel space!"
    }
},
{
    "thumbnailUrl": "2017121101.jpg",
    "creationDate": "2017-12-11",
    "author": {
        "name": "@core_aoi",
        "twitterIcon": "core_aoi.jpg",
        "qiitaUrl": "https://qiita.com/core_aoi",
        "twitterUrl": "https://twitter.com/core_aoi"
    },
    "title": {
        "ja": "[記事削除済み] Houdini入門 チュートリアル集(おまけ付き)",
        "en": "[Article deleted] Introduction to Houdini Tutorial Collection (with extras)"
    },
    "articleUrl": "http://design-ambience.com/blog/?p=1108",
    "categories": "Houdini",
    "tags": "bookmark",
    "articleId": 2017121101,
    "summary": {
        "ja": "この記事では、Houdiniに関する初心者向けに役立ったチュートリアルをまとめています。紹介されているチュートリアルは、サッカーボール、ツタの成長、皮膚が剥がれるエフェクト、凍結、抽象的なデザイン、雲、パーティクル、物体の破壊など様々です。また、3DCGのチュートリアルが多く動画形式であること、YouTubeのショートカットキーの利便性、そしてVimeoでYouTubeのようなショートカットを使用できるブックマークレットの作成についても触れています。",
        "en": "This article is a collection of helpful tutorials for beginners on Houdini. The tutorials featured vary from soccer balls, ivy growth, skin peeling effects, freezing, abstract designs, clouds, particles, object destruction, and more. It also discusses the video format of many of the 3DCG tutorials, the convenience of YouTube's shortcut keys, and the creation of bookmarklets that allow you to use YouTube-like shortcuts on Vimeo."
    }
},
{
    "thumbnailUrl": "2017121201.jpg",
    "creationDate": "2017-12-12",
    "author": {
        "name": "@takavfx",
        "twitterIcon": "takavfx.jpg",
        "qiitaUrl": "https://qiita.com/takavfx",
        "twitterUrl": "https://twitter.com/takavfx"
    },
    "title": {
        "ja": "Maya -> Houdini -> Maya",
        "en": "Maya -> Houdini -> Maya"
    },
    "articleUrl": "https://qiita.com/takavfx/items/8665c9c394db7e5b9f95",
    "categories": "Houdini",
    "tags": "SOP Alembic Python",
    "articleId": 2017121201,
    "summary": {
        "ja": "この記事では、HoudiniとMayaを連携させるプロセスについて紹介されています。具体的には、MayaからエクスポートしたAlembicファイルをHoudiniで読み込み、処理後に再びMayaにインポートする方法が説明されています。このプロセスには、Python SOPを使用してプリミティブのパス属性を追加し、ROP Alembic Outputを使って設定を行う手順が含まれています。最終的に、Mayaで元のモデルシーンにAlembicファイルをインポートし、マテリアルを再アサインするスクリプトが提供されています​​​​​​​​​​​​。",
        "en": "This article describes the process of linking Houdini and Maya. Specifically, it explains how to import Alembic files exported from Maya into Houdini and then import them back into Maya after processing. The process includes steps for adding path attributes to primitives using Python SOPs and configuring them using ROP Alembic Output. Finally, a script is provided to import the Alembic file into the original model scene in Maya and reassign the material ."
    }
},
{
    "thumbnailUrl": "2017121301.jpg",
    "creationDate": "2017-12-13",
    "author": {
        "name": "@it_ks",
        "twitterIcon": "it_ks.jpg",
        "qiitaUrl": "https://qiita.com/it_ks",
        "twitterUrl": "https://twitter.com/it_ks"
    },
    "title": {
        "ja": "（きっとそっちじゃない）スワップとフリップについて",
        "en": "(I'm sure it's not that one.) Swaps and Flips"
    },
    "articleUrl": "https://qiita.com/it_ks/items/17e85024e45685de7c24",
    "categories": "Houdini",
    "tags": "layout Python",
    "articleId": 2017121301,
    "summary": {
        "ja": "この記事は、Houdiniのユーザーインターフェイスにおける「スワップ」と「フリップ」の機能に焦点を当てています。スワップはペインの入れ替え、フリップは仕切りの向きを入れ替える機能を指します。記事では、Pythonを用いてHoudiniのデスクトップ環境を操作し、ペインの配置を動的に変更する方法を詳細に説明しています。さらに、splitSwapメソッドを使用してペインのスワップを行う方法や、階層的なsplitの管理についても掘り下げています。また、様々なHoudiniデスクトップ構成（Build、Animate、Games、Groomingなど）の特徴と使い勝手についても解説されています",
        "en": "This article focuses on the \"swap\" and \"flip\" features in the Houdini user interface. Swap refers to the ability to swap panes and flip refers to the ability to swap the orientation of dividers. The article details how to use Python to manipulate the Houdini desktop environment and dynamically change the placement of panes. It also delves into how to swap panes using the splitSwap method and managing hierarchical splits. The features and usability of the various Houdini desktop configurations (Build, Animate, Games, Grooming, etc.) are also described"
    }
},
{
    "thumbnailUrl": "2017121401.jpg",
    "creationDate": "2017-12-14",
    "author": {
        "name": "@yuya_torii",
        "twitterIcon": "yuya_torii.jpg",
        "qiitaUrl": "https://qiita.com/yuya_torii",
        "twitterUrl": "https://twitter.com/yuya_torii"
    },
    "title": {
        "ja": "Houdini Engine For Maya を調べてみる",
        "en": "Check out Houdini Engine For Maya"
    },
    "articleUrl": "https://qiita.com/yuya_torii/items/001642040a5354cd9f89",
    "categories": "Houdini",
    "tags": "MAYA HoudiniEngine HDA",
    "articleId": 2017121401,
    "summary": {
        "ja": "この記事では、Houdini Engine for Mayaについて詳細に解説されています。インストール場所や使えるコマンド、Pythonでの操作方法、データ構造、HoudiniのデータがMayaでどう扱われるか、ObjectとSOPの違い、VolumeとParticleの扱い、Expressionの利用、MayaのノードをHDAに渡す際の挙動、内部アトリビュートについての詳細が説明されています​",
        "en": "This article describes the Houdini Engine for Maya in detail. It details the installation location, available commands, Python operations, data structures, how Houdini data is handled by Maya, the difference between Objects and SOPs, handling volumes and particles, using Expression, behavior when passing Maya nodes to HDA, and internal Attributes are explained in detail."
    }
},
{
    "thumbnailUrl": "2017121501.jpg",
    "creationDate": "2017-12-15",
    "author": {
        "name": "@sho7noka",
        "twitterIcon": "sho7noka.jpg",
        "qiitaUrl": "https://qiita.com/sho7noka",
        "twitterUrl": "https://twitter.com/sho7noka"
    },
    "title": {
        "ja": "hou で覚える Houdini",
        "en": "Learning Houdini with hou"
    },
    "articleUrl": "https://qiita.com/sho7noka/items/17b7963d31ae1fb66f3f",
    "categories": "Houdini",
    "tags": "Python",
    "articleId": 2017121501,
    "summary": {
        "ja": "この記事では、Houdiniのhouモジュールについて、Pythonを使った操作方法が紹介されています。Pythonが使える場所、houモジュールの概要、ノード操作、プロパティの変更、パラメータ操作、エクスプレッション、キーフレーム、ジオメトリ(SOP)、VEX & Wrangleの使い方について説明されており、PythonからHoudiniを操作するアプローチが示されています",
        "en": "This article shows how to manipulate Houdini's hou module using Python: where Python can be used, an overview of the hou module, node manipulation, property modification, parameter manipulation, expression, keyframes, and geometry (SOP),VEX & Wrangle are explained and the approach to manipulate Houdini from Python is shown."
    }
},
{
    "thumbnailUrl": "2017121601.jpg",
    "creationDate": "2017-12-16",
    "author": {
        "name": "@AokTky_dori",
        "twitterIcon": "AokTky_dori.jpg",
        "qiitaUrl": "https://qiita.com/AokTky_dori",
        "twitterUrl": "https://twitter.com/AokTky_dori"
    },
    "title": {
        "ja": "Intrinsicを使おう",
        "en": "Use Intrinsic!"
    },
    "articleUrl": "https://qiita.com/AokTky_dori/items/de2007716a6a19f26668",
    "categories": "Houdini",
    "tags": "Intrinsic Wrangle",
    "articleId": 2017121601,
    "summary": {
        "ja": "この記事は、HoudiniのIntrinsicアトリビュートについての解説です。Intrinsicアトリビュートの概念、Primitive IntrinsicやDetail Intrinsicの使用方法、測定値やトランスフォーム、Boundsの扱いなどが紹介されています。また、Intrinsicアトリビュートを使うことによる利点、既存情報の利用方法、ノード数の削減やカスタムアトリビュートの整理への影響についても言及されています​​​​​​​​​",
        "en": "This article is an introduction to Intrinsic attributes in Houdini, including the concept of Intrinsic attributes, the use of Primitive Intrinsic and Detail Intrinsic, and the handling of measurements, transforms, and bounces.Intrinsic Attributes. It also discusses the benefits of using Intrinsic attributes, how to use existing information, and the impact on reducing the number of nodes and organizing custom attributes. "
    }
},
{
    "thumbnailUrl": "2017121701.jpg",
    "creationDate": "2017-12-17",
    "author": {
        "name": "@kickbase",
        "twitterIcon": "kickbase.jpg",
        "qiitaUrl": "https://qiita.com/kickbase",
        "twitterUrl": "https://twitter.com/kickbase"
    },
    "title": {
        "ja": "この1年をHoudiniと共に振り返る",
        "en": "Reflecting on the past year with Houdini "
    },
    "articleUrl": "https://kickbase.net/entry/houdini-study-1st-year",
    "categories": "Houdini",
    "tags": "bookmark study",
    "articleId": 2017121701,
    "summary": {
        "ja": "著者はHoudiniを学び始めて1年が経過したことを振り返り、学習過程での経験を共有しています。公式ビデオチュートリアル、書籍、オンラインワークショップ、セミナーなど多岐にわたる学習資源を利用した経験が語られています。また、独自に主催したもくもく会やHoudini関連のセミナーへの参加経験も紹介されており、Houdini学習における豊富な資源と実践的なアプローチについての洞察が得られます",
        "en": "The author reflects on his first year of learning Houdini and shares his experiences in the learning process. He talks about his experiences using a wide variety of learning resources, including official video tutorials, books, online workshops, and seminars.He also shares his experiences attending independently organized mokumoku-kai and Houdini related seminars, providing insight into the wealth of resources and practical approaches to Houdini learning!"
    }
},
{
    "thumbnailUrl": "2017121801.jpg",
    "creationDate": "2017-12-18",
    "author": {
        "name": "@renkiku",
        "twitterIcon": "renkiku.jpg",
        "qiitaUrl": "https://qiita.com/renkiku",
        "twitterUrl": "https://twitter.com/renkiku"
    },
    "title": {
        "ja": "VDBデータの最適化とレンダリングを効率化するためのデータフロー",
        "en": "Data flow for efficient optimization and rendering of VDB data"
    },
    "articleUrl": "https://qiita.com/renkiku/items/0df37294080ee75486b0",
    "categories": "Houdini",
    "tags": "SOP DOP ROP VDB",
    "articleId": 2017121801,
    "summary": {
        "ja": "この記事では、Houdini内でのVDBデータの最適化とレンダリングの効率化に焦点を当てています。VDBの基本的な概念から始まり、VDBへの変換、不要なデータの削除、データサンプリングの整理、ベクターデータのマージ、データの16bit Floatへの変換、レンダリング時のPacked Primitiveの使用など、VDBを最適化して効率的に扱うための具体的な手順が解説されています",
        "en": "This article focuses on optimizing VDB data and rendering efficiency within Houdini, starting with the basic concepts of VDBs, converting to VDBs, removing unnecessary data, organizing data sampling, merging vector data, and converting data to 16-bit Float, Specific procedures for optimizing and efficiently handling VDBs are explained, including the use of Packed Primitive during rendering"
    }
},
{
    "thumbnailUrl": "2017121901.jpg",
    "creationDate": "2017-12-19",
    "author": {
        "name": "@ikatnek",
        "twitterIcon": "ikatnek.jpg",
        "qiitaUrl": "https://qiita.com/ikatnek",
        "twitterUrl": "https://twitter.com/ikatnek"
    },
    "title": {
        "ja": "GameDev Impostor Tool",
        "en": "GameDev Impostor Tool"
    },
    "articleUrl": "https://ikatnek.blogspot.com/2017/12/game-dev-impostor-tool.html",
    "categories": "Houdini",
    "tags": "SOP ROP",
    "articleId": 2017121901,
    "summary": {
        "ja": "この記事では、HoudiniのGame Dev Impostor Toolを使用してアニメーションテクスチャを作成する方法を説明しています。使用されたビルドは16.5.323、Game Development Toolは1.8です。ImpostorツールのAnimation機能を使うには、2017年11月7日以降のGame Development ToolのDevelopment Branchが必要です。記事では、キャラクターを作成し、アニメーションを8フレームに変更する手順を紹介しています。さらに、Impostorの設定として、カメラの作成とROPノードの設定が必要であり、最終的に72枚の画像が出力されます​",
        "en": "This article explains how to create animated textures using the Game Dev Impostor Tool in Houdini. The build used is 16.5.323 and the Game Development Tool is 1.8.To use the Animation feature of the Impostor Tool, you will need the Development Branch of the Game Development Tool after November 7, 2017. The article provides instructions for creating a character and changing the animation to 8 frames. In addition, you will need to create a camera and set up a ROP node as part of the Impostor setup, which will result in a final output of 72 images!"
    }
},
{
    "thumbnailUrl": "2017122001.jpg",
    "creationDate": "2017-12-20",
    "author": {
        "name": "@taikomatsu",
        "twitterIcon": "taikomatsu.jpg",
        "qiitaUrl": "https://qiita.com/taikomatsu",
        "twitterUrl": "https://twitter.com/taikomatsu"
    },
    "title": {
        "ja": "targetvを活用する",
        "en": "Utilize targetv"
    },
    "articleUrl": "https://qiita.com/taikomatsu/items/71d475541eb540705552",
    "categories": "Houdini",
    "tags": "POP DOP",
    "articleId": 2017122001,
    "summary": {
        "ja": "この記事では、HoudiniでPOPを使用してパーティクルシミュレーションを行う際のtargetvとairresistの使い方を解説しています。targetvは、最終的にパーティクルの速度（v）が到達する目標値を指定するもので、airresistはその速度に到達するための抵抗や速度を表します。targetvとairresistは、POP Dragを使用すると自動で設定されます。この機能を風のシミュレーションやカーブフォローなどで応用する方法を紹介しています​",
        "en": "This article explains how to use targetv and airresist when using POP in Houdini for particle simulation. targetv specifies the target value that the particles' velocity (v) will eventually reach, and airresist is the resistance or velocity to reach that velocity. targetv and airresist are set automatically when using POP Drag. Here is how to apply this feature in wind simulation, curve following, etc."
    }
},
{
    "thumbnailUrl": "2017122101.jpg",
    "creationDate": "2017-12-21",
    "author": {
        "name": "@ts_bros",
        "twitterIcon": "ts_bros.jpg",
        "qiitaUrl": "https://qiita.com/ts_bros",
        "twitterUrl": "https://twitter.com/ts_bros"
    },
    "title": {
        "ja": "Mantis_Volume_Simulatorで遊ぼう",
        "en": "Let's play with Mantis_Volume_Simulator!"
    },
    "articleUrl": "https://qiita.com/ts_bros/items/f46a9638226cc23c0d34",
    "categories": "Houdini",
    "tags": "DOP HDA",
    "articleId": 2017122101,
    "summary": {
        "ja": "この記事では、Houdini用のMantis_Volume_Simulator1.0のβ版リリースについて紹介しています。シミュレーションの設定例や、パフォーマンス比較、使用方法に関する詳細が提供されています。特に、シミュレータのOpenCLベースでの最適化や、煙シミュレーションの例が示されています。記事は、このシミュレータを使用して、Grid ControlやTurbulence Flowなどの様々なシミュレーションの学習に役立つことを示しています​",
        "en": "This article describes the beta release of Mantis_Volume_Simulator 1.0 for Houdini. It provides example simulation setups, performance comparisons, and details on how to use it. In particular, the simulator's OpenCL-based optimization and smoke simulation examples are shown. The article shows how the simulator can be used to help learn various simulations such as Grid Control and Turbulence Flow"
    }
},
{
    "thumbnailUrl": "2017122201.jpg",
    "creationDate": "2017-12-22",
    "author": {
        "name": "@K240",
        "twitterIcon": "K240.jpg",
        "qiitaUrl": "https://qiita.com/K240",
        "twitterUrl": "https://twitter.com/K240"
    },
    "title": {
        "ja": "ポリゴン面積を考慮したテクスチャアトラスに関して",
        "en": "Regarding texture atlas considering polygon area"
    },
    "articleUrl": "https://qiita.com/K240/items/3803d3fc1184e1e0e948",
    "categories": "Houdini",
    "tags": "COP Python Wrangle",
    "articleId": 2017122201,
    "summary": {
        "ja": "この記事では、Houdiniを使用してポリゴン面積に基づいたテクスチャアトラスを作成する方法について説明されています。テクスチャアトラスとは、複数の画像を1枚にまとめたもので、ドローコールの軽減に使われます。特に、モデルの大きさを考慮してアトラスを作成する方法が解説されており、シンプルなコードで実装することが目指されています。完成版のノードネットワークやアトラステクスチャ生成の手順が紹介されています​",
        "en": "The article discusses how to create a texture atlas based on polygon area using Houdini. A texture atlas is a single image composed of multiple images, mainly used to reduce draw calls. It particularly focuses on creating atlases considering the size of the model, aiming for implementation with minimal coding. The article includes the final node network and steps for generating the atlas texture​​​​​​​​​​."
    }
},
{
    "thumbnailUrl": "2017122301.jpg",
    "creationDate": "2017-12-23",
    "author": {
        "name": "@YoshiakiHiga",
        "twitterIcon": "YoshiakiHiga.jpg",
        "qiitaUrl": "https://qiita.com/YoshiakiHiga",
        "twitterUrl": "https://twitter.com/YoshiakiHiga"
    },
    "title": {
        "ja": "vopで双曲線関数を組んでみる",
        "en": "Try to set up a hyperbolic function with vop."
    },
    "articleUrl": "https://qiita.com/YoshiakiHiga/items/5412e57ae503f7fcc19e",
    "categories": "Houdini",
    "tags": "VOP SOP",
    "articleId": 2017122301,
    "summary": {
        "ja": "この記事では、HoudiniのVOP（Visual Operators）を使って双曲線関数を組み立てる方法を紹介しています。VEXにはcosh関数があるが、VOPノードにはないことがこの試みの大きな理由です。基本的には直線のカーブを作成し、VOPを適用して双曲線関数を形成します。カーブのセグメントを懸垂化し、最終的にケーブルのような形状を作り出しています。このプロセスは、天井にあるフックに似たイメージを作成することを目的としています​",
        "en": "The article presents a method of constructing hyperbolic functions using Houdini's VOP (Visual Operators). The initiative was largely because the cosh function exists in VEX but not as a VOP node. The approach involves creating a linear curve and applying VOP to form the hyperbolic function. The segments of the curve are suspended to ultimately create a cable-like shape. This process aims to create an image resembling hooks on the ceiling​"
    }
},
{
    "thumbnailUrl": "2017122401.jpg",
    "creationDate": "2017-12-24",
    "author": {
        "name": "@yoong",
        "twitterIcon": "yoong.jpg",
        "qiitaUrl": "https://qiita.com/yoong",
        "twitterUrl": "https://twitter.com/yoong"
    },
    "title": {
        "ja": "Houdini Redshift Rendring Work Flow",
        "en": "Houdini Redshift Rendring Work Flow"
    },
    "articleUrl": "http://yoong-cut-and.blogspot.jp/2017/12/houdini-redshift-rendering-work-flow.html",
    "categories": "Houdini",
    "tags": "SOP ROP Redshift",
    "articleId": 2017122401,
    "summary": {
        "ja": "この記事では、HoudiniでのRedshiftレンダリングの実践的な手法とセッティングについて説明しています。インストールから始め、ライセンスの管理、実写合成用のリファレンス撮影、シーン作成、マテリアル設定、ライティング、サンプリングの最適化、レンダリングまでの工程が詳細に記述されています。特に、Redshiftのサンプリング設定とライトの設定が重要で、これらを調整することでノイズを減らし、より滑らかなレンダリング結果を得ることができます。",
        "en": "The article discusses practical methods and settings for Redshift rendering in Houdini. It covers everything from installation to license management, reference photography for live-action compositing, scene creation, material setup, lighting, optimization of sampling, and rendering. Emphasis is placed on the importance of configuring Redshift's sampling and light settings, highlighting how these adjustments can reduce noise and yield smoother rendering results."
    }
},
{
    "thumbnailUrl": "2017122501.jpg",
    "creationDate": "2017-12-25",
    "author": {
        "name": "@Gold_of_maid",
        "twitterIcon": "Gold_of_maid.jpg",
        "qiitaUrl": "https://qiita.com/Gold_of_maid",
        "twitterUrl": "https://twitter.com/Gold_of_maid"
    },
    "title": {
        "ja": "Houdiniの強み~大量配置編~",
        "en": "Strengths of Houdini ~Massive Placement"
    },
    "articleUrl": "https://qiita.com/Gold_of_maid/items/5dd43789303f6828fc21",
    "categories": "Houdini",
    "tags": "SOP",
    "articleId": 2017122501,
    "summary": {
        "ja": "この記事は、Houdiniでの「copy stamp」機能を使用したオブジェクトの大量配置について説明しています。複雑な地形上にオブジェクトを配置する例を用いて、Houdiniの強力な配置機能の使い方を紹介しています。この機能を使用することで、地形に沿ったオブジェクトの配置が簡単かつ効率的に行えることが強調されています。他のソフトウェアでは複雑な作業が必要な場面でも、Houdiniでは簡単に実現できる点が示されています。",
        "en": " The article explains the use of Houdini's 'copy stamp' feature for mass placement of objects. It demonstrates how to efficiently position objects on complex terrains, highlighting Houdini's powerful arrangement capabilities. The feature allows for easy and efficient placement of objects in accordance with the terrain, a task that would be more complex in other software. The article showcases Houdini's ability to simplify processes that are typically complicated in other applications."
    }
}





,{
  "thumbnailUrl": "2018120101.jpg",
  "creationDate": "2018-12-01",
  "author": {
      "name": "@K240",
      "twitterIcon": "K240.jpg",
      "qiitaUrl": "https://qiita.com/K240",
      "twitterUrl": "https://twitter.com/K240"
  },
  "title": {
      "ja": "アトラステクスチャから軽量なポリゴンを生成するツールの作成",
      "en": "Create a tool to generate lightweight polygons from atlas textures"
  },
  "articleUrl": "https://qiita.com/K240/items/2c159d275a580967d13d",
  "categories": "Houdini",
  "tags": "SOP COP HDA Python",
  "articleId": 2018120101,
  "summary": {
      "ja": "この記事では、アトラステクスチャからカードポリゴンを生成し、描画に優しい形に変換するツールについて紹介しています。Houdini 17の新機能「Python Viewer States」を活用しています。プロセスは、テクスチャの読み込み、境界の調整、テクスチャのトレース、ポリゴンへの変換、矩形化、UVの生成、Pivotの位置調整に分かれています。特に、DilateErodeノードを使った輪郭の調整やPython Viewer Statesの活用が重要です",
      "en": "The article discusses a tool that generates card polygons from atlas textures and converts them into renderer-friendly shapes using Houdini 17's new feature, Python Viewer States. The process involves loading textures, adjusting boundaries, tracing textures to polygons, rectangle conversion, UV generation, and adjusting the pivot position. Key aspects include using the DilateErode node for contour adjustment and leveraging Python Viewer States"
  }
},
{
  "thumbnailUrl": "2018120201.jpg",
  "creationDate": "2018-12-02",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "Houdini Engine API入門",
      "en": "Introduction to Houdini Engine API"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/3d86ab8e69652d5f951c",
  "categories": "Houdini",
  "tags": "HoudiniEngine C++ Qt",
  "articleId": 2018120201,
  "summary": {
      "ja": "この記事では、Houdini Engine APIの基本的な使い方と概要を紹介しています。Houdini Engineは、他のアプリケーションからHoudiniのデジタルアセットにアクセスするための機能であり、C ABI（Application Binary Interface）を用いたC言語の関数セットです。基本的な作業手順としては、Houdini Engineの初期化、アセットノードのインスタンス化とパラメータの設定、オブジェクトノードの問い合わせ、ノードのCook、更新されたノード情報の取得などが含まれます。HAPI_CreateNode関数を使用してノードを作成し、HAPI_ConnectNodeInput関数でノードを接続する方法も説明しています",
      "en": "The article provides an introduction to the basics and overview of Houdini Engine API. Houdini Engine is a feature for accessing Houdini's digital assets from other applications and is a set of C language functions using C ABI. The basic workflow includes initializing Houdini Engine, instantiating asset nodes and setting parameters, querying object nodes, cooking nodes, and retrieving updated node information. The article also explains creating nodes using the HAPI_CreateNode function and connecting nodes with the HAPI_ConnectNodeInput function"
  }
},
{
  "thumbnailUrl": "2018120301.jpg",
  "creationDate": "2018-12-03",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "分布の種類をコントロールする。",
      "en": "Control the type of distribution."
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2018/12/blog-post.html",
  "categories": "Houdini",
  "tags": "SOP Wrangle",
  "articleId": 2018120301,
  "summary": {
      "ja": "この記事では、Houdiniを使用して、スキャッターされる複数のジオメトリの配置に重みをつける方法を紹介しています。具体的には、半径10の円にscatterし、各ポイントにweight属性を割り当てる方法が説明されています。原点からの距離に基づいてweightを決定し、rampで重みを制御します。さらに、0-1の範囲でweight属性をfitし、id属性を作成します。最終的に、idにマッチしたジオメトリが配置されるようにします",
      "en": "The article presents a method to weight the placement of multiple geometries scattered using Houdini. It explains how to scatter across a circle with a radius of 10 and assign a weight attribute to each point. The weight is based on the distance from the origin and controlled via a ramp. The weight attribute is fitted within a 0-1 range, and an id attribute is created. Finally, geometries matching the ids are placed accordingly"
  }
},
{
  "thumbnailUrl": "2018120401.jpg",
  "creationDate": "2018-12-04",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "交点を求める",
      "en": "seek an intersection"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/ef93aeb558f353ab479c",
  "categories": "Houdini",
  "tags": "SOP Wrangle",
  "articleId": 2018120401,
  "summary": {
      "ja": "Houdiniを使って、平面上の直線ABとCDの交点を求める方法について解説しています。内積を用いたベクトル数学と連立方程式を組み合わせる方法が紹介されており、具体的には、点AからB、点CからDへの距離をd1、d2とし、ABとCDのベクトルをそれぞれn1、n2として計算します。線と線の交点、線と線の延長線上の交点、線が平行の場合の処理など、様々なシナリオに対応するための計算方法が示されています。サブルーチンとして定義された関数を用い、PrimitiveWrangleとVertexWrangleのコードも示されています​​​​​​​​​​​​​​。",
      "en": "This article explains how to use Houdini to find the intersection of lines AB and CD on a plane. It introduces a method that combines vector mathematics and simultaneous equations using inner products. Specifically, the distance from point A to B and from point C to D are d1 and d2, and the vectors of AB and CD are calculated as n1 and n2, respectively. Calculation methods are presented to handle various scenarios, such as intersections between lines, intersections on extensions of lines, and when lines are parallel. Using functions defined as subroutines, the PrimitiveWrangle and VertexWrangle codes are also shown The code for PrimitiveWrangle and VertexWrangle is also shown."
  }
},
{
  "thumbnailUrl": "2018120501.jpg",
  "creationDate": "2018-12-05",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "僕なりのHoudini勉強法",
      "en": "My own way of studying Houdini"
  },
  "articleUrl": "https://kickbase.net/entry/houdini-how-to-study",
  "categories": "Houdini",
  "tags": "SOP",
  "articleId": 2018120501,
  "summary": {
      "ja": "Houdiniの初心者向け学習法が紹介されています。学習者はまず、分かるノードと分からないノードを区別し、最小のネットワークを組んでみることから始めます。次に、新しく学んだノードを使って、少し複雑なネットワークを組んでみるというステップを踏みます。この方法は、ノードの理解、記憶、実際の使用を含むイテレーションとして機能し、効率的な学習を促進します。また、hipファイルを使用して実践的な学習を行うことが強調されています​​​​​​​​​​​​​​。",
      "en": "A beginner's approach to learning Houdini is presented. The learner begins by trying to build a minimal network, distinguishing the nodes that are known from those that are not known. The next step is to build a slightly more complex network using the newly learned nodes. This method serves as an iteration that includes understanding, memorizing, and actually using the nodes, facilitating efficient learning. It also emphasizes hands-on learning with the use of HIP files ."
  }
},
{
  "thumbnailUrl": "2018120601.jpg",
  "creationDate": "2018-12-06",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "H17 での Houdini Engine の変更点",
      "en": "Houdini Engine changes in H17"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2018/12/houdini-engine-change-in-h17.html",
  "categories": "Houdini",
  "tags": "HoudiniEngine HARS",
  "articleId": 2018120601,
  "summary": {
      "ja": "Houdini 17でのHoudini Engine for Mayaプラグインの変更点について説明されています。以前のデフォルト設定「Within Maya Process」がサポートされなくなり、Named PipeやTCP Socket方式が新たに採用されました。この変更は、以前の方法がライブラリのコンフリクトを引き起こす可能性があったためです。TCP Socketは、サーバー・クライアント方式を採用し、Houdini Engineの計算をサーバーで行い、Mayaプラグインはその結果を受け取る形になります。この変更により、Mayaが動作しているPCとは別の高性能PCでの演算結果を簡単にMayaで確認できるようになりました​​​​​​​​​​。",
      "en": "The changes to the Houdini Engine for Maya plug-in in Houdini 17 are described. The previous default setting \"Within Maya Process\" is no longer supported, and the Named Pipe and TCP Socket methods are new. This change was made because the previous method could cause library conflicts, and TCP Socket uses a server-client approach, where the Houdini Engine calculations are done on the server and the Maya plug-in receives the results. This change makes it easier for Maya to check the results of calculations on a high-performance PC other than the one on which Maya is running. The Houdini Engine is a new plug-in for the Houdini Engine."
  }
},
{
  "thumbnailUrl": "2018120701.jpg",
  "creationDate": "2018-12-07",
  "author": {
      "name": "@takavfx",
      "twitterIcon": "takavfx.jpg",
      "qiitaUrl": "https://qiita.com/takavfx",
      "twitterUrl": "https://twitter.com/takavfx"
  },
  "title": {
      "ja": "Pixar USD Houdiniプラグインのビルド",
      "en": "Building Pixar USD Houdini Plug-ins"
  },
  "articleUrl": "https://qiita.com/takavfx/items/2b536f2fff583cc47a80",
  "categories": "Houdini",
  "tags": "CMake VisualStudio USD",
  "articleId": 2018120701,
  "summary": {
      "ja": "この記事では、Houdini 17.0.352または17.0.395とWindows 10 (またはWindows 7)、Visual Studio 2017を使用して、Pixar USD Houdiniプラグインのビルド方法について説明しています。ビルド時の問題点として、インストールパスやアイコンファイルの欠如が挙げられ、それらを解決する方法が示されています。また、CMakeでの設定方法や、ビルドする際のベストプラクティスも紹介されており、清潔な環境でのビルドや、後の管理のための手順が詳細に説明されています​​​​​​​​​​。",
      "en": "This article describes how to build the Pixar USD Houdini plugin using Houdini 17.0.352 or 17.0.395, Windows 10 (or Windows 7) and Visual Studio 2017. Problems with the build include missing installation paths and icon files, and how to resolve them is shown. It also shows how to set it up in CMake and best practices for building it, detailing procedures for building in a clean environment and managing it afterwards! ."
  }
},
{
  "thumbnailUrl": "2018120801.jpg",
  "creationDate": "2018-12-08",
  "author": {
      "name": "@Yamabe_Michiyoshi",
      "twitterIcon": "Yamabe_Michiyoshi.jpg",
      "qiitaUrl": "https://qiita.com/Yamabe_Michiyoshi",
      "twitterUrl": "https://twitter.com/Yamabe_Michiyoshi"
  },
  "title": {
      "ja": "Refactoring Node Network - メンテナンス性の高いノードネットワーク構築のために",
      "en": "Refactoring Node Network - For building a highly maintainable node network"
  },
  "articleUrl": "http://www.technical-artist.net/?p=1737",
  "categories": "Houdini",
  "tags": "SOP HDA",
  "articleId": 2018120801,
  "summary": {
      "ja": "Houdiniのノードネットワークのリファクタリングに関する記事です。リファクタリングは、プログラムの外部動作を変えずに内部構造を整理するプロセスで、Houdiniの作業においてもプログラミングと同様の概念が適用されます。リファクタリングのメリットとして、ネットワークの理解が容易になり、修正や拡張が簡単になることが挙げられます。この記事では、名前の変更、アルゴリズムの更新とテスト、関心の分離、処理の集約、処理の再利用などの具体的なリファクタリングの手法が紹介されています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article is about refactoring the Houdini node network. Refactoring is the process of organizing the internal structure of a program without changing its external behavior, and the same concept applies to Houdini work as to programming. One of the benefits of refactoring is that it makes networks easier to understand, modify, and extend. This article presents specific refactoring techniques such as renaming, updating and testing algorithms, isolating interests, consolidating processes, and reusing processes ."
  }
},
{
  "thumbnailUrl": "2018120901.jpg",
  "creationDate": "2018-12-09",
  "author": {
      "name": "@towazumi",
      "twitterIcon": "towazumi.jpg",
      "qiitaUrl": "https://qiita.com/towazumi",
      "twitterUrl": "https://twitter.com/towazumi"
  },
  "title": {
      "ja": "Houdini Python PanelでカスタムUIを作る",
      "en": "Creating a custom UI with Houdini Python Panel"
  },
  "articleUrl": "https://qiita.com/towazumi/items/cb7e5ae0fa609d4294c2",
  "categories": "Houdini",
  "tags": "Python PySide Qt",
  "articleId": 2018120901,
  "summary": {
      "ja": "HoudiniでカスタムUIを作成する方法についての記事です。Python Panelを使ってGUIからHoudini操作を呼び出せるようにする方法が紹介されています。基本的なUIの作成から始め、PySide2によるpythonコードの変更、コードの外部ファイル化、ネットワークエディタからのノードのドラッグ&ドロップ機能の実装について詳細が説明されています。この方法により、より複雑な操作や多くのパラメータを持つ操作を容易に行えるようになります​​​​​​​​​​。",
      "en": "This article on how to create a custom UI in Houdini shows how to use Python Panel to call Houdini operations from the GUI. Starting with the creation of a basic UI, the article details the modification of python code with PySide2, the creation of external files of code, and the implementation of drag-and-drop functionality for nodes from the network editor. This method allows you to easily perform more complex operations and operations with many parameters The following is a list of the most common examples of the new code"
  }
},
{
  "thumbnailUrl": "2018121001.jpg",
  "creationDate": "2018-12-10",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "失ったTransformを取り戻す。",
      "en": "Reclaim lost Transform."
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2018/12/transform.html",
  "categories": "Houdini",
  "tags": "SOP Wrangle",
  "articleId": 2018121001,
  "summary": {
      "ja": "この記事は、ジオメトリの形状からTransform（位置、回転、スケール）を作成し、別のジオメトリに適用する方法について解説しています。ポジションはジオメトリの中心座標を使用し、回転とスケールは特定のポリゴンからN、up、pscaleを計算しています。この方法は、Transformデータが失われたジオメトリに対して有効です。例として、アニメーションされたドーナツ（Torus）ジオメトリにぬいぐるみ（rubbertoy）ジオメトリが追従する様子が示されています。ただし、元のジオメトリの大きさや向きの調整が必要な点に注意が必要です。",
      "en": "This article explains how to create a Transform (position, rotation, scale) from a geometry shape and apply it to another geometry. Position uses the center coordinates of the geometry, while rotation and scale are calculated N, up, and pscale from specific polygons. This method is useful for geometry where Transform data has been lost. As an example, a plush (rubbertoy) geometry is shown following an animated donut (torus) geometry. Note, however, that the size and orientation of the original geometry must be adjusted."
  }
},
{
  "thumbnailUrl": "2018121101.jpg",
  "creationDate": "2018-12-11",
  "author": {
      "name": "@KTK_kumamoto",
      "twitterIcon": "KTK_kumamoto.jpg",
      "qiitaUrl": "https://qiita.com/KTK_kumamoto",
      "twitterUrl": "https://twitter.com/KTK_kumamoto"
  },
  "title": {
      "ja": "ゲームエフェクト Houdiniを使って私がやりたいこと（Houdini歴１年未満）",
      "en": "Game Effects What I want to do with Houdini (less than 1 year of Houdini experience)"
  },
  "articleUrl": "https://qiita.com/KTK_kumamoto/items/15d63d1db65785fde79a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121101,
  "summary": {
      "ja": "この記事では、ゲームエフェクトの制作において、Substance Designerの使用とHoudiniの学習について説明されています。著者は、様々なゲームエフェクトモデルの作成、リアル調やセル調の連番テクスチャー作成にHoudiniを用いることを目指しています。また、炎や煙のシミュレーションのリアルさや、VEX、Wrangleノードのコントロールの重要性についても触れています。著者は、Houdiniのプロシージャルなモデリングの効率的な使い方を将来的に紹介することを目標としています​​​​​​​​​​​​。",
      "en": "This article describes the use of Substance Designer and learning Houdini in the creation of game effects. The author aims to use Houdini for creating various game effects models and creating realistic and cel-like sequential number textures. He also discusses the realism of flame and smoke simulation and the importance of VEX and Wrangle node control. The author aims to show how to use Houdini efficiently for procedural modeling in the future! The author also discusses the use of the Houdini software in the future."
  }
},
{
  "thumbnailUrl": "2018121201.jpg",
  "creationDate": "2018-12-12",
  "author": {
      "name": "@shige_ktgw",
      "twitterIcon": "shige_ktgw.jpg",
      "qiitaUrl": "https://qiita.com/shige_ktgw",
      "twitterUrl": "https://twitter.com/shige_ktgw"
  },
  "title": {
      "ja": "Inherit velocity RBD Packed Object",
      "en": "Inherit velocity RBD Packed Object"
  },
  "articleUrl": "http://nomoreretake.net/2018/12/24/houdini-inherit-velocity-rbd-packed-object/",
  "categories": "Houdini",
  "tags": "SOP DOP",
  "articleId": 2018121201,
  "summary": {
      "ja": "この記事では、RBD Packed ObjectのActive制御と初速度の継承についての方法を紹介しています。具体的には、各破片がActiveになった瞬間に初速度を受け継いで動くシミュレーションに焦点を当てています。初速度は元ジオメトリに設定された速度vを継承します。破片がActive状態になる際に初速の継承を行うための3つの方法が示されており、それぞれの方法についての詳細な説明とサンプルファイルが提供されています。これらの方法は、シミュレーションの多様なニーズに応じて適用されることが示唆されています。",
      "en": "This article shows how to control Active and inherit the initial velocity of an RBD Packed Object. Specifically, it focuses on a simulation in which each piece moves by inheriting its initial velocity at the moment it becomes Active. The initial velocity inherits the velocity v set on the original geometry. Three methods for inheriting the initial velocity when the debris becomes Active are shown, with detailed descriptions and sample files provided for each method. It is suggested that these methods may be applied to meet a variety of simulation needs."
  }
},
{
  "thumbnailUrl": "2018121301.jpg",
  "creationDate": "2018-12-13",
  "author": {
      "name": "@55hertz",
      "twitterIcon": "55hertz.jpg",
      "qiitaUrl": "https://qiita.com/55hertz",
      "twitterUrl": "https://twitter.com/55hertz"
  },
  "title": {
      "ja": "NVIDIA OptiXが静止画とアニメーションで活用できる場面",
      "en": "Situations where NVIDIA OptiX can be used for still images and animation"
  },
  "articleUrl": "https://qiita.com/55hertz/items/188a7e083baff1dd8fe4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121301,
  "summary": {
      "ja": "この記事では、NVIDIAのOptiX denoiserを使用してレンダリング時間を短縮する方法について説明されています。静止画とアニメーションでの比較、レンダリング時間の短縮、画質のトレードオフに焦点を当てています。作者は、OptiXがレンダリング時間の短縮に効果的であるが、品質面での課題も指摘しています​​​",
      "en": "This article describes how to reduce rendering time using NVIDIA's OptiX denoiser. It focuses on comparisons between still and animated images, rendering time reduction, and image quality tradeoffs. The author notes that OptiX is effective in reducing rendering time, but also points out quality challenges"
  }
},
{
  "thumbnailUrl": "2018121401.jpg",
  "creationDate": "2018-12-14",
  "author": {
      "name": "@sho7noka",
      "twitterIcon": "sho7noka.jpg",
      "qiitaUrl": "https://qiita.com/sho7noka",
      "twitterUrl": "https://twitter.com/sho7noka"
  },
  "title": {
      "ja": "怖くないVEX",
      "en": "Fearless VEX"
  },
  "articleUrl": "https://qiita.com/sho7noka/items/f2394d53b8b12f889caa",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121401,
  "summary": {
      "ja": "この記事は、HoudiniのVEX言語についての入門ガイドです。VEXの基本的な特徴や、他のシェーダ言語との比較、ノードベースのプログラミングに関する考察が含まれています。記事は、VEXの学習に対する抵抗を減らすために書かれています​​​​​​​",
      "en": "This article is an introductory guide to the VEX language in Houdini, including a discussion of the basic features of VEX, a comparison to other shader languages, and node-based programming. The article is written to reduce resistance to learning VEX"
  }
},
{
  "thumbnailUrl": "2018121501.jpg",
  "creationDate": "2018-12-15",
  "author": {
      "name": "@yuya_torii",
      "twitterIcon": "yuya_torii.jpg",
      "qiitaUrl": "https://qiita.com/yuya_torii",
      "twitterUrl": "https://twitter.com/yuya_torii"
  },
  "title": {
      "ja": "HoudiniのParameter Interfaceで使えるPython ①",
      "en": "Python for use with Houdini's Parameter Interface ①."
  },
  "articleUrl": "https://qiita.com/yuya_torii/items/9ae1248380c47b79efa3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121501,
  "summary": {
      "ja": "この記事では、HoudiniのParameter Interfaceで使用可能なPythonの使い方について解説しています。Menu Scriptの使用方法、Action Button Script、HDAでのPythonの使用方法に焦点を当てています。具体的なPythonコードの例も提供されています​​​​​​​​​​。",
      "en": "This article describes the use of Python available in Houdini's Parameter Interface, focusing on how to use Menu Script, Action Button Script, and Python in HDA. Specific Python code examples are also provided. The book is available in English, French, German, Italian, French, Spanish, Italian and Japanese."
  }
},
{
  "thumbnailUrl": "2018121601.jpg",
  "creationDate": "2018-12-16",
  "author": {
      "name": "@m__a__",
      "twitterIcon": "m__a__.jpg",
      "qiitaUrl": "https://qiita.com/m__a__",
      "twitterUrl": "https://twitter.com/m__a__"
  },
  "title": {
      "ja": "popの小技",
      "en": "Pop's little tricks"
  },
  "articleUrl": "https://qiita.com/m__a__/items/324c117d7c11e1d459fc",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121601,
  "summary": {
      "ja": "こちらの記事では、Houdiniでpopノードを使用したパーティクルの技術について説明しています。特定の領域のパーティクルを操作する方法や、選択範囲をぼかすための技術が紹介されています​​​​​​​​​​​​​​​​​​。",
      "en": "This article explains particle techniques using pop nodes in Houdini. It shows how to manipulate particles in specific areas and techniques for blurring selections The article explains how to manipulate particles in specific areas and how to blur a selection."
  }
},
{
  "thumbnailUrl": "2018121701.jpg",
  "creationDate": "2018-12-17",
  "author": {
      "name": "@ts_bros",
      "twitterIcon": "ts_bros.jpg",
      "qiitaUrl": "https://qiita.com/ts_bros",
      "twitterUrl": "https://twitter.com/ts_bros"
  },
  "title": {
      "ja": "流体表現に磨きをかける",
      "en": "Refine fluid expression"
  },
  "articleUrl": "https://qiita.com/ts_bros/items/7f0dfa6dd63bc697a48e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121701,
  "summary": {
      "ja": "この記事では、Houdiniを用いた流体表現の技術について説明しています。Animationの基本式、Fluid Dynamics Systemの理解、Volume Displacement、Wavelet TurbulenceとGridRessAdvectionの概念が解説されています​​​​​​​​​​​​。",
      "en": "This article describes the techniques of fluid representation using Houdini, including the basic formulas of Animation, understanding the Fluid Dynamics System, Volume Displacement, Wavelet Turbulence and GridRessAdvection. Wavelet Turbulence and GridRessAdvection are explained. The course is designed to be used by students who are interested in the concept of \"fluid dynamics\"."
  }
},
{
  "thumbnailUrl": "2018121801.jpg",
  "creationDate": "2018-12-18",
  "author": {
      "name": "@sa-k0",
      "twitterIcon": "sa-k0.jpg",
      "qiitaUrl": "https://qiita.com/sa-k0",
      "twitterUrl": "https://twitter.com/sa-k0"
  },
  "title": {
      "ja": "Houdiniで書き出したAlembicファイルをUnityで使うときのTips",
      "en": "Tips for using Alembic files exported by Houdini in Unity"
  },
  "articleUrl": "https://qiita.com/sa-k0/items/6d51e490b4ead1cecb4c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121801,
  "summary": {
      "ja": "この記事では、Houdiniで作成したAlembicファイルをUnityにインポートする際のヒントについて説明しています。Alembicファイルの出力方法、Unityでのインポート方法、色情報やカスタムアトリビュートの扱い方に焦点を当てています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article discusses tips for importing Alembic files created in Houdini into Unity, focusing on how to output Alembic files, import them into Unity, and handle color information and custom attributes!  The following tips and tricks are provided for importing Alembic files into Unity."
  }
},
{
  "thumbnailUrl": "2018121901.jpg",
  "creationDate": "2018-12-19",
  "author": {
      "name": "@AokTky_dori",
      "twitterIcon": "AokTky_dori.jpg",
      "qiitaUrl": "https://qiita.com/AokTky_dori",
      "twitterUrl": "https://twitter.com/AokTky_dori"
  },
  "title": {
      "ja": "addprimでインスタンス",
      "en": "Instance with addprim"
  },
  "articleUrl": "https://qiita.com/AokTky_dori/items/53057591a2c52b7cf15d",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121901,
  "summary": {
      "ja": "この記事では、Houdiniでのインスタンスコピーの方法として、Instance SOP NodeとWrangleを用いた方法が紹介されています。著者は100万ポイントに対して、Instance SOPとWrangleでのパフォーマンスを比較し、Wrangleの方が約8倍速いことを示しています。インスタンス化のためにWrangleでaddprimを使用する方法が、簡単ではないが、HDAにしてしまえば問題ないと述べています​​​​​​​​。",
      "en": "This article shows how to copy instances in Houdini using Instance SOP Node and Wrangle. The author compares performance with Instance SOP and Wrangle for 1 million points and shows that Wrangle is about 8 times faster. He states that the method of using addprim in Wrangle for instantiation is not easy, but once it is HDA, it is not a problem! ."
  }
},
{
  "thumbnailUrl": "2018122001.jpg",
  "creationDate": "2018-12-20",
  "author": {
      "name": "@shige_ktgw",
      "twitterIcon": "shige_ktgw.jpg",
      "qiitaUrl": "https://qiita.com/shige_ktgw",
      "twitterUrl": "https://twitter.com/shige_ktgw"
  },
  "title": {
      "ja": "水を貯める",
      "en": "store water"
  },
  "articleUrl": "http://nomoreretake.net/2018/12/24/houdini_flip_reseed/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122001,
  "summary": {
      "ja": "この記事では、Houdiniを使用して「水を貯める」シミュレーションにおける問題点とその対策について説明されています。FLIPシミュレーションでは、水をビンに溜めると水位が減少する現象が発生しました。この原因は、パーティクルの密度が増加して圧縮されることによるもので、実際のパーティクル数は減っていないことが判明しました。問題を解決するために、FLIP Solver(DOP)のReseedingパラメータを調整しました。このパラメータはパーティクルを追加・削除し、水の量を制御します。Surface OversamplingとBirth Thresholdを変更することで、水位の減少を解消できましたが、この方法が全てのケースに適用できるわけではないとも述べています。",
      "en": "This article describes a problem and its remedy in a \"storing water\" simulation using Houdini: In a FLIP simulation, the water level decreased when water was stored in a bin. It was found that this was caused by an increase in particle density and compression, not a decrease in the actual number of particles. To solve the problem, we adjusted the Reseeding parameter in FLIP Solver (DOP). This parameter adds and removes particles and controls the amount of water; by changing Surface Oversampling and Birth Threshold, we were able to eliminate the reduction in water level, but we also noted that this approach may not be applicable in all cases."
  }
},
{
  "thumbnailUrl": "2018122101.jpg",
  "creationDate": "2018-12-21",
  "author": {
      "name": "@shun-tsumori",
      "twitterIcon": "shun-tsumori.jpg",
      "qiitaUrl": "https://qiita.com/shun-tsumori",
      "twitterUrl": "https://twitter.com/shun-tsumori"
  },
  "title": {
      "ja": "ノード作成時に独自パラメーターを追加する方法",
      "en": "How to add your own parameters when creating a node"
  },
  "articleUrl": "https://qiita.com/shun-tsumori/items/f8d566864feee987ccae",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122101,
  "summary": {
      "ja": "この記事では、Houdiniのノード生成時に独自のパラメーターを追加する方法について説明されています。具体的には、geometryノードに「Backburner」という名前の新たなタブを追加する例が示されています。Houdiniのノードは、parmTemplateGroupという入れ物を持ち、それにパラメーターを追加する方法が紹介されています。この方法を使えば、様々なノードに同じパラメーターを追加することが可能です​​​​​​​​​​​​。",
      "en": "This article explains how to add your own parameters during Houdini node generation. Specifically, it shows an example of adding a new tab named \"Backburner\" to a geometry node, and how Houdini nodes have a container called parmTemplateGroup to which you can add parameters. Using this method, it is possible to add the same parameters to various nodes parmTemplateGroup."
  }
},
{
  "thumbnailUrl": "2018122201.jpg",
  "creationDate": "2018-12-22",
  "author": {
      "name": "@y_yamada",
      "twitterIcon": "y_yamada.jpg",
      "qiitaUrl": "https://qiita.com/y_yamada",
      "twitterUrl": "https://twitter.com/y_yamada"
  },
  "title": {
      "ja": "OpenVDBを使ったリメッシュワーク",
      "en": "Remesh work with OpenVDB"
  },
  "articleUrl": "http://site.cgslab.info/archives/319",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122201,
  "summary": {
      "ja": "この記事では、OpenVDBについて、その基本的な使い方と応用例に焦点を当てて説明しています。OpenVDBは雲や炎、水などのボリュームメトリックシミュレーションに使用され、ジオメトリのボリュームとしての扱いやブーリアン処理にも適しています。記事では、Houdini内のOpenVDBノードの使用方法を紹介し、高解像度メッシュの特定部分を抽出する過程を解説しています。VDB from Polygonsノード、VDB Combineノード、Convert VDBノードの使い方が具体的に説明され、OpenVDBの効率的な利用方法が示されています。また、記事の最後では、実際の使用例の動画も紹介されています。",
      "en": "This article discusses OpenVDB, focusing on its basic usage and applications.OpenVDB is used for volumetric simulations of clouds, flames, water, etc., and is also suitable for treating geometry as volumes and for boolean processing. The article introduces the use of OpenVDB nodes within Houdini and explains the process of extracting specific parts of a high-resolution mesh. is shown in detail and how to use OpenVDB efficiently. At the end of the article, a video of an actual use case is also presented."
  }
},
{
  "thumbnailUrl": "2018122301.jpg",
  "creationDate": "2018-12-23",
  "author": {
      "name": "@jhorikawa_err",
      "twitterIcon": "jhorikawa_err.jpg",
      "qiitaUrl": "https://qiita.com/jhorikawa_err",
      "twitterUrl": "https://twitter.com/jhorikawa_err"
  },
  "title": {
      "ja": "Houdini+ローカルDB〜Qt+SQLiteを使った簡易システム構築〜",
      "en": "Houdini+Local DB - Simple system construction using Qt+SQLite"
  },
  "articleUrl": "https://qiita.com/jhorikawa_err/items/528c188b95707cbe6a54",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122301,
  "summary": {
      "ja": "この記事では、HoudiniとSQLiteを使用したデータベースシステムの構築について説明しています。著者はHoudiniでデータベースを視覚的に処理することの可能性に興味を持ち、ローカルに保存するSQLiteを扱う方法を採用しています。記事では、Houdiniのデータをデータベースに保存し、そのデータを用いてノードネットワークを再構成する方法が示されています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes the construction of a database system using Houdini and SQLite. The author is interested in the possibilities of visually processing databases in Houdini and adopts a method of dealing with SQLite that stores locally. The article shows how to store Houdini data in a database and reconstruct a node network using that data ."
  }
},
{
  "thumbnailUrl": "2018122401.jpg",
  "creationDate": "2018-12-24",
  "author": {
      "name": "@yuya_torii",
      "twitterIcon": "yuya_torii.jpg",
      "qiitaUrl": "https://qiita.com/yuya_torii",
      "twitterUrl": "https://twitter.com/yuya_torii"
  },
  "title": {
      "ja": "HoudiniのParameter Interfaceで使えるPython②",
      "en": "Python (2) for use with Houdini's Parameter Interface"
  },
  "articleUrl": "https://qiita.com/yuya_torii/items/6f07a5708c3f45ad632c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122401,
  "summary": {
      "ja": "この記事では、HoudiniのParameter Interfaceで利用できるPythonに関する技術が紹介されています。具体的には、OrderedMenuとCallbackScriptの組み合わせ、+-ボタンの作り方、ParameterのDefaultValueの設定方法が説明されています。これらの技術は、より効率的で直感的なユーザーインターフェイスの作成に役立ちます",
      "en": "This article introduces techniques related to Python that can be used with Houdini's Parameter Interface. Specifically, it explains how to combine OrderedMenu and CallbackScript, how to create +- buttons, and how to set the DefaultValue of a Parameter. These techniques will help you create a more efficient and intuitive user interface"
  }
},
{
  "thumbnailUrl": "2018122501.jpg",
  "creationDate": "2018-12-25",
  "author": {
      "name": "@ARTsak",
      "twitterIcon": "ARTsak.jpg",
      "qiitaUrl": "https://qiita.com/ARTsak",
      "twitterUrl": "https://twitter.com/ARTsak"
  },
  "title": {
      "ja": "HoudiniのShelfktips",
      "en": "Shelfktips for Houdini"
  },
  "articleUrl": "http://artsak666.hatenablog.com/entry/2018/12/13/184258",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122501,
  "summary": {
      "ja": "この記事は、3DアニメーションソフトウェアHoudiniのShelf機能についての解説です。著者はShelfの基本的な使い方を説明し、Houdini内での多様な挙動や便利なトリックを紹介しています。例えば、右クリックでShelfを編集したり、ショートカットキーを割り当てたりする方法、Geometryを作成するためのビューポートやネットワーク上での操作方法などが説明されています。また、ShelfにノードをドラッグすることでPythonを介して自動的に処理が行われることも紹介されています。",
      "en": "This article describes the Shelf feature of the 3D animation software Houdini. The author explains the basic use of Shelf and introduces various behaviors and useful tricks within Houdini. For example, he explains how to right-click to edit Shelf, how to assign shortcut keys, and how to operate in viewports and on networks to create Geometry. It also shows how dragging a node to the Shelf is automatically processed via Python."
  }
}







,
{
  "thumbnailUrl": "2018120202.jpg",
  "creationDate": "2018-12-02",
  "author": {
      "name": "@peajxs",
      "twitterIcon": "peajxs.jpg",
      "qiitaUrl": "https://qiita.com/peajxs",
      "twitterUrl": "https://twitter.com/peajxs"
  },
  "title": {
      "ja": "自分なりのHoudini勉強方法とSNSの有効的な使い方",
      "en": "My own way of studying Houdini and effective use of SNS"
  },
  "articleUrl": "https://qiita.com/peajxs/items/64b0d2993a2c15b52fbd",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120202,
  "summary": {
      "ja": "この記事は、Houdini Apprentice Advent Calendar 2018の2日目の記事で、著者がHoudiniを学ぶ方法とSNSの活用方法を共有しています。約1年半前に専門学校入学と同時にHoudiniを始めた著者は、当初は独学で進め、最初は教科書やチュートリアル動画を見ながら勉強しました。その後、メモ取り、リファレンスの活用、勉強会への参加、オンラインフォーラム利用など、効率的な学習方法に変更しました。また、Twitterを使ってプロのアドバイスを得たり、勉強会に参加するなど、SNSを有効活用しています",
      "en": "This article is the second day of the Houdini Apprentice Advent Calendar 2018 and shares how the author learned Houdini and how he uses social networking sites. The author, who started working with Houdini about 18 months ago upon entering technical school, was initially self-taught and studied by watching textbooks and tutorial videos at first. Later, he changed to a more efficient learning method by taking notes, using references, participating in study groups, and using online forums. I also make effective use of social networking services, such as using Twitter to get professional advice and participating in study groups!"
  }
},
{
  "thumbnailUrl": "2018120302.jpg",
  "creationDate": "2018-12-03",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "HDA Submenu",
      "en": "HDA Submenu"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2018/12/hda-submenu.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120302,
  "summary": {
      "ja": "この記事では、HoudiniのGame Development Toolsをインストールし、Geometryノード内のTABメニューを使用して、GameDevサブメニュー内に表示されるHoudini Digital Assets（HDA）の整理方法について説明しています。HDAを編集する前に、使用するHoudiniの最古バージョンを選択し、Houdini ApprenticeやIndie版での編集は商用版では読めなくなることに注意が必要です。例として、OrboltからダウンロードしたHDAをサブメニューに整理する方法が示されています。サブメニューの設定は各HDAのType Propertiesから行い、Asset Managerを使うことが推奨されています​​​​​​​​。",
      "en": "This article explains how to install Houdini's Game Development Tools and use the TAB menu in the Geometry node to organize the Houdini Digital Assets (HDA) that appear in the GameDev submenu Before editing HDAs, select the oldest version of Houdini you want to use and note that edits made in the Houdini Apprentice or Indie versions will not be readable in the commercial version. As an example, it is shown how to organize the HDAs downloaded from Orbolt into submenus. The submenus are set up from the Type Properties of each HDA, and it is recommended to use the Asset Manager ."
  }
},
{
  "thumbnailUrl": "2018120402.jpg",
  "creationDate": "2018-12-04",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "SOPのみで作る慣性方程式を利用した溶岩噴出のエフェクト(遠景用)",
      "en": "Lava eruption effect using inertia equation created by SOP only (for distant view)"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/9c6257184f70745e2e94",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120402,
  "summary": {
      "ja": "著者は、Fujtiaさんのチュートリアルを勉強し、その知識を利用してマグマ噴出のエフェクトを作成します。このプロセスでは、初速度自由落下方程式を用いて点に動きを付け、クリッピングとカラーアトリビュートを設定し、アニメーションをサイクルさせて継続的な噴出を実現しています。最終的なコードと結果は記事に掲載されています",
      "en": "The author studies Fujtia's tutorial and uses his knowledge to create a magma eruption effect. The process involves adding motion to a point using the initial velocity freefall equation, setting clipping and color attributes, and cycling the animation to create a continuous eruption. The final code and results can be found in the article"
  }
},
{
  "thumbnailUrl": "2018120502.jpg",
  "creationDate": "2018-12-05",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "TwistとBendデフォーメーションの重ね掛け",
      "en": "Overlapping Twist and Bend deformation"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/79e1b3f191b737777aa4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120502,
  "summary": {
      "ja": "この記事では、著者がTwistとBendデフォーメーションを組み合わせたアニメーションを作成しています。まず、必要な関数を準備し、Twist関数とBend関数を定義します。For Loopを使ってこれらのデフォーメーションを重ねていき、pivot、aim、crossという変数を用いて基点と方向を更新します。最終的には、様々な値を掛け合わせてアニメーションさせ、パーティクルに適用することも可能です",
      "en": "In this article, the author creates an animation that combines Twist and Bend deformations. First, the necessary functions are prepared and the Twist and Bend functions are defined; these deformations are layered using For Loop, and the variables pivot, aim, and cross are used to update the base point and direction. Finally, the various values can be multiplied and animated and applied to the particles!"
  }
},
{
  "thumbnailUrl": "2018120602.jpg",
  "creationDate": "2018-12-06",
  "author": {
      "name": "@hina2vi",
      "twitterIcon": "hina2vi.jpg",
      "qiitaUrl": "https://qiita.com/hina2vi",
      "twitterUrl": "https://twitter.com/hina2vi"
  },
  "title": {
      "ja": "壊したものは元に戻したい",
      "en": "I want to put back what I broke."
  },
  "articleUrl": "https://qiita.com/hina2vi/items/6b6b4b2aa3b8755fd0ae",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120602,
  "summary": {
      "ja": "この記事では、破壊されたものを元に戻すエフェクトの作成方法について紹介されています。最初にレンガの準備を行い、シミュレーションの下準備として、ジオメトリと制御用のポイントを設定します。シミュレーションでは、位置や回転の動きを調整し、最終的には元の状態に戻す過程を紹介しています。著者は、この方法がカーブを使って軌道を容易にコントロールできると述べています",
      "en": "This article shows how to create an effect that restores something that has been destroyed. First, the brick is prepared and geometry and control points are set up to prep the simulation. The simulation shows the process of adjusting the position and rotational movements and eventually undoing them. The author states that this method allows for easy control of the trajectory using curves"
  }
},
{
  "thumbnailUrl": "2018120702.jpg",
  "creationDate": "2018-12-07",
  "author": {
      "name": "@saty",
      "twitterIcon": "saty.jpg",
      "qiitaUrl": "https://qiita.com/saty",
      "twitterUrl": "https://twitter.com/saty"
  },
  "title": {
      "ja": "switchで作るUIいろいろ",
      "en": "Various UI to be created with switch"
  },
  "articleUrl": "https://qiita.com/saty/items/41620eb9f6184a594456",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120702,
  "summary": {
      "ja": "この記事では、Switchノードを用いたUIの作成方法について紹介されています。Switchノードは入力ノードを切り替えることができ、チェックボックス、ラジオボタン、入力の有無の判定などのUIコンポーネントを作成するのに使用されます。著者はこれらのコンポーネントの作成方法を具体的に解説し、最終的にはSwitchノードが完成します",
      "en": "This article shows how to create a UI using Switch nodes, which can switch input nodes and are used to create UI components such as checkboxes, radio buttons, and whether or not an input is present. The author explains exactly how to create these components, and the end result is a Switch node!"
  }
},
{
  "thumbnailUrl": "2018120902.jpg",
  "creationDate": "2018-12-09",
  "author": {
      "name": "@takavfx",
      "twitterIcon": "takavfx.jpg",
      "qiitaUrl": "https://qiita.com/takavfx",
      "twitterUrl": "https://twitter.com/takavfx"
  },
  "title": {
      "ja": "Windows 10でHoudiniのライセンス更新に失敗する時の対処法",
      "en": "What to do when Houdini license renewal fails on Windows 10"
  },
  "articleUrl": "https://qiita.com/takavfx/items/85fb86f9bbf49356fa43",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018120902,
  "summary": {
      "ja": "Windows 10でHoudini Apprenticeを使用する際、ライセンス更新に失敗する問題が発生します。この問題の原因は、ライセンスファイルの更新に管理者権限が必要だが、通常起動では権限がないためです。解決策は、任意のバージョンのHoudini Apprenticeを「管理者として実行」で起動し、表示される指示に従ってライセンスを更新することです​​。",
      "en": "When using Houdini Apprentice on Windows 10, there is an issue with license updates failing. The reason for this problem is that updating the license file requires administrator privileges, but normal startup does not. The solution is to start any version of Houdini Apprentice with \"Run as administrator\" and follow the instructions displayed to update the license."
  }
},
{
  "thumbnailUrl": "2018121002.jpg",
  "creationDate": "2018-12-10",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "拡散していくボックス",
      "en": "Diffusion box"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/179bf28eddef91e55269",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121002,
  "summary": {
      "ja": "この記事では、Solverを使用してボックスが拡散し、特定の形を作る方法を紹介します。まず、ボックスが隣のボックスに拡散する設定を行い、拡散制限を設定します。拡散時にボックスを移動させるためには、いくつかのアトリビュートを追加します。この技法は立体にも適用可能で、ポイントクラウドを使用して隣接ポイントを判定し、アトリビュートを変更します​​​​​​​​​​。",
      "en": "This article shows how to use Solver to make a box diffuse and create a specific shape. First, set up the box to diffuse to a neighboring box and set the diffusion limit. To move the box when diffusing, add some attributes. This technique can also be applied to solids, using a point cloud to determine adjacent points and change the attributes ."
  }
},
{
  "thumbnailUrl": "2018121102.jpg",
  "creationDate": "2018-12-11",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "CopyのStampを使わずに花が咲広がるアニメーション",
      "en": "Animation of flowers blooming and spreading without Stamp of Copy"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/7368cd2062341bc49b30",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121102,
  "summary": {
      "ja": "この記事では、CopyのStamp機能を使わずに花が咲き広がるアニメーションを作成する方法を紹介しています。まず、単体の花びらのアニメーションを作成し、その後、それを複数の花びらに適用します。さらに、Scatterを使って花のポイントを作成し、それらにアトリビュートを用いてより複雑なアニメーションを作成します​​​​​​​​​​。",
      "en": "This article shows how to create an animation of a flower blooming and spreading without using Copy's Stamp feature. First, create an animation of a single petal, then apply it to multiple petals. Then, use Scatter to create the points of the flower and use attributes on them to create a more complex animation The first step is to create a single petal animation and then apply it to multiple petals."
  }
},
{
  "thumbnailUrl": "2018121202.jpg",
  "creationDate": "2018-12-12",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "トランスフォーマーロゴアニメーション",
      "en": "Transformers Logo Animation"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/74216e830b86b825ed0c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121202,
  "summary": {
      "ja": "著者はトランスフォーマー風のロゴアニメーションを作成し、そのプロセスを説明しています。このアニメーションでは、まずピースを設定し、Solverを使用して隣接オブジェクトをアクティブにしながら階層化します。階層トランスフォームでは、子から親へとマトリックスを適用し、基本コードを使ってアニメーションのタイミングを調整します​​​​​​​​​​​​。",
      "en": "The author has created a Transformers-style logo animation to illustrate the process. In this animation, the pieces are first set up and then hierarchically transformed while activating adjacent objects using Solver. The hierarchical transform applies the matrix from child to parent and adjusts the timing of the animation using basic code ."
  }
},
{
  "thumbnailUrl": "2018121402.jpg",
  "creationDate": "2018-12-14",
  "author": {
      "name": "@saty",
      "twitterIcon": "saty.jpg",
      "qiitaUrl": "https://qiita.com/saty",
      "twitterUrl": "https://twitter.com/saty"
  },
  "title": {
      "ja": "カスタムノードシェイプを作る",
      "en": "Create Custom Node Shapes"
  },
  "articleUrl": "https://qiita.com/saty/items/c573fd4bb6ba7f55b995",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121402,
  "summary": {
      "ja": "Houdiniでは、ノードの形状を自作し、JSON形式のファイルでカスタムノードシェイプを追加することができます。このプロセスでは、まずCurve SOPでアウトラインを描き、必要に応じてAdobe Illustratorのepsファイルも使用します。その後、Detailに格納された座標情報をJSONファイルの書式で結合し、カスタムノードシェイプを作成します​​​​​​​​​​​​​​​​。",
      "en": "Houdini allows you to create your own node shapes and add custom node shapes in JSON format files. The process involves first drawing an outline in Curve SOP, and if necessary also using an Adobe Illustrator eps file. Then, coordinate information stored in Detail is combined in the format of a JSON file to create a custom node shape The node shape is then created by combining the coordinate information stored in Detail with the JSON file format."
  }
},
{
  "thumbnailUrl": "2018121502.jpg",
  "creationDate": "2018-12-15",
  "author": {
      "name": "@TaroOzaki",
      "twitterIcon": "TaroOzaki.jpg",
      "qiitaUrl": "https://qiita.com/TaroOzaki",
      "twitterUrl": "https://twitter.com/TaroOzaki"
  },
  "title": {
      "ja": "【第二版】Houdiniで建築(入門編: ジオメトリ間のデータやり取り)",
      "en": "Architecture with Houdini (Introduction: Data exchange between geometries)"
  },
  "articleUrl": "https://qiita.com/TaroOzaki/items/2e0727c3daccb9158e7e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121502,
  "summary": {
      "ja": "著者はドイツで建築学生としてHoudiniを使い始め、建築に関わるさまざまなシーンでHoudiniを活用してきました。この記事では、Houdiniの魅力として、ジオメトリ間のデータのやり取りが簡単にできる点に焦点を当て、Houdiniの基本的な使い方を紹介しています​​​​​​​​​​。",
      "en": "The author started using Houdini as an architecture student in Germany and has used Houdini in a variety of architecture-related situations. In this article, he introduces the basic use of Houdini, focusing on the easy exchange of data between geometries as one of Houdini's most attractive features The article also includes a brief overview of Houdini's use in the field of geometry."
  }
},
{
  "thumbnailUrl": "2018121602.jpg",
  "creationDate": "2018-12-16",
  "author": {
      "name": "@yosemite",
      "twitterIcon": "yosemite.jpg",
      "qiitaUrl": "https://qiita.com/yosemite",
      "twitterUrl": "https://twitter.com/yosemite"
  },
  "title": {
      "ja": "有料チュートリアルの感想",
      "en": "Impressions on paid tutorials"
  },
  "articleUrl": "https://qiita.com/yosemite/items/ef7539157ef16391cb3e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121602,
  "summary": {
      "ja": "この記事では、UdemyとCG Circuitで提供されるHoudiniの有料チュートリアルについての感想が述べられています。Udemyのチュートリアルは初心者向けで、基本的な流れを追いやすい一方で、CG Circuitのチュートリアルは上級者向けでテクニカルな要素が多く含まれていると評価されています​​​​​​​​​​​​​​​​。",
      "en": "This article provides feedback on the paid Houdini tutorials offered by Udemy and CG Circuit, with Udemy's tutorials being more beginner oriented and easy to follow basic flow, while CG Circuit's tutorials are more advanced and include more technical elements. The Udemy tutorials are for beginners and follow a basic flow, while the CG Circuit tutorials are more advanced and include more technical elements. The tutorials on CG Circuit were rated as more advanced and more technical."
  }
},
{
  "thumbnailUrl": "2018121802.jpg",
  "creationDate": "2018-12-18",
  "author": {
      "name": "@fes_0131",
      "twitterIcon": "fes_0131.jpg",
      "qiitaUrl": "https://qiita.com/fes_0131",
      "twitterUrl": "https://twitter.com/fes_0131"
  },
  "title": {
      "ja": "3DCG初心者がHoudiniでCGを始めて。＋簡単に作れる紙タバコのタイムラプス",
      "en": "3DCG beginner starting CG with Houdini. + easy to make paper cigarette time lapse"
  },
  "articleUrl": "https://qiita.com/fes_0131/items/efbbd6d5ee6d515ff741",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018121802,
  "summary": {
      "ja": "著者は3DCG初心者としてHoudiniを学び始めた経験を共有しています。Houdiniの魅力として、無料のApprentice版の提供、公式チュートリアルの充実、ユーザーフレンドリーな公式ヘルプ、アトリビュートとグループの操作の容易さを挙げています。また、紙タバコのタイムラプスアニメーションの作成過程も紹介しています​​​​​​​​​​。",
      "en": "The author shares his experience of starting to learn Houdini as a 3DCG beginner, citing the free Apprentice edition, the extensive official tutorials, the user-friendly official help, and the ease of working with attributes and groups as some of Houdini's attractions. It also shows the process of creating a time-lapse animation of a paper cigarette ."
  }
},
{
  "thumbnailUrl": "2018122102.jpg",
  "creationDate": "2018-12-21",
  "author": {
      "name": "@tsuka0245",
      "twitterIcon": "tsuka0245.jpg",
      "qiitaUrl": "https://qiita.com/tsuka0245",
      "twitterUrl": "https://twitter.com/tsuka0245"
  },
  "title": {
      "ja": "GridMarketを使ったHoudiniレンダリング",
      "en": "Houdini rendering with GridMarket"
  },
  "articleUrl": "https://qiita.com/tsuka0245/items/d59f3bcac82ce5b04a07",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122102,
  "summary": {
      "ja": "この記事では、GridMarketを使用してHoudiniでのクラウドレンダリングの方法について説明しています。GridMarketはクラウド上でレンダリングとシミュレーションが可能なサービスで、料金は使用するマシンの数に応じて異なります。使い方は簡単で、初めての利用者には無料クレジットも提供されています​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to use GridMarket for cloud rendering in Houdini; GridMarket is a service that allows rendering and simulation in the cloud, with fees depending on the number of machines used. It is easy to use and offers free credits for first time users! The service is easy to use and offers free credits to first-time users."
  }
},
{
  "thumbnailUrl": "2018122202.jpg",
  "creationDate": "2018-12-22",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "Houdini Light Pass Expressions",
      "en": "Houdini Light Pass Expressions"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2018/12/houdini-lpe.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122202,
  "summary": {
      "ja": "この記事では、Houdini 17に搭載されたLight Pass Expression（LPE）について紹介されています。LPEは、レンダリング時の光線の軌跡をカメラ、ボリューム、サーフェス、ライトの順に追跡するための正規表現です。記事では、シーン構成、LPEの設定方法、タグの設定、実践例が詳しく解説されています。LPEの設定には、MantraノードのExtra Image PlanesタブでExtra Image Planeを追加し、VEX Variableに記述する方法が用いられています​​​​​​​​​​​​。",
      "en": "This article introduces the Light Pass Expression (LPE) in Houdini 17. LPE is a regular expression for tracking the path of light rays during rendering, in the order of camera, volume, surface, and light. The article details the scene structure, how to set up LPE, tagging, and practical examples; LPE is set up by adding an Extra Image Plane in the Extra Image Planes tab of the Mantra node and describing it in a VEX Variable. The LPE configuration is described in detail in the practical example."
  }
},
{
  "thumbnailUrl": "2018122402.jpg",
  "creationDate": "2018-12-24",
  "author": {
      "name": "@dragon_1159",
      "twitterIcon": "dragon_1159.jpg",
      "qiitaUrl": "https://qiita.com/dragon_1159",
      "twitterUrl": "https://twitter.com/dragon_1159"
  },
  "title": {
      "ja": "Houdini初心者が必死こいてスキル習得を試みた1年を振り返る",
      "en": "Houdini beginners look back on a year of frantic attempts to acquire skills."
  },
  "articleUrl": "https://qiita.com/dragon_1159/items/6639545601b9a77322a3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122402,
  "summary": {
      "ja": "著者はHoudini初心者としての1年間のスキル習得の試行錯誤を振り返っています。彼はTokyo Houdini Meetup、社内勉強会、CEDEC2018でのプログラマ向けトークセッションなどの経験を通じてHoudiniに関する知識とコミュニティを構築しました。また、振り返りを通して得た教訓と反省点も共有しています​​​​​​​​​​​​​​​​。",
      "en": "The author reflects on his year-long trial and error of acquiring skills as a Houdini beginner. He built his Houdini knowledge and community through experiences such as the Tokyo Houdini Meetup, in-house study groups, and a talk session for programmers at CEDEC2018. He also shares lessons learned and reflections through his reflections ."
  }
},
{
  "thumbnailUrl": "2018122502.jpg",
  "creationDate": "2018-12-25",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "Houdiniでチキンラーメンを作る方法",
      "en": "How to Make Chicken Ramen in Houdini"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/2269879e46f9915517ad",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2018122502,
  "summary": {
      "ja": "この記事は、Houdiniを使用してチキンラーメンを3Dモデリングする方法を紹介しています。このプロジェクトでは、RealityCaptureとDetangleというHoudiniの機能が使われています。RealityCaptureは高品質なフォトグラメトリソフトで、Houdini16.5から連携可能になりましたが、別途購入が必要です。DetangleはHoudini17で導入された機能で、ラインとサーフェスの衝突を検出し、解消する役割を果たします。最終的に、チキンラーメンの形状を作成するために、複数のステップが説明されています​​​​​​​​​​​​​​​​​​。",
      "en": "This article shows how to use Houdini to model chicken noodle soup in 3D. The project uses two Houdini features, RealityCapture and Detangle; RealityCapture is a high-quality photogrammetry software that has been available for integration since Houdini 16.5, but must be purchased separately. Detangle is a feature introduced in Houdini 17 that is responsible for detecting and resolving collisions between lines and surfaces. Finally, multiple steps are described to create a chicken noodle shape ."
  }
}









,{
  "thumbnailUrl": "2019120101.jpg",
  "creationDate": "2019-12-01",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "ディニ子をつくる：Houdiniでキャラクターモデリング",
      "en": "Creating Diniko: Character Modeling in Houdini"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/ad15495a702ee957dbe8",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120101,
  "summary": {
      "ja": "Houdiniのキャラクターモデリングプロセスについて、特に「ディニ子」というキャラクターを例に説明しています。Houdiniのモデリング機能の強化、キャラクターデザインの決定、モデリングの基本的な手順から細かいテクニックまでを詳細に記述しています",
      "en": "Describes the Houdini character modeling process, using the character \"Diniko\" as an example in particular, detailing Houdini's enhanced modeling capabilities, character design decisions, basic modeling steps and detailed techniques."
  }
},
{
  "thumbnailUrl": "2019120201.jpg",
  "creationDate": "2019-12-02",
  "author": {
      "name": "@skg17948541",
      "twitterIcon": "skg17948541.jpg",
      "qiitaUrl": "https://qiita.com/skg17948541",
      "twitterUrl": "https://twitter.com/skg17948541"
  },
  "title": {
      "ja": "本を色々な形の本棚に詰め込む",
      "en": "Cram books into bookshelves of various shapes and sizes."
  },
  "articleUrl": "https://qiita.com/skg17948541/items/bd7dff8da0479a5330c8",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120201,
  "summary": {
      "ja": "Houdiniを使用して、様々な形の本棚に本を詰め込むプロセスを紹介しています。重要な機能としてUVlayoutノードのIslands from Second InputとDOPシュミレーションがあり、これらを使って自然な本の配置を実現しています",
      "en": "Using Houdini, this video shows the process of filling bookshelves of various shapes with books. Important features include Islands from Second Input and DOP simulation in the UVlayout node, which are used to achieve natural book placement!"
  }
},
{
  "thumbnailUrl": "2019120301.jpg",
  "creationDate": "2019-12-03",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "パリピHoudiniロゴアニメーションとPDGでムービー出力",
      "en": "Movie output with Parisi Houdini logo animation and PDG"
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2019/12/houdinipdg.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120301,
  "summary": {
      "ja": "この記事では、パリピ風のHoudiniロゴアニメーションの制作が紹介されています。Wireソルバーを用いたSoftbodyシミュレーションで、文字をDivideで分割し、シミュレーション後に厚みを加えています。また、Houdini17.5からのPDG機能を使い、レンダリングした連番をムービー(mp4)に自動変換し、モデリングからアップロードまでの工程を自動化する方法が解説されています​",
      "en": "This article presents the creation of a Parisian-style Houdini logo animation, using a Softbody simulation with the Wire solver to divide the letters with Divide and add thickness after simulation. The PDG functionality from Houdini 17.5 is used to automatically convert the rendered sequential numbers into a movie (mp4), and how to automate the process from modeling to uploading is also explained."
  }
},
{
  "thumbnailUrl": "2019120401.jpg",
  "creationDate": "2019-12-04",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "HtoAを使ったAss/Alembicの利用方法",
      "en": "How to use Ass/Alembic with HtoA"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/71a0974092b6e9cb1872",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120401,
  "summary": {
      "ja": "Arnoldレンダラー（HtoA）を使用してHoudiniとMayaの間でAssとAlembicファイルをやり取りする方法について説明しています。Assファイルの出力、Alembic経由でのアトリビュートの伝達、シェーダの割り当て方法などが詳述されています",
      "en": "Describes how to use the Arnold renderer (HtoA) to exchange Ass and Alembic files between Houdini and Maya, including details on how to output Ass files, transfer attributes via Alembic, and assign shaders"
  }
},
{
  "thumbnailUrl": "2019120501.jpg",
  "creationDate": "2019-12-05",
  "author": {
      "name": "@takavfx",
      "twitterIcon": "takavfx.jpg",
      "qiitaUrl": "https://qiita.com/takavfx",
      "twitterUrl": "https://twitter.com/takavfx"
  },
  "title": {
      "ja": "SideFX Labs Toolの新規のインストール方法、Package機能に関して検証してみる",
      "en": "How to install a new SideFX Labs Tool, and verify regarding the Package functionality."
  },
  "articleUrl": "https://qiita.com/takavfx/items/d1698b89df6fb1b86f9c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120501,
  "summary": {
      "ja": "Houdini 18で導入されたSideFX Labs Toolの新しいインストール方法とPackage機能について解説しています。従来のインストール方法と新しい方法の比較、Package機能の特徴と使用例、複数のプロジェクトでの適用例などが記載されています",
      "en": "This article describes the new installation method and Package feature of the SideFX Labs Tool introduced in Houdini 18. It includes a comparison of the old and new installation methods, features and usage examples of the Package feature, and examples of how it can be applied to multiple projects."
  }
},
{
  "thumbnailUrl": "2019120601.jpg",
  "creationDate": "2019-12-06",
  "author": {
      "name": "@70_cg_art",
      "twitterIcon": "70_cg_art.jpg",
      "qiitaUrl": "https://qiita.com/70_cg_art",
      "twitterUrl": "https://twitter.com/70_cg_art"
  },
  "title": {
      "ja": "Houdiniで始めるPython",
      "en": "Getting Started with Python in Houdini"
  },
  "articleUrl": "https://qiita.com/70_cg_art/items/46dd9ca06bee4478c495",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120601,
  "summary": {
      "ja": "HoudiniでPythonスクリプトを作成する基本的なプロセスを紹介しています。シェルフツールの作成、必要な手順の整理、情報収集方法、ヘルプページの活用、スクリプトの実装、完成後の確認、さらなる課題設定などが詳述されています",
      "en": "The basic process of creating Python scripts in Houdini is presented. It details the creation of shelf tools, organizing the necessary steps, how to gather information, using the help pages, implementing the script, checking it after completion, and setting up further assignments!"
  }
},
{
  "thumbnailUrl": "2019120701.jpg",
  "creationDate": "2019-12-07",
  "author": {
      "name": "@yuya_torii",
      "twitterIcon": "yuya_torii.jpg",
      "qiitaUrl": "https://qiita.com/yuya_torii",
      "twitterUrl": "https://twitter.com/yuya_torii"
  },
  "title": {
      "ja": "Wedgeを中心にPDGの話まで",
      "en": "Focusing on Wedge and even talking about PDG"
  },
  "articleUrl": "https://qiita.com/yuya_torii/items/2dfab15a4ad433a187b4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120701,
  "summary": {
      "ja": "この記事はHoudiniのWedgeROPノードに焦点を当てています。Wedgeは、指定されたパラメータを変更しながら任意の回数実行する機能で、大量のバリエーションを簡単に作成できます。作者はWedgeROPの内部動作と、PDGのリリース後に追加されたWedgeTOPの使い方及び従来の方法との違いを詳しく解説しています。記事では、Wedgeの使用例としてパラメータの範囲変更やランダムな値生成を行う方法も紹介しています​​​​​​​​​​。",
      "en": "This article focuses on Houdini's WedgeROP node, which is a feature that runs an arbitrary number of times while changing specified parameters, making it easy to create large numbers of variations. The author details the internal workings of WedgeROP and how to use WedgeTOP, which was added after the release of PDG, and how it differs from the traditional method. The article also shows how to use Wedge as an example to change the range of parameters and generate random values. The article also includes examples of how to use Wedge to change the range of parameters and generate random values."
  }
},
{
  "thumbnailUrl": "2019120801.jpg",
  "creationDate": "2019-12-08",
  "author": {
      "name": "@d658t",
      "twitterIcon": "d658t.jpg",
      "qiitaUrl": "https://qiita.com/d658t",
      "twitterUrl": "https://twitter.com/d658t"
  },
  "title": {
      "ja": "HDAにヘルプを付ける方法(Pythonスクリプトのおまけ付き)",
      "en": "How to add help to HDA (with an extra Python script)"
  },
  "articleUrl": "https://qiita.com/d658t/items/1737cb4e820b45f28723",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120801,
  "summary": {
      "ja": "この記事では、HoudiniのHDAにヘルプを追加する方法について解説しています。ヘルプはType PropertiesウィンドウのHelpタブか特定のディレクトリにテキストファイルとして書くことができます。書式はWikiマークアップを使用し、タイトルやアイコン設定、要約などが含まれます。さらに、ヘルプにカスタムサンプルを付ける方法や、作業を半自動化するPythonスクリプトの使用方法も紹介されています​​​​​​​​​​​​​​。",
      "en": "This article explains how to add help to Houdini's HDA. Help can be written as a text file in the Help tab of the Type Properties window or in a specific directory. The formatting uses Wiki markup and includes a title, icon settings, and a summary. In addition, you will learn how to attach custom samples to the help and how to use Python scripts to semi-automate the work The help is also available in the following languages."
  }
},
{
  "thumbnailUrl": "2019120901.jpg",
  "creationDate": "2019-12-09",
  "author": {
      "name": "@PontaYamazato",
      "twitterIcon": "PontaYamazato.jpg",
      "qiitaUrl": "https://qiita.com/PontaYamazato",
      "twitterUrl": "https://twitter.com/PontaYamazato"
  },
  "title": {
      "ja": "今年のクリスマスカード",
      "en": "This year's Christmas card"
  },
  "articleUrl": "https://note.com/pontayamazato/n/n9c6953041ea8",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120901,
  "summary": {
      "ja": "この記事では、筆者がHoudiniを使用して作成したクリスマスカードについて詳細に述べています。2年目の試みで、ピアノとフルートをモチーフに選び、クリスマスらしい赤緑の花やキャンドルを配置しています。各アイテムはリアルなディテールを持ち、ライティングやレンダリングも丁寧に行われています。筆者はHoudiniを「魔法の筆」と称え、このソフトウェアでのモデリングについての愛着を表現しています",
      "en": "This article details a Christmas card created by the author using Houdini; for the second year, a piano and flute were chosen as the motifs and Christmas-like red-green flowers and candles were placed. Each item has realistic detail and is carefully lit and rendered. The author refers to Houdini as the \"magic brush\" and expresses his love for modeling with this software!"
  }
},
{
  "thumbnailUrl": "2019121001.jpg",
  "creationDate": "2019-12-10",
  "author": {
      "name": "@d658t",
      "twitterIcon": "d658t.jpg",
      "qiitaUrl": "https://qiita.com/d658t",
      "twitterUrl": "https://twitter.com/d658t"
  },
  "title": {
      "ja": "新しいバージョンで追加、更新されたノードを取得、作成する",
      "en": "Retrieve and create nodes that have been added or updated with newer versions"
  },
  "articleUrl": "https://qiita.com/d658t/items/33170d0e625d76effcde",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121001,
  "summary": {
      "ja": "この記事では、Houdini 18.0で追加または更新されたノードを取得し、作成する方法を紹介しています。追加されたノードの定義として、17.5と18.0の間で新たに追加されたノードや、パラメータが更新されたノードが挙げられています。スクリプトの実行結果として、新たに追加されたノードや更新されたパラメータの一覧が得られ、さらにCSVデータとしても提供されています。また、Pythonスクリプトを使用して指定したバージョンのノード情報を取得する方法も説明されています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article shows how to get and create nodes that have been added or updated in Houdini 18.0. Added nodes are defined as nodes that were newly added or whose parameters were updated between 17.5 and 18.0. As a result of running the script, a list of newly added nodes and updated parameters is obtained, and is also provided as CSV data. It also explains how to retrieve a specified version of node information using a Python script The script is available in the following formats."
  }
},
{
  "thumbnailUrl": "2019121101.jpg",
  "creationDate": "2019-12-11",
  "author": {
      "name": "@TF_siri",
      "twitterIcon": "TF_siri.jpg",
      "qiitaUrl": "https://qiita.com/TF_siri",
      "twitterUrl": "https://twitter.com/TF_siri"
  },
  "title": {
      "ja": "自己流自動生成方法",
      "en": "Self-generated automatic generation method"
  },
  "articleUrl": "https://qiita.com/TF_siri/items/14c6a2c87629e4cfe0f3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121101,
  "summary": {
      "ja": "この記事では、Houdiniを使った自動生成の方法を紹介しています。シード値を変えるだけで多くのバリエーションを作ることを目的とし、scatterノードのseedを使用してpointの位置をランダムに変更する方法を基本としています。さらに、Voronoi分割やAttribute Transfer、Attribute Promoteの使用法、色のランダム変更などのテクニックも紹介されています。また、mirrorやcopy and transformを使用してデザインの応用方法も説明されています​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article shows how to use Houdini for automatic generation. The goal is to create many variations by simply changing the seed value, and the basic method is to randomly change the position of a point using the seed in the scatter node. In addition, techniques such as Voronoi splitting, Attribute Transfer, Attribute Promote usage, and random color changes are introduced. It also explains how to apply designs using mirror and copy and transform. The following is a brief introduction to the use of the Voronoi method."
  }
},
{
  "thumbnailUrl": "2019121201.jpg",
  "creationDate": "2019-12-12",
  "author": {
      "name": "@K240",
      "twitterIcon": "K240.jpg",
      "qiitaUrl": "https://qiita.com/K240",
      "twitterUrl": "https://twitter.com/K240"
  },
  "title": {
      "ja": "HDKでアニメーションをSOPに取り込む",
      "en": "HDK to import animation into SOP"
  },
  "articleUrl": "https://qiita.com/K240/items/b0de7d3f440da836743e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121201,
  "summary": {
      "ja": "この記事は、HoudiniのSOPでFBXアニメーションを扱うためのノード開発に関するものです。Houdini 18のBone Deformerを活用し、ポイントアトリビュートを使用してボーン変形を解く方法について説明しています。記事では、このノードのビルド方法と、ゲーム開発におけるHoudiniの活用に焦点を当てています。また、公開されたソースコードを参照し、Houdiniでのプラグイン実装をサポートする目的で書かれています​​​​​​​​​​​​​​。",
      "en": "This article is about node development for handling FBX animations in Houdini's SOP, leveraging Houdini 18's Bone Deformer to solve bone deformations using point attributes. The article focuses on how to build this node and the use of Houdini in game development. It also references publicly available source code and is written with the purpose of supporting plug-in implementations in Houdini The article is written with the aim of supporting the implementation of plug-ins in Houdini."
  }
},
{
  "thumbnailUrl": "2019121301.jpg",
  "creationDate": "2019-12-13",
  "author": {
      "name": "@tanitta",
      "twitterIcon": "tanitta.jpg",
      "qiitaUrl": "https://qiita.com/tanitta",
      "twitterUrl": "https://twitter.com/tanitta"
  },
  "title": {
      "ja": "普段使いで便利なHoudiniのSideFX LabのOperatorピックアップ",
      "en": "Houdini's SideFX Lab Operator pickup useful for everyday use."
  },
  "articleUrl": "https://tanitta.hatenablog.com/entry/2019/12/13/153600",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121301,
  "summary": {
      "ja": "この記事では、HoudiniのSideFX Lab（旧GameDevTools）について紹介されています。これは、Indie以上のグレードのライセンスで利用可能なOperatorの追加パッケージで、特にゲームアセット制作などのリアルタイム用途に適しているとされています。記事では、実際に使ってみて便利だと感じたOperatorを中心に、その応用例を解説しています",
      "en": "This article introduces Houdini's SideFX Lab (formerly GameDevTools). This is an additional Operator package available with Indie or higher grade licenses, and is said to be particularly suited for real-time applications such as game asset production. The article focuses on Operator, which we have actually used and found useful, and explains its applications"
  }
},
{
  "thumbnailUrl": "2019121401.jpg",
  "creationDate": "2019-12-14",
  "author": {
      "name": "@takavfx",
      "twitterIcon": "takavfx.jpg",
      "qiitaUrl": "https://qiita.com/takavfx",
      "twitterUrl": "https://twitter.com/takavfx"
  },
  "title": {
      "ja": "Houdini を Python 3 でやる!!!",
      "en": "Doing Houdini with Python 3!"
  },
  "articleUrl": "https://qiita.com/takavfx/items/a019427a1062b41fc8d6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121401,
  "summary": {
      "ja": "この記事では、Houdini 18でPython 3のプレビュー版が配布され始めたことについて触れ、Python 3での処理が可能になった背景を説明しています。著者は、Python 3での作業を行っており、HoudiniでのPython 3のサポートが重要であることを強調しています。記事ではPython 3のテストや、TensorFlowなどのライブラリの利用が容易になることを示唆しています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article mentions that a preview version of Python 3 is beginning to be distributed with Houdini 18 and provides background on the availability of Python 3 processing. The author has been working with Python 3 and emphasizes the importance of Python 3 support in Houdini. The article suggests that it will be easier to test Python 3 and use libraries such as TensorFlow ."
  }
},
{
  "thumbnailUrl": "2019121501.jpg",
  "creationDate": "2019-12-15",
  "author": {
      "name": "@m__a__",
      "twitterIcon": "m__a__.jpg",
      "qiitaUrl": "https://qiita.com/m__a__",
      "twitterUrl": "https://twitter.com/m__a__"
  },
  "title": {
      "ja": "ボリュームのポスト処理",
      "en": "Volume post-processing"
  },
  "articleUrl": "https://qiita.com/m__a__/items/bb6ed9f6dd0e735a2a5b",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121501,
  "summary": {
      "ja": "この記事では、Houdiniでのボリュームデータのポスト処理方法について解説しています。主にvolume wrangleノードの活用に焦点を当て、様々なポスト処理技術について説明しています。記事では、ボリュームデータを変形したりノイズを加えたりする技術や、フェイクコリジョンの作成方法についても紹介しています​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to post-process volume data in Houdini. It focuses primarily on utilizing the volume wrangle node and describes various post-processing techniques. The article also covers techniques for deforming and noifying volume data, as well as how to create fake collisions. The article also describes how to create fake collisions."
  }
},
{
  "thumbnailUrl": "2019121601.jpg",
  "creationDate": "2019-12-16",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "初心者向けチュートリアル動画をリリースした話",
      "en": "The story of the release of the tutorial video for beginners"
  },
  "articleUrl": "https://kickbase.net/entry/houdini_basic_tutorial",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121601,
  "summary": {
      "ja": "「Houdini基礎 - モデリング編」という初心者向けの動画チュートリアルがリリースされた。このチュートリアルは、Houdiniをこれから始めるアーティストや一度挫折したアーティストに向けて制作され、Houdiniの基本を丁寧に解説している。特に、Houdiniのプロシージャルなアプローチに重点を置き、なぜ特定のノードを使うかを詳細に説明している。チュートリアルは、Houdiniの基礎知識をしっかりと学ぶことができる内容になっている​​​​​​​​​​​​​​。",
      "en": "A new video tutorial for beginners called \"Houdini Basics - Modeling\" has been released. This tutorial was created for artists who are just starting out or once frustrated with Houdini, and carefully explains the basics of Houdini. Particular emphasis is placed on Houdini's procedural approach, explaining in detail why certain nodes are used. The tutorial is designed to provide a solid foundation for learning the fundamentals of Houdini ."
  }
},
{
  "thumbnailUrl": "2019121701.jpg",
  "creationDate": "2019-12-17",
  "author": {
      "name": "@tsuka0245",
      "twitterIcon": "tsuka0245.jpg",
      "qiitaUrl": "https://qiita.com/tsuka0245",
      "twitterUrl": "https://twitter.com/tsuka0245"
  },
  "title": {
      "ja": "HDKでオリジナルのVEX関数を作る話",
      "en": "Talk about creating an original VEX function in HDK."
  },
  "articleUrl": "https://qiita.com/tsuka0245/items/cdc28d0a3da0c813f74f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121701,
  "summary": {
      "ja": "この記事では、HDKを使用してオリジナルのVEX関数を作成する方法について詳細に解説しています。VEX_VexOpクラスの活用、コールバック関数の作成、最適化の必要性などについて述べています。また、法線から接線と従法線を得る関数の具体例を示し、コードの書き方とコンパイル方法についても説明しています​​​​​​​​​​​​​​​​。",
      "en": "This article details how to use HDK to create original VEX functions, discussing the use of the VEX_VexOp class, creating callback functions, and the need for optimization. It also shows a concrete example of a function that obtains tangent and subordinate normals from a normal, and explains how to write and compile the code The code is written and compiled."
  }
},
{
  "thumbnailUrl": "2019121801.jpg",
  "creationDate": "2019-12-18",
  "author": {
      "name": "@hasegawa_t",
      "twitterIcon": "hasegawa_t.jpg",
      "qiitaUrl": "https://qiita.com/hasegawa_t",
      "twitterUrl": "https://twitter.com/hasegawa_t"
  },
  "title": {
      "ja": "OpenCL SOPでグラフ力学シミュレーション",
      "en": "Graph dynamics simulation with OpenCL SOP"
  },
  "articleUrl": "https://qiita.com/hasegawa_t/items/94c4b086fb0b9bd003ce",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121801,
  "summary": {
      "ja": "この記事では、Houdiniでのグラフ力学シミュレーションの実装方法を紹介しています。Houdini 16.5で追加されたOpenCL SOPを使用して、ネットワーク構造の配置を最適化するプロセスを解説しています。OpenCL SOPを使うことで、GPUの力を借りてシミュレーションを高速化する方法を示しています。記事では、データの準備からジオメトリ化、OpenCL SOPへのデータの渡し方まで、手順を具体的に説明しています",
      "en": "This article shows how to implement a graph dynamics simulation in Houdini. it describes the process of optimizing the placement of network structures using OpenCL SOPs, which were added in Houdini 16.5. by using OpenCL SOPs, with the help of the GPU It shows how to accelerate the simulation. The article describes the steps in detail, from data preparation, to geometrization, to passing data to OpenCL SOPs"
  }
},
{
  "thumbnailUrl": "2019121901.jpg",
  "creationDate": "2019-12-19",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "HoudiniでPointCacheを作成・エクスポートしてUnityのVFXgraphに読み込んで使うフローの基礎解説",
      "en": "Basic explanation of the flow of creating and exporting PointCache in Houdini and importing it into Unity's VFXgraph."
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/e356cf4913b48900a0f6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121901,
  "summary": {
      "ja": "この記事では、HoudiniでPointCacheを作成し、それをエクスポートしてUnityのVFXgraphに読み込む基本的なフローを解説しています。VFXgraphはリアルタイムで使用可能なGPUパーティクルシステムであり、Houdiniとの連携により様々な興味深い使用法が可能です。しかし、VFXgraphが新しいツールであるため、資料が少ないため、この記事では動画チュートリアルとしてこのプロセスを紹介しています​​。",
      "en": "This article describes the basic flow of creating a PointCache in Houdini, exporting it, and loading it into Unity's VFXgraph, a GPU particle system that can be used in real-time, and which, in conjunction with Houdini, offers a variety of interesting uses. VFXgraph is a real-time GPU particle system that can be used in conjunction with Houdini in a variety of interesting ways. However, since VFXgraph is a new tool, documentation is scarce, so this article presents the process as a video tutorial."
  }
},
{
  "thumbnailUrl": "2019122001.jpg",
  "creationDate": "2019-12-20",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "[記事削除済み] Houdini18 で追加された LOP ノードを調べてみた",
      "en": "[Article deleted] I looked into the LOP nodes added in Houdini18."
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/10_Houdini/11_SOLARIS/90_solaris_lop_node/",
  "categories": "Houdini",
  "tags": "USD SOLARIS Houdini",
  "articleId": 2019122001,
  "summary": {
      "ja": "Houdini18のSOLARISのStageネットワーク用LOPノードを紹介する記事です。主要ノードの基本使い方を解説し、SOPからLOPへのジオメトリの持ち込み方法、Primitive、PointInstancer、Collectionsなどの機能が紹介されています。また、Python Scriptを用いたシーングラフ編集の可能性も触れられ、SOLARISノードがHoudini風にUSDを直感的に操作できるように設計されていると述べています。",
      "en": "This article introduces the LOP node for the Stage network of SOLARIS in Houdini18. It explains the basic usage of the main nodes and introduces how to bring geometry from SOP to LOP, Primitive, PointInstancer, Collections, and other features. It also touches on the possibility of scene graph editing using Python Script, and states that the SOLARIS node is designed to allow intuitive manipulation of USD in a Houdini-like manner."
  }
},
{
  "thumbnailUrl": "2019122101.jpg",
  "creationDate": "2019-12-21",
  "author": {
      "name": "@harayoki",
      "twitterIcon": "harayoki.jpg",
      "qiitaUrl": "https://qiita.com/harayoki",
      "twitterUrl": "https://twitter.com/harayoki"
  },
  "title": {
      "ja": "Houdini18のGoZ処理の仕組みを追う",
      "en": "Follow how Houdini18's GoZ process works"
  },
  "articleUrl": "https://qiita.com/harayoki/items/4c2e6aedf96112d55c55",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122101,
  "summary": {
      "ja": "この記事は、HoudiniとZBrush間の連携ツールであるGoZの動作に焦点を当てています。GoZはHoudiniからZBrushへのメッシュデータのエクスポートとインポートの際に使用され、相互にデータ変換を行います。具体的には、HoudiniのグループをZBrushのサブツール名やポリグループなどに変換する方法が説明されています。これにより、HoudiniとZBrushの間でのワークフローがスムーズになります​​​​​​。",
      "en": "This article focuses on the workings of GoZ, a collaboration tool between Houdini and ZBrush; GoZ is used when exporting and importing mesh data from Houdini to ZBrush and performs data conversion between the two. Specifically, it explains how to convert Houdini groups to ZBrush subtool names, polygroups, etc. This allows for a smoother workflow between Houdini and ZBrush."
  }
},
{
  "thumbnailUrl": "2019122201.jpg",
  "creationDate": "2019-12-22",
  "author": {
      "name": "@jhorikawa_err",
      "twitterIcon": "jhorikawa_err.jpg",
      "qiitaUrl": "https://qiita.com/jhorikawa_err",
      "twitterUrl": "https://twitter.com/jhorikawa_err"
  },
  "title": {
      "ja": "Houdiniでポワンカレディスク上のタイリング模様を作る",
      "en": "Creating a tiling pattern on a Pointe Carrée disk in Houdini"
  },
  "articleUrl": "https://qiita.com/jhorikawa_err/items/24785f6255ccf19296b3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122201,
  "summary": {
      "ja": "この記事では、双曲幾何学の一部であるポワンカレディスク上でのタイリング模様の作成方法について説明しています。Houdiniを使用して、双曲幾何学のモデルに基づいた複雑な模様を作る過程が詳細に解説されています。この記事は、主にピクセル処理ではなくメッシュデータを使用してタイリング模様を作る方法に焦点を当てています。最終的な結果は色々な多角形が作られた順番に応じて色を変えられ、Mergeされます​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to create a tiling pattern on a Pointe Carrée disk, which is part of hyperbolic geometry, and details the process of using Houdini to create complex patterns based on hyperbolic geometry models. The article focuses primarily on how to create tiling patterns using mesh data rather than pixel processing. The end result is a variety of polygons that are colored according to the order in which they were created and merge The final result is a tiling pattern."
  }
},
{
  "thumbnailUrl": "2019122301.jpg",
  "creationDate": "2019-12-23",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "M@ya の Paint FX っぽいトゥーンアウトライン",
      "en": "M@ya's Paint FX-like toon outline"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2019/12/paintfx-outlines-in-houdini.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122301,
  "summary": {
      "ja": "この記事は、M@yaに搭載されているPaintFXのToon Outlineに似たアウトラインをHoudiniで生成する方法について紹介している。プロセスには、Rubber Toyなどのジオメトリを使い、Geometryノード、Object Merge、Deleteノードなどを通じてアウトラインを作成する手順が含まれる。アウトラインの形状はPolyWireノードで調整され、最終的に色を設定してMantraでレンダリングされる。ただし、状況によっては望ましくないアウトラインが生成されることがあり、完全プロシージャルな解決策にはさらなる検討が必要である​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to generate an outline in Houdini similar to PaintFX's Toon Outline in M@ya. The process involves using geometry such as Rubber Toy and creating an outline through Geometry nodes, Object Merge, and Delete nodes. The shape of the outline is adjusted with the PolyWire node, and finally the color is set and rendered in Mantra. However, undesirable outlines may be generated in some situations, and a fully procedural solution requires further investigation. The following is an example of a fully procedural solution."
  }
},
{
  "thumbnailUrl": "2019122401.jpg",
  "creationDate": "2019-12-24",
  "author": {
      "name": "@ijiVFX",
      "twitterIcon": "ijiVFX.jpg",
      "qiitaUrl": "https://qiita.com/ijiVFX",
      "twitterUrl": "https://twitter.com/ijiVFX"
  },
  "title": {
      "ja": "HoudiniのPresetについて",
      "en": "About Preset in Houdini"
  },
  "articleUrl": "https://qiita.com/ijiVFX/items/6be3e7850884c652ad9d",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122401,
  "summary": {
      "ja": "この記事では、Houdiniの日常的な作業を簡単にするためにノードのPreset機能について説明しています。ユーザーは頻繁に行う設定をプリセットとして保存し、その後の作業を簡単にすることができます。プリセットの設定ファイルはユーザーのプリファレンスディレクトリに保存されます。また、プリセットの引っ越しや編集方法、HDA（Houdini Digital Assets）のプリセットの適用方法についても解説されています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes the Node's Preset feature to simplify everyday work in Houdini. Users can save frequently performed settings as presets to simplify subsequent work. Preset configuration files are stored in the user's preference directory. It also explains how to move and edit presets and how to apply presets in HDA (Houdini Digital Assets) HDA (Houdini Digital Assets)."
  }
},
{
  "thumbnailUrl": "2019122501.jpg",
  "creationDate": "2019-12-25",
  "author": {
      "name": "@towazumi",
      "twitterIcon": "towazumi.jpg",
      "qiitaUrl": "https://qiita.com/towazumi",
      "twitterUrl": "https://twitter.com/towazumi"
  },
  "title": {
      "ja": "ネットワークエディタにスクリプトショートカットメニューを表示する",
      "en": "Display script shortcut menu in network editor"
  },
  "articleUrl": "https://qiita.com/towazumi/items/3c87dd58376dbf4b4152",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122501,
  "summary": {
      "ja": "この記事では、HoudiniのネットワークエディタでShift+Tabキーを使って独自メニューを表示する方法を紹介しています。HoudiniはHDA, シェルフ, プリセットなどの便利なツールが豊富ですが、改造を楽しむ方向けに、スクリプトからノードを作成し、カスタムショートカットメニューを表示する方法が説明されています。メニューの表示にはhou.qt.Menuを使用し、メニューと一緒に画像も表示するウィジェットの作成方法も解説しています。さらに、特定のノード操作に関するスクリプト例も提供しています​​​​​​​​。",
      "en": "This article shows how to use the Shift+Tab key in Houdini's Network Editor to display your own menus.Houdini has a wealth of useful tools such as HDA, Shelves, and Presets, but for those who enjoy modding, you can create nodes from scripts, For those who enjoy modding, this tutorial explains how to create a node from a script and display a custom shortcut menu. Menus are displayed using hou.qt.Menu, and how to create a widget that displays an image along with the menu is also explained. In addition, example scripts for specific node operations are provided The scripts are as follows"
  }
}





,
{
  "thumbnailUrl": "2019120102.jpg",
  "creationDate": "2019-12-01",
  "author": {
      "name": "@sho7noka",
      "twitterIcon": "sho7noka.jpg",
      "qiitaUrl": "https://qiita.com/sho7noka",
      "twitterUrl": "https://twitter.com/sho7noka"
  },
  "title": {
      "ja": "VEX&VOP チートシート",
      "en": "VEX&VOP Cheat Sheet"
  },
  "articleUrl": "https://qiita.com/sho7noka/items/df7109f42d8e2cfce503",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120102,
  "summary": {
      "ja": "この記事は、HoudiniのVEXとVOPの比較と使い方をまとめたチートシートを提供しています。VOPはVEXのラッパーであり、Houdiniを効果的に使用するにはVEXの理解が重要です。記事では、SOP Attribute, DOP Geometry VOP, COP VOPなどのVOPとVEXノードの比較表を提供し、HOM (Houdini Object Model)を使用したVEXのPython記述例も紹介しています。最後に、ノードベースの弱点として他者への技術伝達の難しさを指摘しています​​​​​​。",
      "en": "DumThis article provides a cheat sheet comparing and using VEX and VOP in Houdini.VOP is a wrapper for VEX and understanding VEX is critical to using Houdini effectively. The article provides a comparison table of VOP and VEX nodes, including SOP Attribute, DOP Geometry VOP, and COP VOP, as well as an example Python description of VEX using the HOM (Houdini Object Model). Finally, it points out the difficulty of transferring technology to others as a weakness of node-based systems.my"
  }
},
{
  "thumbnailUrl": "2019120202.jpg",
  "creationDate": "2019-12-02",
  "author": {
      "name": "@MIN0NIUM",
      "twitterIcon": "MIN0NIUM.jpg",
      "qiitaUrl": "https://qiita.com/MIN0NIUM",
      "twitterUrl": "https://twitter.com/MIN0NIUM"
  },
  "title": {
      "ja": "Houdiniでパラメータを作る話",
      "en": "Talk about creating parameters in Houdini."
  },
  "articleUrl": "https://qiita.com/MIN0NIUM/items/e23a5b3b62b344b621f5",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120202,
  "summary": {
      "ja": "こちらの記事では、Houdiniでのパラメータ作成の基本から応用までを丁寧に解説しています。Edit Parameter InterfaceとType Propertiesの違い、パラメータの種類やデフォルト値の設定、範囲の決定、表示設定のカスタマイズ方法などが説明されています。また、Pythonを使用してパラメータを追加、編集、削除する方法も紹介されており、hou.Parmとhou.ParmTemplateの違いや基本的な使用法が解説されています​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article explains the differences between the Edit Parameter Interface and Type Properties, the types of parameters and default values, determining ranges, and how to customize display settings. The book also explains how to use Python to create parameters. It also shows how to add, edit, and delete parameters using Python, and explains the differences between hou.Parm and hou.ParmTemplate and their basic usage. Parm."
  }
},
{
  "thumbnailUrl": "2019120302.jpg",
  "creationDate": "2019-12-03",
  "author": {
      "name": "@mhpzlry0ftTQG1R",
      "twitterIcon": "mhpzlry0ftTQG1R.jpg",
      "qiitaUrl": "https://qiita.com/mhpzlry0ftTQG1R",
      "twitterUrl": "https://twitter.com/mhpzlry0ftTQG1R"
  },
  "title": {
      "ja": "Pythonでパラメータの値を移す",
      "en": "Transferring parameter values in Python"
  },
  "articleUrl": "https://qiita.com/mhpzlry0ftTQG1R/items/eb8896958cf8d5cc210b",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120302,
  "summary": {
      "ja": "この記事では、Houdiniのノード上のパラメータが更新された際にPythonスクリプトを自動実行する機能について説明しています。Python Source Editorを使って関数を定義し、Callback Scriptを介してこれを呼び出す方法が紹介されています。具体的な関数定義と実行例が提供されており、HoudiniをPythonで操作するための基本的なクラスや関数も説明されています。また、ボタンを使用してユーザーの操作に応じてスクリプトを実行する方法も解説されています​​​​​​​​​​​​。",
      "en": "This article describes the ability to automatically run Python scripts when parameters on Houdini nodes are updated, and shows how to define a function using the Python Source Editor and call it via Callback Script The following is an example of a function definition and execution. Specific function definitions and execution examples are provided, as well as the basic classes and functions for working with Houdini in Python. It also explains how to use buttons to execute scripts in response to user actions The following is a list of the functions and classes that can be used in Python."
  }
},
{
  "thumbnailUrl": "2019120402.jpg",
  "creationDate": "2019-12-04",
  "author": {
      "name": "@h_kishimoto",
      "twitterIcon": "h_kishimoto.jpg",
      "qiitaUrl": "https://qiita.com/h_kishimoto",
      "twitterUrl": "https://twitter.com/h_kishimoto"
  },
  "title": {
      "ja": "\"見習い\"なので初級チュートリアルに積極的につまづいていく",
      "en": "The apprentice is actively involved in the beginner's tutorial."
  },
  "articleUrl": "https://qiita.com/h_kishimoto/items/2004d8e920d9343c1c6a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120402,
  "summary": {
      "ja": "この記事は、Houdini Apprenticeの初心者向けのチュートリアルで、特に初心者がつまずきやすいポイントに焦点を当てています。著者はHoudiniの基本的な使用方法を説明し、日本語版PDFのチュートリアルで省略されている部分や不明瞭な点を補足しています。特に「ノード, ネットワーク & デジタルアセット」のチュートリアルについて詳しく解説しており、この記事はそれを補完する内容になっています​​。",
      "en": "This article is a tutorial for beginners of Houdini Apprentice, focusing especially on the points that beginners tend to stumble upon. The author explains the basic use of Houdini and supplements the tutorials with sections that are omitted or unclear in the Japanese version of the PDF tutorial. In particular, the \"Nodes, Networks & Digital Assets\" tutorial is explained in detail, and this article complements it."
  }
},
{
  "thumbnailUrl": "2019120502.jpg",
  "creationDate": "2019-12-05",
  "author": {
      "name": "@hirapot",
      "twitterIcon": "hirapot.jpg",
      "qiitaUrl": "https://qiita.com/hirapot",
      "twitterUrl": "https://twitter.com/hirapot"
  },
  "title": {
      "ja": "Calabi Yau 多様体を作ってみよう",
      "en": "Let's make Calabi Yau manifolds!"
  },
  "articleUrl": "https://qiita.com/hirapot/items/4a7c467151d856338e5e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120502,
  "summary": {
      "ja": "この記事では、著者がPythonとHoudiniを使用してCalabi Yau多様体を作成する過程を紹介しています。記事にはPythonコードの詳細な説明が含まれており、Houdiniでのジオメトリ生成に関連する様々な概念（例えば、for文、while文、yield、print文など）が説明されています。著者はこのプロジェクトを通じてPythonの基礎を紹介し、最終的に複雑な幾何学的形状の生成に成功しています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "In this article, the author walks through the process of creating a Calabi Yau manifold using Python and Houdini. The article includes a detailed description of the Python code and explains various concepts related to geometry generation in Houdini, such as for, while, yield, and print statements. The author introduces the basics of Python through this project and ultimately succeeds in generating complex geometric shapes The author has also written a series of tutorials on the use of Python in the field of geometry."
  }
},
{
  "thumbnailUrl": "2019120602.jpg",
  "creationDate": "2019-12-06",
  "author": {
      "name": "@MIN0NIUM",
      "twitterIcon": "MIN0NIUM.jpg",
      "qiitaUrl": "https://qiita.com/MIN0NIUM",
      "twitterUrl": "https://twitter.com/MIN0NIUM"
  },
  "title": {
      "ja": "Houdini はじめてのBlock Begin/End",
      "en": "Houdini First Time Block Begin/End"
  },
  "articleUrl": "https://qiita.com/MIN0NIUM/items/e7c94f3b3470dae642f6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120602,
  "summary": {
      "ja": "この記事は、Houdiniの初心者がBlock Begin/Endノードの使用方法を学ぶためのガイドです。著者は、繰り返し処理に使用するBlock Begin/Endノードの種類や設定方法を詳細に説明しています。記事では、イテレーションの概念やBlock BeginのMethodパラメータ、Block EndのIteration Methodパラメータなど、さまざまなパラメータについて解説しています。これらの知識を身につけることで、Houdiniでより複雑な操作が可能になると説明されています​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article is a guide for Houdini beginners to learn how to use Block Begin/End nodes. The author details the types of Block Begin/End nodes used for iteration and how to set them up. The article explains the concept of iteration, the Method parameter for Block Begin, the Iteration Method parameter for Block End, and many other parameters. It is explained that with the knowledge of these, more complex operations can be performed in Houdini The author has also written a series of tutorials on the use of Python in the field of geometry."
  }
},
{
  "thumbnailUrl": "2019120702.jpg",
  "creationDate": "2019-12-07",
  "author": {
      "name": "@takashiFujiyama",
      "twitterIcon": "takashiFujiyama.jpg",
      "qiitaUrl": "https://qiita.com/takashiFujiyama",
      "twitterUrl": "https://twitter.com/takashiFujiyama"
  },
  "title": {
      "ja": "ミスティーク変身エフェクト",
      "en": "Mystique Transformation Effects"
  },
  "articleUrl": "https://qiita.com/takashiFujiyama/items/31d881b3b2c0c05ddecb",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120702,
  "summary": {
      "ja": "この記事は、X-menのミスティークの変身エフェクトを模倣する方法について述べています。著者は、動きのある2人のモデルを用いて男性モデルから女性モデルへの変形を行い、VDBを利用してポリゴンへの変換とRayの適用を行います。その後、モデルにScatterを適用し、Solver内で変身エリアの計算を行います。羽のコピーとアニメーションも取り入れ、位置と回転を考慮したキャラクターへの当て込みを行い、最終的にAlphaでフェードさせたアニメーションを作成します​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article discusses how to mimic the Mystique transformation effect in X-men. The author uses two models in motion to transform a male model into a female model, then uses VDB to convert the model to polygons and apply Ray. Scatter is then applied to the models and the transformation area is calculated within Solver. We also incorporate the copying and animation of the wings, apply them to the character taking into account position and rotation, and finally create a faded animation in Alpha The final animation is faded in Alpha."
  }
},
{
  "thumbnailUrl": "2019120802.jpg",
  "creationDate": "2019-12-08",
  "author": {
      "name": "@aiu_617",
      "twitterIcon": "aiu_617.jpg",
      "qiitaUrl": "https://qiita.com/aiu_617",
      "twitterUrl": "https://twitter.com/aiu_617"
  },
  "title": {
      "ja": "ちょっと躓いた時の対処法",
      "en": "What to do when you stumble a bit"
  },
  "articleUrl": "https://qiita.com/aiu_617/items/1d87fb66947068a33d1b",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120802,
  "summary": {
      "ja": "この記事ではHoudiniで躓いた際の対処法を著者の経験を元に述べています。Houdiniの学習環境について触れた後、具体的な問題として、Shelfから作成したSimが既存DOP内に作成される問題、Persp Viewへの戻り方、SceneViewのNearやFarの変更方法、ObjレベルでTransformを誤って操作してしまった際の対処法などが紹介されています​​​​​​​​​​。",
      "en": "The article describes how to deal with Houdini stumbles based on the author's experience, and after mentioning the Houdini learning environment, it discusses specific issues such as the problem of Sims created from Shelf being created in an existing DOP, how to return to Persp View, how to change Near and Far in SceneView, and how to handle the problem of accidental manipulation of Transforms at the Obj level. How to change Far, and what to do if you accidentally manipulate Transform at the Obj level. The following is a brief overview of the issues that can be addressed in the DOP"
  }
},
{
  "thumbnailUrl": "2019120902.jpg",
  "creationDate": "2019-12-09",
  "author": {
      "name": "@MIN0NIUM",
      "twitterIcon": "MIN0NIUM.jpg",
      "qiitaUrl": "https://qiita.com/MIN0NIUM",
      "twitterUrl": "https://twitter.com/MIN0NIUM"
  },
  "title": {
      "ja": "はじめてのL-System",
      "en": "First L-System"
  },
  "articleUrl": "https://qiita.com/MIN0NIUM/items/79a5ab492b9eb44f11d4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019120902,
  "summary": {
      "ja": "L-Systemの基本から、その使用方法までを説明している記事です。L-System SOPの基本ルールや、3D空間での枝分かれの方法、ジオメトリへの適用方法などが解説されています。また、L-Systemの学習に役立つリソースとしてCG Forgeのチュートリアルや、他の有用な記事へのリンクも提供されています​​​​​​​​​​​​。",
      "en": "This article explains the basics of the L-System and how to use it, including the basic rules of the L-System SOP, how to branch in 3D space, and how to apply it to geometry. It also provides links to CG Forge tutorials and other useful articles as resources for learning the L-System. L-System."
  }
},
{
  "thumbnailUrl": "2019121002.jpg",
  "creationDate": "2019-12-10",
  "author": {
      "name": "@yu_kita",
      "twitterIcon": "yu_kita.jpg",
      "qiitaUrl": "https://qiita.com/yu_kita",
      "twitterUrl": "https://twitter.com/yu_kita"
  },
  "title": {
      "ja": "対数螺旋をVEXでつくる",
      "en": "Create logarithmic spirals in VEX"
  },
  "articleUrl": "https://qiita.com/yu_kita/items/17ab5bd1caa5f7bb83e2",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121002,
  "summary": {
      "ja": "対数螺旋の作成方法に関する記事で、対数螺旋の基本的な概念からVEXを使用した実装方法までが詳述されています。対数螺旋の極座標表示、その性質、そしてVEXを使った対数螺旋のコーディング方法が解説されています。特に、対数螺旋のピッチの重要性や、黄金螺旋を作成するためのbの値の求め方が詳しく説明されています​​​​​​​​​​​​​​。",
      "en": "This article on how to create logarithmic spirals details the basic concepts of logarithmic spirals and how to implement them using VEX. It explains the polar coordinate representation of logarithmic spirals, their properties, and how to code logarithmic spirals using VEX. In particular, the importance of the pitch of the logarithmic spiral and how to find the value of b to create the golden spiral are explained in detail ."
  }
},
{
  "thumbnailUrl": "2019121102.jpg",
  "creationDate": "2019-12-11",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "[記事削除済み] SOLARISでUSDファイルを開く話",
      "en": "[Article deleted] Talk about opening USD files in SOLARIS"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/10_Houdini/11_SOLARIS/01_solaris_open_usd/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121102,
  "summary": {
      "ja": "この記事では、Houdini18に新たに追加されたSOLARISを用いてUSDファイルを開く方法について紹介しています。USDはPixarが開発した、複数のファイルをプロシージャルに合成してシーングラフを構築できるフォーマットです。SOLARISはUSDをネイティブでサポートし、SOPのようにプロシージャルに扱うことが可能です。また、SOLARIS上のノードはそれぞれがUSDファイルとしてレイヤー扱いされます。記事では、USDファイルをダウンロードし、SOLARISの機能や画面構成を使ってUSDファイルを開くプロセスを説明しています。SOLARISは、USDファイルの柔軟な扱いを可能にするツールとしての強みがあります。",
      "en": "This article shows how to open a USD file using SOLARIS, a new addition to Houdini 18. USD is a format developed by Pixar that allows multiple files to be procedurally combined to build a scene graph. SOLARIS supports USD natively and can handle it procedurally like SOP. Also, each node on SOLARIS is treated as a layered USD file. The article describes the process of downloading a USD file and opening it using SOLARIS features and screen configuration SOLARIS has its strengths as a tool that allows flexible handling of USD files."
  }
},
{
  "thumbnailUrl": "2019121202.jpg",
  "creationDate": "2019-12-12",
  "author": {
      "name": "@d658t",
      "twitterIcon": "d658t.jpg",
      "qiitaUrl": "https://qiita.com/d658t",
      "twitterUrl": "https://twitter.com/d658t"
  },
  "title": {
      "ja": "初心者向けノードサンプル集",
      "en": "Sample collection of nodes for beginners"
  },
  "articleUrl": "https://qiita.com/d658t/items/1a44518523f8ffb14cd4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121202,
  "summary": {
      "ja": "この記事は、Houdiniを始めたばかりの初心者向けのノードベースのサンプル集を紹介しています。サンプルは、Vop、VEX、Pythonなどのコーディングを使用せずに、ノードと簡単なエクスプレッション（四則演算など）のみで構成されています。モデラー寄りの内容で、Houdini18.0.287を使用しています​​。",
      "en": "This article presents a collection of node-based samples for beginners just starting out with Houdini. The samples consist only of nodes and simple expressions (e.g. quadratures) without any coding (Vop, VEX, Python, etc.). The content is modeler-oriented and uses Houdini 18.0.287."
  }
},
{
  "thumbnailUrl": "2019121302.jpg",
  "creationDate": "2019-12-13",
  "author": {
      "name": "@55hertz",
      "twitterIcon": "55hertz.jpg",
      "qiitaUrl": "https://qiita.com/55hertz",
      "twitterUrl": "https://twitter.com/55hertz"
  },
  "title": {
      "ja": "レイアウトの基本とカメラ設定",
      "en": "Layout Basics and Camera Settings"
  },
  "articleUrl": "https://qiita.com/55hertz/items/0998e1ae2a3ebf0a401a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121302,
  "summary": {
      "ja": "この記事は、CG初心者向けに、レイアウト（構図）とカメラ設定の基本について解説しています。レイアウトの代表的なタイプ（クローズアップ、ミディアムショット、ロングショット、エスタブリッシングショット）や、Houdiniでのレイアウトとカメラ設定に関する技術的な詳細が説明されています。また、Houdini内でカメラ設定を行うためのhipファイルの使用方法についても触れています​​。",
      "en": "This article covers the basics of layout (composition) and camera settings for beginners in computer graphics. It describes the typical types of layout (close-up, medium shot, long shot, establishing shot) as well as the technical details of layout and camera settings in Houdini. It also discusses the use of HIP files for camera settings within Houdini."
  }
},
{
  "thumbnailUrl": "2019121402.jpg",
  "creationDate": "2019-12-14",
  "author": {
      "name": "@egzao1o9_CG",
      "twitterIcon": "egzao1o9_CG.jpg",
      "qiitaUrl": "https://qiita.com/egzao1o9_CG",
      "twitterUrl": "https://twitter.com/egzao1o9_CG"
  },
  "title": {
      "ja": "プロシージャルにメッシュ変形",
      "en": "Procedural mesh deformation"
  },
  "articleUrl": "https://qiita.com/egzao1o9_CG/items/431eb40f1a9a52a3d924",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121402,
  "summary": {
      "ja": "この記事では、メッシュをベースにしたプロシージャルモデリングによる変形の方法を初心者向けにチュートリアル形式で紹介しています。Houdiniの面白さや使い方の基本をわかりやすく説明している点が特徴です​​。",
      "en": "This article is a beginner's tutorial on mesh-based procedural modeling for deformation, featuring interesting and easy-to-understand explanations of the basics of Houdini and how to use it."
  }
},
{
  "thumbnailUrl": "2019121502.jpg",
  "creationDate": "2019-12-15",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "この翻訳で許して (VELLUM CLOTH: TIPS &TRICKS)",
      "en": "Forgive me for this translation (VELLUM CLOTH: TIPS &TRICKS)"
  },
  "articleUrl": "https://www.sidefx.com/ja/tutorials/vellum-cloth-tips-tricks/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121502,
  "summary": {
      "ja": "Houdini 18で改良されたVellumキャラクタツールに関する記事です。新機能と優れたワークフローテクニックを取り入れ、クロスシミュレーションの生成をよりわかりやすくアートディレクト可能なプロセスとしています。初期セットアップやクロスシミュレーションに適したジオメトリタイプ、衝突ジオメトリの準備、トラブルシューティングの例やシミュレーション後の修正方法などが紹介されています​​。",
      "en": "This article is about the improved Vellum character tool in Houdini 18. It incorporates new features and better workflow techniques to make cross-simulation generation a more straightforward and art-directable process. The article covers initial setup, geometry types suitable for cross-simulation, preparing collision geometry, troubleshooting examples and post-simulation fixes."
  }
},
{
  "thumbnailUrl": "2019121602.jpg",
  "creationDate": "2019-12-16",
  "author": {
      "name": "@okada_takuya",
      "twitterIcon": "okada_takuya.jpg",
      "qiitaUrl": "https://qiita.com/okada_takuya",
      "twitterUrl": "https://twitter.com/okada_takuya"
  },
  "title": {
      "ja": "Houdiniで鳥の群れを飛ばそう",
      "en": "Fly a flock of birds with Houdini!"
  },
  "articleUrl": "https://qiita.com/okada_takuya/items/42ab3fedefbb9b3a4710",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121602,
  "summary": {
      "ja": "この記事はHoudini Indie 17.5.327を使用して鳥の群れを作成する方法について説明しています。著者は鳥のモデルを簡単なジオメトリで作成し、はばたきのアニメーションにはSin関数を使用しています。パーティクルの生成、インスタンスの配置方法も解説されており、Houdini Advent Calendar 2018の方法を参考にしています。著者はHoudiniを学ぶ過程で得た知識を共有し、日本語コミュニティへの貢献を目指しています​​​​​​​​​​​​。",
      "en": "This article describes how to create a flock of birds using Houdini Indie 17.5.327. The author creates a bird model with simple geometry and uses the Sin function for flapping animation. It also explains how to generate particles and place instances, referencing the methods of the Houdini Advent Calendar 2018. The author aims to share the knowledge gained in the process of learning Houdini and contribute to the Japanese community!"
  }
},
{
  "thumbnailUrl": "2019121702.jpg",
  "creationDate": "2019-12-17",
  "author": {
      "name": "@hirapot",
      "twitterIcon": "hirapot.jpg",
      "qiitaUrl": "https://qiita.com/hirapot",
      "twitterUrl": "https://twitter.com/hirapot"
  },
  "title": {
      "ja": "使える！と思ったこと、うっかり忘れていたこと 【役に立つかも？しれない集】",
      "en": "Useful! Things I thought I could use, things I accidentally forgot to mention [Might be useful? Might be useful?"
  },
  "articleUrl": "https://qiita.com/hirapot/items/8dba483922b46920d3aa",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121702,
  "summary": {
      "ja": "この記事では、著者がHoudiniで有用だと思った小ネタや忘れていたことを紹介しています。例えば、ビューポートでvelocityを確認する方法、trail sopでベロシティを計算する方法、EdgeTransportでカーブの距離を確認する方法などが含まれています。また、trailsopを使用してベロシティを計算する際にNormalの値を指定する方法や、vdbが平面でも厚みを持つこと、ボロノイでデフォームやクラスター作成が可能であることなどが解説されています​​​​​​​​​​​​​​​​​​。",
      "en": "In this article, the author presents small things that he found useful in Houdini and forgot to mention. For example, it includes how to check velocity in the viewport, how to calculate velocity with a trail sop, and how to check the distance of a curve with EdgeTransport. It also explains how to specify a Normal value when calculating velocity using trail sop, how vdb has thickness even on a plane, and how Voronoi can be used to deform and create clusters! "
  }
},
{
  "thumbnailUrl": "2019121802.jpg",
  "creationDate": "2019-12-18",
  "author": {
      "name": "@ogrew",
      "twitterIcon": "ogrew.jpg",
      "qiitaUrl": "https://qiita.com/ogrew",
      "twitterUrl": "https://twitter.com/ogrew"
  },
  "title": {
      "ja": "Houdiniに出会って半年くらいでやったこと",
      "en": "What I did in the first six months or so after meeting Houdini"
  },
  "articleUrl": "https://taiga.hatenadiary.com/entry/2019/12/25/134717",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121802,
  "summary": {
      "ja": "この記事は、David Adanの「Introduction to VEX」のコースを完走した著者の経験を共有するものです。記事では、HScriptとChannel Referencing、VEXの基本概念とジオメトリ操作、パーティクルとボリューム、剛体動力学（RBD）に関する各セクションの内容が紹介されています。著者は、VEXの学習プロセスを楽しんでおり、特にGeometry manipulationやParticleの再利用、RBDの応用について触れています",
      "en": "This article shares the author's experience completing David Adan's Introduction to VEX course. The article includes sections on HScript and Channel Referencing, basic VEX concepts and geometry manipulation, particles and volumes, and rigid body dynamics (RBD). The author enjoys the learning process of VEX and specifically mentions Geometry manipulation, Particle reuse, and RBD applications!  "
  }
},
{
  "thumbnailUrl": "2019121902.jpg",
  "creationDate": "2019-12-19",
  "author": {
      "name": "@sho7noka",
      "twitterIcon": "sho7noka.jpg",
      "qiitaUrl": "https://qiita.com/sho7noka",
      "twitterUrl": "https://twitter.com/sho7noka"
  },
  "title": {
      "ja": "HoudiniでVFXクラウドコンピューティング",
      "en": "VFX Cloud Computing with Houdini"
  },
  "articleUrl": "https://qiita.com/sho7noka/items/5f9c96b04e41c028cac8",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019121902,
  "summary": {
      "ja": "この記事では、仕事用マシンの限界を超えるために、著者がGCPのCentOS環境でHoudini用VFXクラウドワークステーションを構築する過程を説明しています。著者は、GCPを選んだ理由、Teradici PCoIPクライアントの使用、UbuntuとCentOSの比較、マーケットプレイスでのインストール方法、Houdiniのインストールと設定方法について詳細に説明しています。このセットアップは、特にシミュレーションなどメモリやGPUを多く必要とする作業に適していると述べています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes the author's process of building a VFX cloud workstation for Houdini on GCP's CentOS environment in order to push the limits of his work machine. The author details why he chose GCP, the use of the Teradici PCoIP client, a comparison of Ubuntu and CentOS, how to install in the marketplace, and how to install and configure Houdini. He states that this setup is especially suited for tasks that require a lot of memory and GPU, such as simulations  The installation is also available on the Houdini website."
  }
},
{
  "thumbnailUrl": "2019122002.jpg",
  "creationDate": "2019-12-20",
  "author": {
      "name": "@TaroOzaki",
      "twitterIcon": "TaroOzaki.jpg",
      "qiitaUrl": "https://qiita.com/TaroOzaki",
      "twitterUrl": "https://twitter.com/TaroOzaki"
  },
  "title": {
      "ja": "【第1版】階段のプロシージャルモデリング : Stairs Procedural Modeling",
      "en": "[1st Edition] Procedural Modeling of Stairs : Stairs Procedural Modeling"
  },
  "articleUrl": "https://qiita.com/TaroOzaki/items/f249ae4b5e8dc46f16f3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122002,
  "summary": {
      "ja": "この記事では、Houdiniを使用して階段をプロシージャルにモデリングする方法を紹介しています。10種類のノードを使い、7つのパラメータを設定して、直進階段、折返し階段、螺旋階段のモデリングを行うことができます​​​​​​​​​​。",
      "en": "This article shows how to procedurally model a staircase using Houdini, using 10 different nodes and 7 parameters to model a straight staircase, a turning staircase, and a spiral staircase! ."
  }
},
{
  "thumbnailUrl": "2019122102.jpg",
  "creationDate": "2019-12-21",
  "author": {
      "name": "@ts_bros",
      "twitterIcon": "ts_bros.jpg",
      "qiitaUrl": "https://qiita.com/ts_bros",
      "twitterUrl": "https://twitter.com/ts_bros"
  },
  "title": {
      "ja": "Scrach for FX RnDTASK",
      "en": "Scrach for FX RnDTASK"
  },
  "articleUrl": "https://qiita.com/ts_bros/items/fd10fa3d94d05d8d82cf",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122102,
  "summary": {
      "ja": "この記事は、Houdiniを使用したFX R&D（リサーチ＆デベロップメント）について説明しています。FX工程でR&Dを行う際の目標設定、共有の重要性、実例として泡の表現開発について述べています​​​​。",
      "en": "This article discusses FX R&D (Research & Development) using Houdini, the importance of goal setting and sharing when conducting R&D in the FX process, and the development of foam expressions as a practical example! The article also discusses the development of bubble expressions as an example."
  }
},
{
  "thumbnailUrl": "2019122202.jpg",
  "creationDate": "2019-12-22",
  "author": {
      "name": "@shin_t_o_",
      "twitterIcon": "shin_t_o_.jpg",
      "qiitaUrl": "https://qiita.com/shin_t_o_",
      "twitterUrl": "https://twitter.com/shin_t_o_"
  },
  "title": {
      "ja": "Houdiniからトイドローン(Tello)を動かしてみる",
      "en": "Running a toy drone (Tello) from Houdini"
  },
  "articleUrl": "https://qiita.com/shin_t_o_/items/511fd74fcdd73b8176f6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122202,
  "summary": {
      "ja": "この記事では、Houdiniを用いてトイドローン（Tello）を操作する方法について説明しています。Houdiniで生成した軌跡データをPythonを介してドローンへ命令を送り、実際に飛行させる実験を行っています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article explains how to operate a toy drone (Tello) using Houdini, and experiments with sending commands to the drone via Python from trajectory data generated by Houdini to actually make it fly!  The drone is then controlled by the user."
  }
},
{
  "thumbnailUrl": "2019122402.jpg",
  "creationDate": "2019-12-24",
  "author": {
      "name": "@ARTsak",
      "twitterIcon": "ARTsak.jpg",
      "qiitaUrl": "https://qiita.com/ARTsak",
      "twitterUrl": "https://twitter.com/ARTsak"
  },
  "title": {
      "ja": "Houdini初学の為に簡単に行きたいと思います+簡易ROCKgenerator",
      "en": "I'd like to go easy for Houdini beginners + simple ROCKgenerator"
  },
  "articleUrl": "http://artsak666.hatenablog.com/entry/hadc",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122402,
  "summary": {
      "ja": "この記事では、Houdiniの初心者向けガイドが提供されています。主に、Houdiniの基本的なデータ構造、VEXやVOPなどのプログラミング言語、SOP（Scene Object Parameters）について説明されています。また、デジタルアセットの作成方法として簡易な「岩ジェネレーター」の作成過程が示され、ポイントジェネレーター、VDB変換、リメッシュ、UVマッピングなどのプロセスが紹介されています。最後に、Houdiniはアーティストの視点に基づいたCGツールであると結論づけています。",
      "en": "This article provides a beginner's guide to Houdini. It mainly explains the basic data structures of Houdini, programming languages such as VEX and VOP, and Scene Object Parameters (SOP). In addition, the process of creating a simple \"rock generator\" is shown as a way to create digital assets, and the processes of point generator, VDB conversion, remesh, and UV mapping are introduced. Finally, it concludes that Houdini is a CG tool based on the artist's point of view."
  }
},
{
  "thumbnailUrl": "2019122502.jpg",
  "creationDate": "2019-12-25",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "HoudiniでUV展開＆リグ入門",
      "en": "Introduction to UV Development & Rigging in Houdini"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/e15d53e88e9cc018d18f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2019122502,
  "summary": {
      "ja": "この記事は、Houdiniを使用したUV展開とリグの基礎を説明しています。UV展開のさまざまな方法とそれらの特徴、ボーン構造の作成方法、およびそれらの実装方法について詳細に説明しています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article covers the basics of UV development and rigging using Houdini, detailing the different methods of UV development and their characteristics, how to create bone structures, and how to implement them The article explains in detail the different methods of UV development and their characteristics, how to create bone structures and how to implement them."
  }
}

,
{
  "thumbnailUrl": "2020120101.jpg",
  "creationDate": "2020-12-01",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "Houdiniの新しいリギングとアニメーション：KineFX機能まとめ",
      "en": "New Rigging and Animation in Houdini: KineFX Feature Summary"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/cc4c7c529fed71f03df3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120101,
  "summary": {
      "ja": "この記事では、Houdini18.5の新しいリギングとアニメーション機能、KineFXについて紹介されています。KineFXは、従来のOBJレベルのボーンからSOPレベルのボーンへの移行を特徴とし、多くの機能を備えています。記事では、KineFXでよく使用されるノードのパターンを紹介し、参考となるカンニングペーパー的な内容を提供しています。また、KineFXの利用によりリギングやアニメーションの作業が容易になったことが強調されており、Houdini19でさらなる機能拡張が予想されています​​​​。",
      "en": "This article introduces the new rigging and animation feature in Houdini 18.5, KineFX, which features a transition from traditional OBJ-level bones to SOP-level bones, with many more features. The article presents node patterns commonly used in KineFX and provides a cheat sheet of reference content. It also highlights the ease of rigging and animation work with KineFX and anticipates further enhancements in Houdini19."
  }
},
{
  "thumbnailUrl": "2020120201.jpg",
  "creationDate": "2020-12-02",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "オーナメントを通してプロシージャルに関する必須事項",
      "en": "Essentials for Procedures through Ornaments"
  },
  "articleUrl": "https://nullnode.wixsite.com/houdinipsalm/post/houdini-advent-calendar-2020-day-2th",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120201,
  "summary": {
      "ja": "この記事では、Houdiniを用いてクリスマスシーズンに相応しいオーナメントのモデリング方法を紹介しています。プロシージャルな手法を用い、限られたSOPの数でモデリングする方法が解説されており、楽しく学べる手順が提供されています。使用されているHoudiniのバージョンは18.0.499で、この記事を通じてオーソドックスなクリスマスオーナメントの作成方法が披露されています​​​​。",
      "en": "This article shows how to model ornaments appropriate for the Christmas season using Houdini. It explains how to model with a limited number of SOPs using a procedural approach and provides a fun procedure to learn. The Houdini version used is 18.0.499, and through this article, an orthodox method of creating Christmas ornaments is demonstrated."
  }
},
{
  "thumbnailUrl": "2020120301.jpg",
  "creationDate": "2020-12-03",
  "author": {
      "name": "@PontaYamazato",
      "twitterIcon": "PontaYamazato.jpg",
      "qiitaUrl": "https://qiita.com/PontaYamazato",
      "twitterUrl": "https://twitter.com/PontaYamazato"
  },
  "title": {
      "ja": "今年のカード",
      "en": "This year's Christmas card"
  },
  "articleUrl": "https://note.com/pontayamazato/n/nafc634230d84",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120301,
  "summary": {
      "ja": "筆者は毎年12月に、Houdiniを使ってクリスマスカードを作成し、お世話になった人々に贈っています。記事では、今年のカードについて記述しており、冬の暖かい部屋の雰囲気を表現したデザインになっています。外が雪で覆われている可能性を示唆しつつ、キャラクターを椅子に座らせてくつろいでいる様子を描くことも可能であったが、省略されています。また、著者はHoudiniを「魔法の筆と魔法の絵具と魔法の画用紙」と評し、長年にわたる愛着を表現しています​​​​​​。",
      "en": "Every December, the author creates Christmas cards using Houdini and sends them to those who have helped him. In the article, he describes this year's card, which is designed to depict the atmosphere of a warm winter room. It could have depicted a character sitting comfortably in a chair, suggesting the possibility of snow outside, but it was omitted. The author also describes Houdini as \"magic brushes, magic paints, and magic drawing paper,\" expressing his attachment to it over the years! ."
  }
},
{
  "thumbnailUrl": "2020120401.jpg",
  "creationDate": "2020-12-04",
  "author": {
      "name": "@mizunori",
      "twitterIcon": "mizunori.jpg",
      "qiitaUrl": "https://qiita.com/mizunori",
      "twitterUrl": "https://twitter.com/mizunori"
  },
  "title": {
      "ja": "Point Deformを使って破壊表現をしてみる",
      "en": "Try using Point Deform for destructive expressions"
  },
  "articleUrl": "https://qiita.com/mizunori/items/d58661369e4e3cfc2fff",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120401,
  "summary": {
      "ja": "この記事は、HoudiniのPoint Deformツールを用いた破壊表現の作成方法について説明しています。著者は、学校のグループワークでPoint Deformを使用した経験を基に、その使用法を紹介しています。記事では、シミュレーションではなく、物理的に100%正確ではない方法でオブジェクトの破壊を表現する手法を説明しています。具体的な手順として、土台の準備、ガイドオブジェクトの作成、最終的な変形処理が説明されています。最後に、この手法の利点と限界についても触れています​​​​​​​​​​​​​​。",
      "en": "This article describes how to create destructive representations using Houdini's Point Deform tool. The author draws on his experience using Point Deform in group work at school to show how it is used. The article describes a method for representing the destruction of an object in a way that is not a simulation and is not 100% physically accurate. Specific steps are described: preparation of the foundation, creation of the guide object, and the final deformation process. Finally, the advantages and limitations of this technique are discussed The following is a brief description of the method"
  }
},
{
  "thumbnailUrl": "2020120501.jpg",
  "creationDate": "2020-12-05",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "今年作ったHDAのご紹介をします",
      "en": "Here are some of the HDAs we made this year"
  },
  "articleUrl": "https://kickbase.net/entry/my_hda",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120501,
  "summary": {
      "ja": "この記事では、著者が1年間に作成したHDA（Houdini Digital Assets）について紹介しています。特に、汎用性の高いHDAに焦点を当て、その作り方と使用例を提供しています。記事では、Min/Max/AverageSOP、Decoratorパターン、SwitchSOPの代替案としてのHDA作成方法などが詳述されています。また、著者は、Houdiniの勉強会も開催しており、その内容や目的についても触れています。記事全体を通して、HDAの作成と活用方法についての洞察を提供しています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to create destructive representations using Houdini's Point Deform tool. The author draws on his experience using Point Deform in group work at school to show how it is used. The article describes a method for representing the destruction of an object in a way that is not a simulation and is not 100% physically accurate. Specific steps are described: preparation of the foundation, creation of the guide object, and the final deformation process. Finally, the advantages and limitations of this technique are discussed The following is a brief description of the method"
  }
},
{
  "thumbnailUrl": "2020120601.jpg",
  "creationDate": "2020-12-06",
  "author": {
      "name": "@TaroOzaki",
      "twitterIcon": "TaroOzaki.jpg",
      "qiitaUrl": "https://qiita.com/TaroOzaki",
      "twitterUrl": "https://twitter.com/TaroOzaki"
  },
  "title": {
      "ja": "ジオメトリからポリライン抽出あれこれ  -Various Methods to Extract Polyline from Geometry-",
      "en": "Various Methods to Extract Polyline from Geometry"
  },
  "articleUrl": "https://qiita.com/TaroOzaki/items/73d5b3d0d0bc0919828f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120601,
  "summary": {
      "ja": "この記事では、ジオメトリからポリラインを抽出するさまざまな方法について説明しています。著者は、ポリラインの抽出がシーンの制作において重要であるとし、そのための複数の手法を紹介しています。主に、EndsSOP、PrimitiveSOP、ConvertLineSOP、PolyPathSOPを使用した方法が詳述されています。また、ジオメトリを切断して抽出する方法や、EdgeGroupからの抽出、グリッド構造からのアイソカーブ抽出など、多様なアプローチが提示されています​​​​​​​​。",
      "en": "This article discusses different methods of extracting polylines from geometry. The author states that polyline extraction is important in the creation of a scene and introduces several methods for this purpose. The main methods detailed are using EndsSOP, PrimitiveSOP, ConvertLineSOP, and PolyPathSOP. Various approaches are also presented, including cutting and extracting geometry, extracting from EdgeGroups, and extracting isocurves from grid structures The following is a list of the methods used in the book"
  }
},
{
  "thumbnailUrl": "2020120701.jpg",
  "creationDate": "2020-12-07",
  "author": {
      "name": "@jhorikawa_err",
      "twitterIcon": "jhorikawa_err.jpg",
      "qiitaUrl": "https://qiita.com/jhorikawa_err",
      "twitterUrl": "https://twitter.com/jhorikawa_err"
  },
  "title": {
      "ja": "建築＋生物の大学の授業でHoudiniを使った話",
      "en": "A story about using Houdini in an architecture + biology college class."
  },
  "articleUrl": "https://qiita.com/jhorikawa_err/items/5e97ab9d8386aa47c1eb",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120701,
  "summary": {
      "ja": "この記事は、イギリスのバートレット建築学校で行われた建築＋生物デザインの授業について述べています。授業では、生物学と建築の融合したコンセプトでデザインを行い、Houdiniを主要ツールとして使用しました。授業の主なテーマは「Emergence（創発）」で、3つのタームに分けて進行し、生徒は基本的なシミュレーション技術を学び、それを拡張して最終的に空間デザインを行いました​​​​​​​​。",
      "en": "This article describes an architecture + biodesign class at the Bartlett School of Architecture in England. The class was designed around the concept of combining biology and architecture and used Houdini as the primary tool. The main theme of the class was \"Emergence,\" and the class progressed in three terms, with students learning basic simulation techniques, which were then extended and finally designed in space The students learned basic simulation techniques, which were then extended and finally used to design their own spaces."
  }
},
{
  "thumbnailUrl": "2020120801.jpg",
  "creationDate": "2020-12-08",
  "author": {
      "name": "@70_cg_art",
      "twitterIcon": "70_cg_art.jpg",
      "qiitaUrl": "https://qiita.com/70_cg_art",
      "twitterUrl": "https://twitter.com/70_cg_art"
  },
  "title": {
      "ja": "Houdiniで始めるGUIツール作成【PySide2】",
      "en": "Creating GUI tools starting with Houdini [PySide2]."
  },
  "articleUrl": "https://qiita.com/70_cg_art/items/2cf6a4b82b23a0f303ad",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120801,
  "summary": {
      "ja": "この記事は、Houdini上でGUIツールを作成するためのPySide2の使用方法に焦点を当てています。Python初学者向けに、基本的なダイアログ、ボタン、テキストエディタ、チェックボックス、スピンボックス、コンボボックスの作成方法を順を追って説明しています。最終的には、PySide2を使ってHoudiniで動作するGUIツールを作成することを目標としています​​​​​​​​​​​​。",
      "en": "This article focuses on using PySide2 to create GUI tools on Houdini, with step-by-step instructions for Python beginners on how to create basic dialogs, buttons, text editors, check boxes, spin boxes, and combo boxes . Ultimately, the goal is to create a GUI tool that works in Houdini using PySide2! The course is designed to help you create a GUI tool that will work in Houdini."
  }
},
{
  "thumbnailUrl": "2020120901.jpg",
  "creationDate": "2020-12-09",
  "author": {
      "name": "@takaf51",
      "twitterIcon": "takaf51.jpg",
      "qiitaUrl": "https://qiita.com/takaf51",
      "twitterUrl": "https://twitter.com/takaf51"
  },
  "title": {
      "ja": "SolarisでRedshiftなどのサードパーティのレンダリングエンジンを使っている時でもHoudini GLで素早くViewに表示させる方法。",
      "en": "How to quickly display in View with Houdini GL even when using a third party rendering engine such as Redshift in Solaris."
  },
  "articleUrl": "https://qiita.com/takaf51/items/f53d84ae0a1e029c440a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120901,
  "summary": {
      "ja": "この記事では、HoudiniのSolarisでRedshiftを使用している際に、Houdini GLを使って迅速にビュー表示する方法を紹介しています。レンダリングエンジンとしてRedshiftを使いつつも、Houdini GLを用いて作業効率を高めるためのテクニックを提供しています。具体的には、Material LibraryでKarmaの設定を行い、Collectノードでまとめ上げることで、HoudiniGLとKarmaでのレンダリングが可能になります​​​​​​​​。",
      "en": "This article focuses on using PySide2 to create GUI tools on Houdini, with step-by-step instructions for Python beginners on how to create basic dialogs, buttons, text editors, check boxes, spin boxes, and combo boxes . Ultimately, the goal is to create a GUI tool that works in Houdini using PySide2! The course is designed to help you create a GUI tool that will work in Houdini."
  }
},
{
  "thumbnailUrl": "2020121001.jpg",
  "creationDate": "2020-12-10",
  "author": {
      "name": "@towazumi",
      "twitterIcon": "towazumi.jpg",
      "qiitaUrl": "https://qiita.com/towazumi",
      "twitterUrl": "https://twitter.com/towazumi"
  },
  "title": {
      "ja": "Houdini HDKでpmxファイルを読み込むサンプル",
      "en": "Sample of reading pmx file in Houdini HDK"
  },
  "articleUrl": "https://qiita.com/towazumi/items/de22b08fdd4330a69481",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121001,
  "summary": {
      "ja": "この記事は、Houdini HDKを使ってMMDのpmxファイルフォーマットを読み込む方法について詳述しています。記事では、Houdini HDKを使用してポリゴン情報、法線、UV、マテリアル設定などを読み込むプロセスを説明しています。プロジェクトの作成、ノードのパラメータ設定、処理の実装、ファイルの読み込み、pmxファイルのパース、軸変換行列の作成、ポイントとポリゴンの追加、マテリアル情報の構築などのステップが含まれます​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article details how to use Houdini HDK to read MMD's pmx file format. The article describes the process of loading polygon information, normals, UVs, material settings, etc. using Houdini HDK. Steps include creating a project, parameterizing nodes, implementing processing, loading files, parsing pmx files, creating an axis transformation matrix, adding points and polygons, and building material information  ."
  }
},
{
  "thumbnailUrl": "2020121101.jpg",
  "creationDate": "2020-12-11",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "使ってはいけないstamp!",
      "en": "Don't use STAMP!"
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2020/12/stamp.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121101,
  "summary": {
      "ja": "[記事削除済み] この記事では、Houdiniのアニメーション機能であるStampとTime shift Sopの使用に関して警告を発しています。多くのチュートリアルでこれらの機能を使った悪い例が見られるため、その代わりにアトリビュートを直接操作する方法を推奨しています。特に、キーフレームでのアニメーション制作の際は、Wrangleノードでch関数の特定のオプションを使用することが望ましいとしています。この方法はパフォーマンスが格段に良いため、Stampはどうしても必要な場合にのみ使用すべきだと述べています​",
      "en": "[Article deleted] This article issues a warning regarding the use of Houdini's animation features Stamp and Time shift Sop. Because many tutorials show bad examples of using these functions, we recommend instead the direct manipulation of attributes. In particular, he states that when creating animations with keyframes, it is preferable to use the specific options of the ch function in the Wrangle node. Since this method has much better performance, Stamp states that it should only be used when absolutely necessary"
  }
},
{
  "thumbnailUrl": "2020121201.jpg",
  "creationDate": "2020-12-12",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "SOLARISでUSDアセットを作る",
      "en": "Creating USD Assets in SOLARIS"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/05_DCCTool/10_Houdini/11_SOLARIS/13_create_usdAssets_01/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121201,
  "summary": {
      "ja": "この記事では、Houdini19のSOLARISを使用してUSDアセットを作成する方法について説明しています。重点は「USDの汎用アセット」の作成で、USDのシーングラフを自由に設計し、SOLARIS上でレイアウトやゲームエンジンへの転送、他のツールでの使用などに対応する汎用アセットの構造を構築します。基本的なアセットのセットアップから始め、USDのコンポジションの理解を深めることが目的です。また、アセットにはさまざまな種類があり、特にBG/Propをベースに構築を行います。USDファイルの分割、コンポジションアークの利用、最小単位のアセットの構築などのプロセスを通じて、効率的で汎用的なUSDアセットの作成方法を解説しています。",
      "en": "This article describes how to create USD assets using SOLARIS in Houdini19. The emphasis is on creating \"generic USD assets,\" where you design your own USD scene graph and build a generic asset structure in SOLARIS for layout, transfer to game engines, use in other tools, etc. The goal is to start with a basic asset setup and gain a better understanding of USD compositions. The course also builds on the different types of assets, particularly BG/Prop, and explains how to create efficient and generic USD assets through processes such as splitting USD files, using composition arcs, and building the smallest unit of assets."
  }
},
{
  "thumbnailUrl": "2020121301.jpg",
  "creationDate": "2020-12-13",
  "author": {
      "name": "@55hertz",
      "twitterIcon": "55hertz.jpg",
      "qiitaUrl": "https://qiita.com/55hertz",
      "twitterUrl": "https://twitter.com/55hertz"
  },
  "title": {
      "ja": "Solaris,USD,instancerを使った作例(.hip)",
      "en": "Example using Solaris,USD,instancer(.hip)"
  },
  "articleUrl": "https://qiita.com/55hertz/items/2c6f5e7cead95ef62064",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121301,
  "summary": {
      "ja": "この記事は、Houdini18の新機能であるSolarisとUSDを使って背景シーンを作成するプロセスを紹介しています。具体的には、LOPでのオブジェクトの読込み、Variantの作成、Instancerによる配置、そしてReferenceによる合成が含まれています。USDの利点として、多数のオブジェクトや複雑なシーンを効率的に管理できる点が挙げられており、Solarisを使用することでノードベースの視覚的な理解が可能になると述べています。",
      "en": "This article takes you through the process of creating a background scene using the new Solaris and USD features in Houdini 18. The benefits of USD include the ability to efficiently manage large numbers of objects and complex scenes, and the use of Solaris allows for node-based visual understanding. Solaris allows for node-based visual understanding."
  }
},
{
  "thumbnailUrl": "2020121401.jpg",
  "creationDate": "2020-12-14",
  "author": {
      "name": "@talkyren",
      "twitterIcon": "talkyren.jpg",
      "qiitaUrl": "https://qiita.com/talkyren",
      "twitterUrl": "https://twitter.com/talkyren"
  },
  "title": {
      "ja": "HoudiniのVEXを利用したヒガンバナの手続き型生成の一例",
      "en": "An example of procedural generation of Lycoris radiata using VEX in Houdini"
  },
  "articleUrl": "https://qiita.com/talkyren/items/4b6219c0ce258e1c9904",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121401,
  "summary": {
      "ja": "著者は、HoudiniのVEXを使用してヒガンバナのモデリングプロセスを説明しています。ヒガンバナの形状分析から始まり、Houdiniでの具体的な作業過程について詳細に記述しています。これには、全体構造の設計、細部デザインの作成、そして最終的な組み立てが含まれています。また、花弁の生成にはパラメトリック方程式を使った螺旋形のモデリングが採用されており、花軸の生成にも特定のステップが説明されています。",
      "en": "The author describes the modeling process of a higanbana using Houdini's VEX. Beginning with a shape analysis of the higanbana, the specific process of working in Houdini is described in detail. This includes the design of the overall structure, the creation of the detail design, and the final assembly. The modeling of spiral shapes using parametric equations is employed to generate the petals, and specific steps are also described for the generation of the floral axis."
  }
},
{
  "thumbnailUrl": "2020121501.jpg",
  "creationDate": "2020-12-15",
  "author": {
      "name": "@procedural_design",
      "twitterIcon": "procedural_design.jpg",
      "qiitaUrl": "https://qiita.com/procedural_design",
      "twitterUrl": "https://twitter.com/procedural_design"
  },
  "title": {
      "ja": "L-SYSTEM 2020++",
      "en": "L-SYSTEM 2020++"
  },
  "articleUrl": "https://qiita.com/procedural_design/items/a27b38e862bcfcb2f09e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121501,
  "summary": {
      "ja": "この記事では、L-Systemの基本操作と応用について詳しく説明されています。主要なタートルコマンド、再帰性、確率ベースのルール、ローカル変数と条件分岐などが取り上げられています。著者は、L-Systemを用いた形状生成の例として、人型のモデリングを示しており、これはL-Systemの様々な機能を組み合わせて利用することで、より複雑な構造を生成できることを示しています。",
      "en": "This article details the basic operations and applications of the L-System. Key turtle commands, recursion, probability-based rules, local variables and conditional branching are covered. The author shows modeling of human figures as an example of shape generation using the L-System, which demonstrates how the various features of the L-System can be used in combination to generate more complex structures."
  }
},
{
  "thumbnailUrl": "2020121601.jpg",
  "creationDate": "2020-12-16",
  "author": {
      "name": "@TF_siri",
      "twitterIcon": "TF_siri.jpg",
      "qiitaUrl": "https://qiita.com/TF_siri",
      "twitterUrl": "https://twitter.com/TF_siri"
  },
  "title": {
      "ja": "お茶を飲もう",
      "en": "Let's have some tea."
  },
  "articleUrl": "https://qiita.com/TF_siri/items/972d723e221a849575bf",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121601,
  "summary": {
      "ja": "この記事では、著者がHoudiniを使用して「茶」をテーマにしたシーンを作成する過程を紹介しています。カップのモデリングから始まり、茶の液体のシミュレーション、そして湯気のシミュレーションまで、各ステップにおいてHoudiniのさまざまな機能がどのように使われるかが説明されています。特に液体シミュレーションには、sphereを用いたアニメーション設定やflipsourceの設定、そしてDOPnetworkの詳細な設定が含まれています。また、湯気のシミュレーションでは、Pyrosourceの使用とPyro solverの設定が詳しく解説されています。",
      "en": "In this article, the author describes the process of creating a \"tea\" themed scene using Houdini. Starting with the modeling of the cups, the simulation of the liquid tea, and then the simulation of the steam, the article explains how the various features of Houdini are used in each step. In particular, the liquid simulation includes animation settings using spheres, flipsource settings, and detailed DOPnetwork settings. In addition, for the steam simulation, the use of Pyrosource and the Pyro solver settings are explained in detail."
  }
},
{
  "thumbnailUrl": "2020121701.jpg",
  "creationDate": "2020-12-17",
  "author": {
      "name": "@junichinakano",
      "twitterIcon": "junichinakano.jpg",
      "qiitaUrl": "https://qiita.com/junichinakano",
      "twitterUrl": "https://twitter.com/junichinakano"
  },
  "title": {
      "ja": "測地線について",
      "en": "About geodesic lines"
  },
  "articleUrl": "https://qiita.com/junichinakano/items/8617581e12d1ace6f98a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121701,
  "summary": {
      "ja": "この記事では、ポリゴンオブジェクト上の測地線（滑らかな曲面上の直線）について説明しています。測地線は、地球の大圏航路のように、曲面上での最短経路として表現されます。曲面上のベクトルの平行移動、測地線の方程式、ポリゴン上での測地線の近似方法などが説明されており、Houdiniを使用しての可視化の利点が強調されています​​​​​​​​​​。",
      "en": "This article describes geodesics (straight lines on smooth surfaces) on polygonal objects. A geodesic is represented as the shortest path on a curved surface, like the Earth's great circle route. It explains the translations of vectors on surfaces, the geodesic equation, and how to approximate geodesics on polygons, highlighting the advantages of visualization using Houdini. The advantages of visualization using Houdini are emphasized."
  }
},
{
  "thumbnailUrl": "2020121801.jpg",
  "creationDate": "2020-12-18",
  "author": {
      "name": "@tsuka0245",
      "twitterIcon": "tsuka0245.jpg",
      "qiitaUrl": "https://qiita.com/tsuka0245",
      "twitterUrl": "https://twitter.com/tsuka0245"
  },
  "title": {
      "ja": "DOP Solverをつくる",
      "en": "Create DOP Solver"
  },
  "articleUrl": "https://qiita.com/tsuka0245/items/c85ea3f5e678e6b72a4f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121801,
  "summary": {
      "ja": "この記事では、Houdiniで簡単なシミュレーションのSolverをDOPで実装する方法を解説しています。具体的には、シミュレーションオブジェクトの作成、Solverの作成、その他の設定について説明されています。オイラー法を用いたSolverの作成と、その結果として球が壁に衝突して跳ねるシミュレーションが示されています。また、シンプレクティック法を用いたSolverの実装も紹介されています​​​​​​​​​​​​​​​​。",
      "en": "This article explains how to implement a simple simulation Solver in Houdini with DOP. Specifically, it describes the creation of a simulation object, the creation of a Solver, and other settings. It shows the creation of a Solver using the Eulerian method and the resulting simulation of a sphere bouncing against a wall. An implementation of Solver using the symplectic method is also presented ."
  }
},
{
  "thumbnailUrl": "2020121901.jpg",
  "creationDate": "2020-12-19",
  "author": {
      "name": "@dicepastoso",
      "twitterIcon": "dicepastoso.jpg",
      "qiitaUrl": "https://qiita.com/dicepastoso",
      "twitterUrl": "https://twitter.com/dicepastoso"
  },
  "title": {
      "ja": "MOPs(Motion Operator)の簡単なご紹介",
      "en": "Brief introduction to MOPs (Motion Operators)"
  },
  "articleUrl": "https://qiita.com/dicepastoso/items/433d5f45c2a85960a038",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121901,
  "summary": {
      "ja": "この記事では、Houdiniの拡張機能であるMOPs（Motion Operator）について紹介しています。MOPsは、モーショングラフィックスを簡単かつ直感的に行うために開発され、オープンソースで提供されています。MOPsのインストール方法、更新方法、使用方法、提供されているノードの種類、質問や不具合報告の方法などが説明されています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article introduces MOPs (Motion Operator), an extension to Houdini that was developed to make motion graphics easy and intuitive and is available as open source. MOPs, the types of nodes provided, and how to ask questions or report problems. The MOPs are available for download from the MOPs website."
  }
},
{
  "thumbnailUrl": "2020122001.jpg",
  "creationDate": "2020-12-20",
  "author": {
      "name": "@egzao1o9_CG",
      "twitterIcon": "egzao1o9_CG.jpg",
      "qiitaUrl": "https://qiita.com/egzao1o9_CG",
      "twitterUrl": "https://twitter.com/egzao1o9_CG"
  },
  "title": {
      "ja": "（]ミズクラゲ（]ミ （]彡 （]ミ （]彡（]ミ",
      "en": "Moon jellyfish"
  },
  "articleUrl": "https://qiita.com/egzao1o9_CG/items/34007d1ff59209888733",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122001,
  "summary": {
      "ja": "この記事では、Houdiniを使ってミズクラゲの3Dモデルを作成するプロセスが紹介されています。モデリングの各ステップ、使用されたノード、モデルの各部位（体、触手、目、口腕、胃、水管）の作成方法が詳細に説明されています。最終的にはこれらのパーツを組み合わせてミズクラゲのモデルを完成させ、レイアウト、ライティング、マテリアルの調整を行っています",
      "en": "This article describes the process of creating a 3D model of a water jellyfish using Houdini. It details each step of the modeling process, the nodes used, and how each part of the model (body, tentacles, eyes, mouth arms, stomach, and water tubes) was created. Ultimately, these parts are combined to complete the model of the water jellyfish, and layout, lighting, and materials are adjusted!"
  }
},
{
  "thumbnailUrl": "2020122101.jpg",
  "creationDate": "2020-12-21",
  "author": {
      "name": "@tanitta",
      "twitterIcon": "tanitta.jpg",
      "qiitaUrl": "https://qiita.com/tanitta",
      "twitterUrl": "https://twitter.com/tanitta"
  },
  "title": {
      "ja": "HoudiniによるプロシージャルUnityプロジェクト",
      "en": "Procedural Unity projects with Houdini"
  },
  "articleUrl": "https://tanitta.hatenablog.com/entry/2020/12/21/230403",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122101,
  "summary": {
      "ja": "HoudiniとUnityの組み合わせにおける作業効率化を目指し、HoudiniからUnityへのコマンド送信システムを開発。このシステムは、Houdiniで定義したコマンドをUnityのソケットサーバーに送信し、Unity上で自動的に処理を実行させています。FBX書き出しやPrefab作成などの例を紹介し、このシステムによってUnityでの作業が大幅に効率化されたことが示されています。",
      "en": "Aiming to improve work efficiency in the combination of Houdini and Unity, a system for sending commands from Houdini to Unity was developed. This system sends commands defined in Houdini to Unity's socket server and automatically executes them in Unity. The system has made working with Unity much more efficient."
  }
},
{
  "thumbnailUrl": "2020122201.jpg",
  "creationDate": "2020-12-22",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "炎プロップ作成シーン配布＆解説",
      "en": "Flame prop creation scene distribution & explanation"
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/39573c3d0302d2d58f33",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122201,
  "summary": {
      "ja": "この記事では、Houdiniを使用して炎のプロップを作成するためのシーン（アセット）が配布されています。Houdiniはバージョンアップにより機能が向上しており、特にPyro系の機能が進化しています。本アセットは、Houdini 17で作成され、後続のバージョンで追加された機能を取り入れて改修されています。これは、古いテクニックも含め、レガシーだが有用な技術を示す資料となっています",
      "en": "In this article, a scene (asset) is distributed for creating a flame prop using Houdini.Houdini has been improving its functionality with each version upgrade, especially the Pyro system. This asset was created in Houdini 17 and has been modified to incorporate features added in subsequent versions. It is a document that demonstrates legacy but useful techniques, including some older techniques"
  }
},
{
  "thumbnailUrl": "2020122301.jpg",
  "creationDate": "2020-12-23",
  "author": {
      "name": "@yu_nnnnnnnn",
      "twitterIcon": "yu_nnnnnnnn.jpg",
      "qiitaUrl": "https://qiita.com/yu_nnnnnnnn",
      "twitterUrl": "https://twitter.com/yu_nnnnnnnn"
  },
  "title": {
      "ja": "オーラ系エフェクトのアプローチ",
      "en": "Aura-based effects approach"
  },
  "articleUrl": "https://wakumoku.com/2020/12/23/%e3%82%aa%e3%83%bc%e3%83%a9%e7%b3%bb%e3%82%a8%e3%83%95%e3%82%a7%e3%82%af%e3%83%88%e3%81%ae%e3%82%a2%e3%83%97%e3%83%ad%e3%83%bc%e3%83%81/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122301,
  "summary": {
      "ja": "この記事は、Houdiniを使用したオーラ系エフェクトの制作方法を紹介しています。基本的なpyroシミュレーションから、カスタムフィールドや螺旋効果を加えた高度な手法まで解説。筋感や動きの表現が重要で、様々なテクニックを用いて異なるオーラ効果を作成する方法を提供。美しいエフェクトの作成に役立つアプローチと手法を展開させています。",
      "en": "This article shows how to create aura-type effects using Houdini. Explains everything from basic pyro simulation to advanced techniques with custom fields and spiral effects. Provides how to create different aura effects using a variety of techniques, where the expression of striations and movement is important. The approaches and methods are developed to help you create beautiful effects."
  }
},
{
  "thumbnailUrl": "2020122401.jpg",
  "creationDate": "2020-12-24",
  "author": {
      "name": "@kajitaj63b3",
      "twitterIcon": "kajitaj63b3.jpg",
      "qiitaUrl": "https://qiita.com/kajitaj63b3",
      "twitterUrl": "https://twitter.com/kajitaj63b3"
  },
  "title": {
      "ja": "【Houdini】1ジオメトリーから階層付きFBXを出力するツールの開発",
      "en": "Development of a tool to output hierarchical FBX from one geometry."
  },
  "articleUrl": "https://qiita.com/kajitaj63b3/items/2aec4406cd87affcef4b",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122401,
  "summary": {
      "ja": "この記事では、Houdiniで1つのGeometryノード内のジオメトリーを階層化し、階層ごとにTransformを設定してFBX形式で出力するためのツール（HDA）の開発について説明されています。これは、ゲームエンジンでの使用を考慮して、階層構造と自由なTransformを実現するためのツールです",
      "en": "This article describes the development of a tool (HDA) for hierarchizing geometry within a single Geometry node in Houdini, setting up Transforms for each hierarchy, and outputting them in FBX format. This is a tool for hierarchical structures and free Transforms for use in game engines"
  }
},
{
  "thumbnailUrl": "2020122501.jpg",
  "creationDate": "2020-12-25",
  "author": {
      "name": "@radio9997",
      "twitterIcon": "radio9997.jpg",
      "qiitaUrl": "https://qiita.com/radio9997",
      "twitterUrl": "https://twitter.com/radio9997"
  },
  "title": {
      "ja": "リアルタイム向けにこんもりした山を作る",
      "en": "Create a stumpy mountain for real-time"
  },
  "articleUrl": "https://qiita.com/radio9997/items/b614bfb1481f99925ff0",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122501,
  "summary": {
      "ja": "この記事では、HoudiniとUE4を使用してリアルタイムで動作する山の風景を作成する方法が解説されています。HDAを使用してHeightFieldで山のベースを作成し、木をインスタンス配置する手法が紹介されています。これにより、UE4で動くリアルタイムの3D環境を作り出すことができます",
      "en": "This article describes how to create a mountain landscape that runs in real-time using Houdini and UE4. a technique is presented that uses HDA to create a mountain base with a HeightField and instance placement of trees. This allows you to create a real-time 3D environment that runs in UE4!"
  }
}




,{
  "thumbnailUrl": "2020120102.jpg",
  "creationDate": "2020-12-01",
  "author": {
      "name": "@mhpzlry0ftTQG1R",
      "twitterIcon": "mhpzlry0ftTQG1R.jpg",
      "qiitaUrl": "https://qiita.com/mhpzlry0ftTQG1R",
      "twitterUrl": "https://twitter.com/mhpzlry0ftTQG1R"
  },
  "title": {
      "ja": "Houdiniでドット絵作成",
      "en": "Creating dots with Houdini"
  },
  "articleUrl": "https://qiita.com/mhpzlry0ftTQG1R/items/dcd0d28f07736bd513e1",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120102,
  "summary": {
      "ja": "この記事では、Houdini Apprentice 18.5.351を用いてドット絵を作成する手法について解説しています。リファレンス画像の読み込み、解像度設定、Meshの扱い、色や不透明度の調整方法が詳述されています。また、グループ化、アウトライン作成、グラデーションの適用などの応用例や、最終的な画像出力のプロセスも説明されています。",
      "en": "This article describes a technique for creating dots using Houdini Apprentice 18.5.351. It details how to load a reference image, set resolution, work with Mesh, and adjust color and opacity. It also describes the application of grouping, outlining, and applying gradients, as well as the process of outputting the final image."
  }
},
{
  "thumbnailUrl": "2020120202.jpg",
  "creationDate": "2020-12-02",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "諦めたSOPの事：いろどりを増やせそうなSOPだったから。",
      "en": "About the SOP I gave up: it was a SOP that could have increased color."
  },
  "articleUrl": "https://qiita.com/Alidade/items/7616e6d718182c1d3778",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120202,
  "summary": {
      "ja": "記事では、grouprange SOPに関する詳細な説明が提供されています。このSOPは、選択のバリエーションを増やす便利なツールとして紹介されており、特定のプリミティブやポイント、バーテックスを選択してグループ化する機能を持ちます。これにより、様々な形状やデザインが作成可能ですが、グループ指定が重くなる傾向があるため、軽いモデルに適しています。",
      "en": "The article provides a detailed description of the grouprange SOP. This SOP is presented as a useful tool to increase selection variation and has the ability to select and group specific primitives, points, and vertexes. This allows for the creation of a wide variety of shapes and designs, but tends to be heavy on group specification, making it suitable for lighter models."
  }
},
{
  "thumbnailUrl": "2020120302.jpg",
  "creationDate": "2020-12-03",
  "author": {
      "name": "@ijiVFX",
      "twitterIcon": "ijiVFX.jpg",
      "qiitaUrl": "https://qiita.com/ijiVFX",
      "twitterUrl": "https://twitter.com/ijiVFX"
  },
  "title": {
      "ja": "君はお隣さん？一番近い点？それとも座標？",
      "en": "Are you the neighbor? The nearest point? Or coordinates?"
  },
  "articleUrl": "https://qiita.com/ijiVFX/items/0e36f17ddb690ab615eb",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120302,
  "summary": {
      "ja": "この記事は、Houdini内の近傍系VEX関数について詳しく解説しています。nearpoint系、neighbour系、minpos、xyzdist、polyneighbours、surfacedist、ptlinedといった様々な関数の使い方や挙動が説明されています。これらの関数は、点やメッシュとの関連を計算するのに用いられ、Houdiniの多機能かつ強力な特性を示しています。",
      "en": "This article describes in detail the neighborhood VEX functions in Houdini, explaining the usage and behavior of various functions such as nearpoint, neighbour, minpos, xyzdist, polyneighbours, surfacedist, ptlined, etc. The use and behavior of these functions are explained. These functions are used to compute relationships between points and meshes, demonstrating Houdini's versatile and powerful properties."
  }
},
{
  "thumbnailUrl": "2020120402.jpg",
  "creationDate": "2020-12-04",
  "author": {
      "name": "@SaladMix",
      "twitterIcon": "SaladMix.jpg",
      "qiitaUrl": "https://qiita.com/SaladMix",
      "twitterUrl": "https://twitter.com/SaladMix"
  },
  "title": {
      "ja": "HOUDINIでSkin weightのクリーンアップ。",
      "en": "Skin weight cleanup at HOUDINI."
  },
  "articleUrl": "https://qiita.com/SaladMix/items/7a9e1aa348a3a3b6b9c4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120402,
  "summary": {
      "ja": "Houdini 18.5のKineFXを活用し、SkinWeightのクリーンアップ作業の方法を紹介する記事です。ゲーム用アセットのウェイト情報の編集、Influence数の削減、ウェイトの正規化、端数の処理、ウェイトの移動・交換などのプロセスが説明されています。この方法は、特にゲームエンジンの制限やデータ容量削減を目的としていますが、Houdiniのツール化の可能性も示しています。",
      "en": "This article shows how to utilize KineFX in Houdini 18.5 to perform SkinWeight cleanup work. It describes the process of editing weight information for game assets, reducing the number of Influences, normalizing weights, handling fractions, and moving and replacing weights. This method is specifically aimed at game engine limitations and data volume reduction, but also demonstrates the potential of Houdini tooling."
  }
},
{
  "thumbnailUrl": "2020120502.jpg",
  "creationDate": "2020-12-05",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "[記事削除済み] LOPのVEXで遊んでみます",
      "en": "[Article deleted] I'll play with the LOP vex."
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/10_Houdini/11_SOLARIS/09_solaris_vex/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120502,
  "summary": {
      "ja": "この記事では、SOLARISでのVEXの基本的な使い方について紹介されています。記事のゴールは、HoudiniのVEXの基本的な書き方を理解することです。まずは、SOLARISで基本的なVEXを書く方法から始め、USD用の関数を利用してUSDのシーングラフを操作する方法が示されています。また、VEXでの処理対象の指定、ビルトイン変数の使用、制御構文、USD固有の関数の使用方法などが説明されています。さらに、VEXとPythonのパフォーマンス比較も行われ、VEXの方が高速であることが示されています。全体を通して、SOLARISでのVEXの利用に関する基本的な知識とテクニックが提供されています。",
      "en": "This article is about the basic use of VEX in SOLARIS. The goal of the article is to understand how to write basic VEX in Houdini. It begins by showing how to write basic VEX in SOLARIS and how to manipulate the USD scene graph using functions for USD. It also explains how to specify what to process in VEX, use built-in variables, control syntax, and USD-specific functions. In addition, a performance comparison between VEX and Python is provided, showing that VEX is faster. Throughout, basic knowledge and techniques for using VEX in SOLARIS are provided."
  }
},
{
  "thumbnailUrl": "2020120602.jpg",
  "creationDate": "2020-12-06",
  "author": {
      "name": "@Boxsui",
      "twitterIcon": "Boxsui.jpg",
      "qiitaUrl": "https://qiita.com/Boxsui",
      "twitterUrl": "https://twitter.com/Boxsui"
  },
  "title": {
      "ja": "Houdiniで社寺建築！！！～触って3日の感触と展望～",
      "en": "Shrine and Temple Architecture with Houdini! ～Three days of experience and outlook"
  },
  "articleUrl": "https://qiita.com/Boxsui/items/35c68c00a05224d80f2c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120602,
  "summary": {
      "ja": "筆者は大学で史跡の復元VRを作成しており、お寺をVR用に作成し、建築技法や歴史資料を研究しています。Houdiniの特徴として、尺貫法の履歴保持、Copy to point機能の利便性、Booleanの綺麗さが挙げられています。ただし、自動化にはまだ課題があると述べています。",
      "en": "The author is creating VR restorations of historical sites at a university, creating temples for VR, and researching architectural techniques and historical materials.The features of Houdini include scale history retention, the convenience of the Copy to point function, and the cleanliness of Boolean. However, he states that automation is still a challenge."
  }
},
{
  "thumbnailUrl": "2020120802.jpg",
  "creationDate": "2020-12-08",
  "author": {
      "name": "@kkcg",
      "twitterIcon": "kkcg.jpg",
      "qiitaUrl": "https://qiita.com/kkcg",
      "twitterUrl": "https://twitter.com/kkcg"
  },
  "title": {
      "ja": "おじいさんの亡霊を制作する上でつまずいたところなど",
      "en": "What were the stumbling blocks in creating the ghost of your grandfather, etc.?"
  },
  "articleUrl": "https://qiita.com/kkcg/items/23a85d6ff248bfbc88b0",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120802,
  "summary": {
      "ja": "筆者はHoudiniを使用しておじいさんの亡霊FXを制作し、その過程での困難や学びについて語っています。使用したのはHoudini Indie 18.5.351です。写真の加工、HoudiniでのUV問題、Textureの逆さ問題などに取り組みました。VOPの使用、UV参照の方法、Textureの扱いについても触れています。螺旋カーブの作成にはVEXが有効であり、PathDeformerを使った亡霊の動きを調整しました。最後に、反省点として処理の重さが挙げられています​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "The author uses Houdini to create the Ghost of Grandpa FX and discusses the difficulties and lessons learned in the process. Houdini Indie 18.5.351 was used. We tackled photo processing, UV issues in Houdini, Texture inversion issues, etc. We discuss the use of VOPs, how to reference UVs, and how to handle Texture. VEX is useful for creating spiral curves, and we coordinated the movement of ghosts using PathDeformer. Finally, processing weight was mentioned as a point of reflection ."
  }
},
{
  "thumbnailUrl": "2020120902.jpg",
  "creationDate": "2020-12-09",
  "author": {
      "name": "@pky_blog",
      "twitterIcon": "pky_blog.jpg",
      "qiitaUrl": "https://qiita.com/pky_blog",
      "twitterUrl": "https://twitter.com/pky_blog"
  },
  "title": {
      "ja": "SideFX Labs / Substanceプラグインの基本的なところ",
      "en": "SideFX Labs / Substance plugin basics"
  },
  "articleUrl": "http://pkyblog.hatenablog.com/entry/2020/12/09/065721",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020120902,
  "summary": {
      "ja": "この記事は、HoudiniとSubstanceDesignerを結びつけるSideFX Labs/Substanceプラグインについて解説しています。Substance Archive形式のファイルをHoudiniで扱い、BaseColorやNormalなどのチャンネルを分離する方法が紹介されています。また、Substance Material (SOP)ノードやSubstance Archive (COP)ノードの使用法が示されており、Heightマップを取り出し、COPで加工しディスプレイスメントする例が示されています​​​​​​​​​​​​。",
      "en": "This article describes the SideFX Labs/Substance plugin that ties Houdini and SubstanceDesigner together, allowing Substance Archive format files to be handled in Houdini, including BaseColor and Normal. It introduces how to handle Substance Archive format files in Houdini and separate BaseColor, Normal, and other channels. It also shows how to use the Substance Material (SOP) node and the Substance Archive (COP) node, and shows an example of extracting a Height map and processing and displacing it in COP. The following is an example of how to take a Height map, process it with COP, and displace it."
  }
},
{
  "thumbnailUrl": "2020121002.jpg",
  "creationDate": "2020-12-10",
  "author": {
      "name": "@ijiVFX",
      "twitterIcon": "ijiVFX.jpg",
      "qiitaUrl": "https://qiita.com/ijiVFX",
      "twitterUrl": "https://twitter.com/ijiVFX"
  },
  "title": {
      "ja": "たまにはWrangleやVOPのRun Overに感謝しても良いと思います！",
      "en": "Sometimes you can thank Wrangle and VOP's Run Over for that!"
  },
  "articleUrl": "https://qiita.com/ijiVFX/items/2d617ea49c8f1bf4cfab",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121002,
  "summary": {
      "ja": "この記事では、HoudiniのWrangleとVOPのRun Over機能について解説しています。Run Overは、Point、Primitives、Vertices、Numbersなどに対する処理方法を指定します。例として、バウンディングボックスの位置の処理や、Detailレベルでの複雑さの増加が示されています。VOPの場合、AttributeVOPを使った処理と、Detailレベルでのノードの増加について説明されています​​​​​​​​​​。",
      "en": "This article describes Houdini's Wrangle and VOP Run Over features.Run Over specifies how to process for Points, Primitives, Vertices, Numbers, and more. Examples are shown for processing bounding box positions and increasing complexity at the Detail level; for VOPs, processing using AttributeVOPs and increasing nodes at the Detail level are described. In the case of VOPs, the processing using AttributeVOPs and the increase in nodes at the Detail level are described."
  }
},
{
  "thumbnailUrl": "2020121102.jpg",
  "creationDate": "2020-12-11",
  "author": {
      "name": "@tI30961587",
      "twitterIcon": "tI30961587.jpg",
      "qiitaUrl": "https://qiita.com/tI30961587",
      "twitterUrl": "https://twitter.com/tI30961587"
  },
  "title": {
      "ja": "simon の Falling Tool を参考に斜方投射します",
      "en": "Oblique projection with reference to simon's Falling Tool"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/900004726423-%E6%96%9C%E6%96%B9%E6%8A%95%E5%B0%84%E3%83%84%E3%83%BC%E3%83%AB",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121102,
  "summary": {
      "ja": "この記事は、HoudiniとPythonを用いて、斜方投射ツールの作成過程について説明しています。Scene Viewで球を生成し、ランダムな発射角度と初速度で射出することができます。参考チュートリアルのノードネットワークをベースに、自由落下から斜方投射に運動を変更し、XZ-Y空間での斜方投射を実現しました。さらに、第一象限に投げる設定を行い、象限を増やす方法も紹介しています​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes the process of creating an oblique projection tool using Houdini and Python to generate a sphere in Scene View and eject it at a random launch angle and initial velocity. Based on the node network from the reference tutorial, the motion is changed from free fall to oblique projection in XZ-Y space. It also shows how to increase the number of quadrants by setting the throw to the first quadrant ."
  }
},
{
  "thumbnailUrl": "2020121202.jpg",
  "creationDate": "2020-12-12",
  "author": {
      "name": "@bechica",
      "twitterIcon": "bechica.jpg",
      "qiitaUrl": "https://qiita.com/bechica",
      "twitterUrl": "https://twitter.com/bechica"
  },
  "title": {
      "ja": "出る順! Houdini Nodes",
      "en": "In order of appearance! Houdini Nodes"
  },
  "articleUrl": "https://qiita.com/bechica/items/4fb7d46d9268154a8233",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121202,
  "summary": {
      "ja": "この記事は、Houdiniのノードの使用頻度を調査し、学習指針としてまとめたものです。公式チュートリアルを見て、頻出するノードを分析し、それらのノードについて解説しています。上位10位のノードには「Geometry」「Null」「Box」「Transform」などが含まれます。各ノードの基本的な使い方や特徴について詳細な説明がなされています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article is a study of the frequency of use of Houdini nodes and is intended as a learning guideline. It looks at the official tutorials, analyzes the nodes that appear frequently, and explains those nodes. The top 10 nodes include Geometry, Null, Box, and Transform. Detailed explanations are provided on the basic usage and characteristics of each node  The top 10 nodes are"
  }
},
{
  "thumbnailUrl": "2020121302.jpg",
  "creationDate": "2020-12-13",
  "author": {
      "name": "@sho7noka",
      "twitterIcon": "sho7noka.jpg",
      "qiitaUrl": "https://qiita.com/sho7noka",
      "twitterUrl": "https://twitter.com/sho7noka"
  },
  "title": {
      "ja": "Houdini Engine API Python をさくっと書いてみる",
      "en": "Quickly write Houdini Engine API Python"
  },
  "articleUrl": "https://qiita.com/sho7noka/items/f1c3045fcc6b6f8d306c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121302,
  "summary": {
      "ja": "この記事では、Houdini Engine Python APIについての基本的な情報と使い方を説明しています。Houdini Engineの2つの主な用途、エンジンプラグインとバッチ処理について概説し、Python APIの使用方法を具体的なコード例を交えて紹介しています。ただし、外部Pythonインタープリタでのout-of-processセッションの作成はできなかった点など、いくつかの課題も指摘しています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article provides basic information about the Houdini Engine Python API and how to use it, outlines the two main uses of the Houdini Engine, engine plug-ins and batch processing, and shows how to use the Python API with concrete code examples. The book also provides concrete code examples of how to use the Python API. However, it also points out some issues, such as the fact that it was not possible to create out-of-process sessions with an external Python interpreter. The book also includes a section on the use of the Python API."
  }
},
{
  "thumbnailUrl": "2020121402.jpg",
  "creationDate": "2020-12-14",
  "author": {
      "name": "@sho7noka",
      "twitterIcon": "sho7noka.jpg",
      "qiitaUrl": "https://qiita.com/sho7noka",
      "twitterUrl": "https://twitter.com/sho7noka"
  },
  "title": {
      "ja": "Houdini + LiDARを使った3Dスキャンを試す",
      "en": "Try 3D scanning with Houdini + LiDAR"
  },
  "articleUrl": "https://qiita.com/sho7noka/items/5bca51b6cceabc0c399f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121402,
  "summary": {
      "ja": "この記事では、iPhone 12 ProのLiDARスキャナーとHoudiniを組み合わせた3Dスキャンの試みについて述べています。ARKitから取得できる深度データと点群データの取り扱い、HoudiniでのLiDARスキャンデータの読み込み方法について詳しく説明しています。また、様々なLiDAR対応アプリとの連携方法も検討されています。実際にHoudiniでLiDARデータを読み込み、処理する流れが詳細に記されていますが、最終的な成果には至らなかったことが述べられています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes an attempt to combine the iPhone 12 Pro's LiDAR scanner with Houdini for 3D scanning, detailing the handling of depth and point cloud data available from ARKit and how to import LiDAR scan data in Houdini. The presentation also covers how to import LiDAR scan data into Houdini. It also discusses how to work with various LiDAR-enabled applications. The actual process of loading and processing LiDAR data in Houdini is detailed, but it is noted that the final result was not achieved. The final result was not achieved."
  }
},
{
  "thumbnailUrl": "2020121502.jpg",
  "creationDate": "2020-12-15",
  "author": {
      "name": "@pky_blog",
      "twitterIcon": "pky_blog.jpg",
      "qiitaUrl": "https://qiita.com/pky_blog",
      "twitterUrl": "https://twitter.com/pky_blog"
  },
  "title": {
      "ja": "SideFX Labs / Substanceプラグイン応用と実例(hip配布あり)",
      "en": "SideFX Labs / Substance Plugin Applications and Examples (hip distribution available)"
  },
  "articleUrl": "http://pkyblog.hatenablog.com/entry/2020/12/15/122030",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121502,
  "summary": {
      "ja": "この記事では、SideFX LabsとSubstanceプラグインの応用方法について説明しています。特に、入力画像を用いたテクスチャ生成やPhotoshopとの連携に重点を置いています。また、Low/Highモデルからのベイクテクスチャを使用した岩のテクスチャジェネレータやNodevember2020イベントで作成されたモザイクタイルの例も取り上げられています​​​​​​。",
      "en": "This article describes how to apply SideFX Labs and the Substance plugin. Special emphasis is placed on texture generation using input images and working with Photoshop. Also covered are examples of rock texture generators using baked textures from Low/High models and mosaic tiles created with the Nodevember2020 event The following is a brief overview of the project."
  }
},
{
  "thumbnailUrl": "2020121602.jpg",
  "creationDate": "2020-12-16",
  "author": {
      "name": "@okada_takuya",
      "twitterIcon": "okada_takuya.jpg",
      "qiitaUrl": "https://qiita.com/okada_takuya",
      "twitterUrl": "https://twitter.com/okada_takuya"
  },
  "title": {
      "ja": "Houdini18.5 新ノードを使った作例！～従来の方法と一緒に～",
      "en": "Houdini18.5 Examples with the new nodes! ~ with the conventional method!"
  },
  "articleUrl": "https://qiita.com/okada_takuya/items/0243bc0ef38f2761eef3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121602,
  "summary": {
      "ja": "この記事では、Houdini 18.5の新ノードの使用例を提供しています。従来の方法と新しいノードの使用法を比較しながら、バリエーションコピー、ランダムアトリビュートの作成、積もった雪の作成、カーブ上に配置する方法などを解説しています。また、Match Sizeノードの使用例も紹介されています​​​​。",
      "en": "This article provides examples of using the new nodes in Houdini 18.5. It compares the use of the new node with the traditional method, explaining how to copy variations, create random attributes, create piled snow, and place it on a curve. It also provides examples of using the Match Size node."
  }
},
{
  "thumbnailUrl": "2020121702.jpg",
  "creationDate": "2020-12-17",
  "author": {
      "name": "@YoshihiroMiura",
      "twitterIcon": "YoshihiroMiura.jpg",
      "qiitaUrl": "https://qiita.com/YoshihiroMiura",
      "twitterUrl": "https://twitter.com/YoshihiroMiura"
  },
  "title": {
      "ja": "Houdini18.5 RBD Destructionの紹介",
      "en": "Introduction to Houdini18.5 RBD Destruction"
  },
  "articleUrl": "https://houdinifx.jp/blog/houdini-18-5%e3%81%a7%e3%81%ae%e3%82%ac%e3%82%a4%e3%83%89%e3%82%b7%e3%83%9f%e3%83%a5%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121702,
  "summary": {
      "ja": "この記事では、Houdini 18.5でのガイドシミュレーション機能について詳しく説明しています。Houdini 18.5での新機能により、SOP階層とDOP階層の両方でガイドシミュレーションが可能になった点が強調されています。具体的なガイドシミュレーションの作成手順や、破壊されたモデルの準備方法も含まれています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article details the guided simulation capabilities in Houdini 18.5, highlighting new features in Houdini 18.5 that allow guided simulation in both the SOP and DOP hierarchies. Specific guided simulation creation steps and how to prepare a destroyed model are also included."
  }
},
{
  "thumbnailUrl": "2020121802.jpg",
  "creationDate": "2020-12-18",
  "author": {
      "name": "@Muteriku",
      "twitterIcon": "Muteriku.jpg",
      "qiitaUrl": "https://qiita.com/Muteriku",
      "twitterUrl": "https://twitter.com/Muteriku"
  },
  "title": {
      "ja": "TOPのアトリビュートの扱い方入門",
      "en": "Introduction to Handling TOP Attributes"
  },
  "articleUrl": "https://qiita.com/Muteriku/items/809694f64f8ac35f6401",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121802,
  "summary": {
      "ja": "この記事では、HoudiniのTOPネットワークでのアトリビュートの基本的な扱い方について解説されています。主に、フォルダ内のジオメトリファイルをリダクションし、CSVに書き出すプロセスが紹介されています。カスタムアトリビュートとビルトインアトリビュートの種類、確認方法、Pythonを使用したアトリビュートの取得や作成方法が説明されており、TOPネットワークの理解に役立つ内容となっています​​​​​​​​​​​​​​​​。",
      "en": "This article describes the basic way to handle attributes in Houdini's TOP network. Primarily, the process of reducing geometry files in folders and exporting them to CSV is presented. The types of custom and built-in attributes, how to check them, and how to retrieve and create attributes using Python are explained to help you understand the TOP network The book is designed to help you understand the TOP network."
  }
},
{
  "thumbnailUrl": "2020121902.jpg",
  "creationDate": "2020-12-19",
  "author": {
      "name": "@yutaokuyam",
      "twitterIcon": "yutaokuyam.jpg",
      "qiitaUrl": "https://qiita.com/yutaokuyam",
      "twitterUrl": "https://twitter.com/yutaokuyam"
  },
  "title": {
      "ja": "Solverを使って、Creative Codingの関数に対応づけてHoudiniで作ってみる",
      "en": "Use Solver to map to Creative Coding functions and make them in Houdini."
  },
  "articleUrl": "https://qiita.com/yutaokuyam/items/c9201effa58f385868aa",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020121902,
  "summary": {
      "ja": "この記事は、openFrameworksを用いたCreative Codingの関数をHoudiniのSolverと対応付ける方法について解説しています。主に、Creative Codingで一般的な表現をHoudiniに移植する過程が説明されており、Githubに掲載されたコードの解説が含まれています。著者は、このプロセスを通じてHoudiniの理解を深めた経験を共有しており、Creative Coding界隈の人々にHoudiniを紹介する目的で書かれた記事です​​​​​​​​。",
      "en": "This article describes how to map Creative Coding functions with openFrameworks to Houdini's Solver. It mainly describes the process of porting common expressions in Creative Coding to Houdini and includes explanations of code posted on Github. The author shares his experience in understanding Houdini through this process, and the article is written with the purpose of introducing Houdini to people in the Creative Coding community! The author shares his experience in gaining an understanding of Houdini through this process."
  }
},
{
  "thumbnailUrl": "2020122002.jpg",
  "creationDate": "2020-12-20",
  "author": {
      "name": "@nk_wip",
      "twitterIcon": "nk_wip.jpg",
      "qiitaUrl": "https://qiita.com/nk_wip",
      "twitterUrl": "https://twitter.com/nk_wip"
  },
  "title": {
      "ja": "Houdiniでアウトプットして楽しもう",
      "en": "Enjoy the output in Houdini!"
  },
  "articleUrl": "https://qiita.com/nk_wip/items/987eac6c31368b1c88fd",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122002,
  "summary": {
      "ja": "この記事は、Houdiniを使ったアウトプットの楽しみ方を紹介しています。著者は映像分野でフリーランスとして活動しており、趣味でCG作品も制作しています。記事では、処理が軽い、色とアニメーションをコントロール可能なStrand系表現の作成過程が紹介されています。RedshiftとMantraを使ったレンダリングのプロセスも説明されており、軽い気持ちでHoudiniを使うことの楽しさが伝わる内容です​​​​​​​​​​。",
      "en": "This article is about how to enjoy output using Houdini. The author is a freelancer in the video field and also creates CG works as a hobby. The article shows the process of creating Strand-based expressions with light processing, controllable color and animation, and the process of rendering with Redshift and Mantra, which shows how fun it is to use Houdini with a light touch! The video is a fun and lighthearted introduction to using Houdini."
  }
},
{
  "thumbnailUrl": "2020122102.jpg",
  "creationDate": "2020-12-21",
  "author": {
      "name": "@komakinex",
      "twitterIcon": "komakinex.jpg",
      "qiitaUrl": "https://qiita.com/komakinex",
      "twitterUrl": "https://twitter.com/komakinex"
  },
  "title": {
      "ja": "HOULY Daily Challenge2020で作ったものまとめ Day1～Day10",
      "en": "Summary of what you made in the HOULY Daily Challenge 2020 Day1-Day10"
  },
  "articleUrl": "https://qiita.com/komakinex/items/e7dd85329661c1517b46",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122102,
  "summary": {
      "ja": "この記事では、著者がSideFX社のHOULY Daily Challengeに参加した際の作品を紹介しています。Houdini Indie 18.0とMantraを使用し、毎日異なるお題に基づいてビジュアル作品を作成しました。記事では、地球、風、水、火など、様々なテーマに基づいた作品の制作過程が紹介されています。このチャレンジを通じてHoudiniのスキルを向上させたと述べており、個々の作品についての詳細な解説が含まれています​​​​​​​​​​。",
      "en": "In this article, the author shares his work from his participation in SideFX's HOULY Daily Challenge, where he used Houdini Indie 18.0 and Mantra to create visuals based on a different subject each day. The article shows the process of creating pieces based on different themes such as earth, wind, water, and fire. They describe how they improved their Houdini skills through this challenge and include detailed descriptions of their individual creations The article also includes a detailed description of each piece."
  }
},
{
  "thumbnailUrl": "2020122202.jpg",
  "creationDate": "2020-12-22",
  "author": {
      "name": "@shin_t_o_",
      "twitterIcon": "shin_t_o_.jpg",
      "qiitaUrl": "https://qiita.com/shin_t_o_",
      "twitterUrl": "https://twitter.com/shin_t_o_"
  },
  "title": {
      "ja": "VEXでCFDに入門してみる",
      "en": "Getting Started with CFDs on the VEX"
  },
  "articleUrl": "https://qiita.com/shin_t_o_/items/ba5fe7f7bac9a8022db0",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122202,
  "summary": {
      "ja": "この記事では、Houdiniを用いて数値流体力学（CFD）の基礎をVEXで実装するプロセスが紹介されています。主に流体の挙動をシミュレーションするための数学的原理とそのVEXによる実装に焦点を当てています。具体的には、ナビエ・ストークス方程式の簡略化や方程式の離散化について詳しく説明されており、流体シミュレーションのための基本的なアプローチを示しています。ただし、最終的な実装の詳細には触れておらず、基礎的な理論と簡略化されたシミュレーションの概念に注目しています​​​​​​​​​​​​​​​​。",
      "en": "This article presents the process of implementing the fundamentals of Computational Fluid Dynamics (CFD) in VEX using Houdini. It focuses primarily on the mathematical principles for simulating fluid behavior and their implementation in VEX. Specifically, the simplification of the Navier-Stokes equations and the discretization of the equations are described in detail, and a basic approach for fluid simulation is presented.  However, it does not go into the details of the final implementation, focusing instead on the underlying theory and simplified simulation concepts."
  }
},
{
  "thumbnailUrl": "2020122302.jpg",
  "creationDate": "2020-12-23",
  "author": {
      "name": "@okada_takuya",
      "twitterIcon": "okada_takuya.jpg",
      "qiitaUrl": "https://qiita.com/okada_takuya",
      "twitterUrl": "https://twitter.com/okada_takuya"
  },
  "title": {
      "ja": "Houdiniで街のある景観をつくる！",
      "en": "Creating a landscape with a city in Houdini!"
  },
  "articleUrl": "https://qiita.com/okada_takuya/items/ac2e07d5892b418c4cfa",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122302,
  "summary": {
      "ja": "この記事では、Houdiniを使用して街の景観を生成するプロセスが解説されています。地形生成、道路の作成、家の配置、木の配置、地形への色付けなど、街の景観を構築するためのステップが順を追って紹介されています。特に注目すべきは、地形の自動生成、道路の配置、さまざまな家のバリエーションの作成、最終的なシーンの組み合わせと色付けに関する詳細な説明です。記事の終わりには、参考となるHoudiniのファイルへのリンクも提供されています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes the process of generating a cityscape using Houdini. The steps for building a cityscape are presented step-by-step, including generating terrain, creating roads, placing houses, placing trees, and coloring the terrain. Of particular note are the detailed instructions for automatically generating terrain, placing roads, creating different house variations, and combining and coloring the final scene. At the end of the article, links to reference Houdini files are also provided ."
  }
},
{
  "thumbnailUrl": "2020122402.jpg",
  "creationDate": "2020-12-24",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "AMD Radeon ProRender 導入",
      "en": "AMD Radeon ProRender Introduction"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2020/12/amd-prorender.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122402,
  "summary": {
      "ja": "この記事では、AMD Radeon ProRenderのHoudini / Solarisへの導入方法について説明しています。ProRenderはAMD社製の無償GPUレンダラーで、OpenCLで書かれているためNVIDIA GPUでも動作します。ProRenderはGitHubからダウンロードできます。ProRenderの導入にはHoudiniのPackageファイルの設定が必要で、これによりProRenderが正しく認識されるようになります​",
      "en": "This article describes how to install AMD Radeon ProRender into Houdini / Solaris ProRender is a free GPU renderer from AMD that is written in OpenCL and works on NVIDIA GPUs. ProRender can be downloaded from GitHub, and requires a Houdini Package file to be configured so that ProRender is properly recognized."
  }
},
{
  "thumbnailUrl": "2020122502.jpg",
  "creationDate": "2020-12-25",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "KineFX Part2：MotionClipアニメーション入門",
      "en": "KineFX Part 2: Introduction to MotionClip Animation"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/1ba0c8844c4d51b9878e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2020122502,
  "summary": {
      "ja": "この記事では、HoudiniのKineFX機能を用いたMotionClipアニメーションの基本が説明されています。MotionClip機能の基本、利点、さまざまなMotionClip関連ノードの使用方法が解説されています。特に、スケルトンアニメーションのMotionClipへの変換、評価、混合、循環、抽出、挿入、速度調整、連結、更新などの機能に焦点を当てています。この記事は、MotionClipを使用してアニメーションの編集と最適化を行う方法を提供し、KineFXの柔軟性と強力な機能を示しています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article covers the basics of MotionClip animation using Houdini's KineFX feature, explaining the basics of the MotionClip function, its benefits, and how to use the various MotionClip-related nodes. In particular, it focuses on converting skeletal animations to MotionClip, evaluating, mixing, cycling, extracting, inserting, speeding, concatenating, and updating. This article provides a method for editing and optimizing animations using MotionClip and demonstrates the flexibility and powerful features of KineFX  ."
  }
}







,
{
  "thumbnailUrl": "2021120101.jpg",
  "creationDate": "2021-12-01",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "フェイシャルキャプチャ― in Houdini",
      "en": "Facial Capture in Houdini"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/271501cbeea78ee705ab",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120101,
  "summary": {
      "ja": "この記事は、iPhone X Face Motion Captureを用いたTCPでのフェイシャルキャプチャーやUDPでのフェイシャルキャプチャー（zigsimを使用）に関するもので、TCPとUDPの違い、それらの実装方法についても詳述されています。Python Source Editorの使用方法や、Houdini内での複数スレッドの使用例などが記載されており、Houdiniを用いたフェイシャルキャプチャーの技術的な側面が詳細に説明されています​​​​​​​​​​​​​​​​。",
      "en": "This article is about facial capture with iPhone X Face Motion Capture over TCP and facial capture over UDP (using zigsim), detailing the differences between TCP and UDP and how they are implemented. python The technical aspects of facial capture with Houdini are explained in detail, including how to use the Source Editor and examples of using multiple threads within Houdini. The book also includes a detailed description of the technical aspects of facial capture using Houdini."
  }
},
{
  "thumbnailUrl": "2021120201.jpg",
  "creationDate": "2021-12-02",
  "author": {
      "name": "@shop_0761",
      "twitterIcon": "shop_0761.jpg",
      "qiitaUrl": "https://qiita.com/shop_0761",
      "twitterUrl": "https://twitter.com/shop_0761"
  },
  "title": {
      "ja": "SOP~TOPまでのワークフロー的なやつをかきます",
      "en": "Workflow from SOP to TOP"
  },
  "articleUrl": "https://shop-0761.hatenablog.com/entry/2021/12/02/120000",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120201,
  "summary": {
      "ja": "この記事は、Houdiniのワークフローに関する技術的な詳細を提供しています。記事の焦点は、Houdiniの各ステップ（SOP、LOP、COP、TOP）にわたるワークフローの効率化にあり、特にパラメータの変更によるレンダリング結果の比較、COP内でのカラースペースの変換、ffmpegを使用した動画出力などが取り上げられています。また、著者はこのワークフローを構築する過程で直面した課題や解決策についても語っています​​​​​​​​​​​​​​。",
      "en": "This article provides technical details about the Houdini workflow. The focus of the article is on streamlining the workflow across each step of Houdini (SOP, LOP, COP, and TOP), specifically covering the comparison of rendering results by changing parameters, color space conversion within COP, and video output using ffmpeg. The authors also discuss the challenges they faced in the process of building this workflow and the solutions they came up with. The author also discusses the challenges and solutions he faced in the process of building this workflow."
  }
},
{
  "thumbnailUrl": "2021120301.jpg",
  "creationDate": "2021-12-03",
  "author": {
      "name": "@PontaYamazato",
      "twitterIcon": "PontaYamazato.jpg",
      "qiitaUrl": "https://qiita.com/PontaYamazato",
      "twitterUrl": "https://twitter.com/PontaYamazato"
  },
  "title": {
      "ja": "今年のカード",
      "en": "This year's Christmas card"
  },
  "articleUrl": "https://note.com/pontayamazato/n/n9a01614259b6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120301,
  "summary": {
      "ja": "の記事では、著者が作成したクリスマスカードに関する概要と制作過程が述べられています。カードはHoudiniで描かれたイラストを基に、Adobe Illustratorで仕上げられています。絵にはフィンランドの家庭で見られるクリスマス祭壇が描かれており、壁と床、キャンドル、トント人形、ツリー、十字架、花の小物、ガラス球などがデザインされています。技術的な詳細として、Houdiniで開発されたBendアセットや花を開くアニメーションアセット、Celtic Knotを生成するアセットなどが紹介されています。また、フォトンマップ・レンダリングの技術についても言及されています​​。",
      "en": "article outlines and describes the process of creating the Christmas card created by the author. The card is based on an illustration drawn in Houdini and finished in Adobe Illustrator. The picture depicts a Christmas altar found in Finnish homes, with designs for walls and floors, candles, tonto dolls, a tree, crosses, floral accessories, and glass balls. Technical details include Bend assets developed in Houdini, animated assets to open the flowers, and assets to generate the Celtic Knot. Photon map rendering techniques are also discussed."
  }
},
{
  "thumbnailUrl": "2021120401.jpg",
  "creationDate": "2021-12-04",
  "author": {
      "name": "@core_aoi",
      "twitterIcon": "core_aoi.jpg",
      "qiitaUrl": "https://qiita.com/core_aoi",
      "twitterUrl": "https://twitter.com/core_aoi"
  },
  "title": {
      "ja": "実践 Houdini Engine for Unity",
      "en": "Practical Houdini Engine for Unity"
  },
  "articleUrl": "https://note.com/aoi/n/n8fbfd54c349f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120401,
  "summary": {
      "ja": "この記事では、Houdini Engine for Unityを使ってプロシージャルモデリングにより多様なモデルを作成する方法を紹介しています。Unity内で動作するため、モデリングツールとUnityを行き来する必要がありません。実際のゲーム開発での具体的な使用例も「○○したい->実装方法」という形で解説されています。",
      "en": "This article shows how to use Houdini Engine for Unity to create a variety of models through procedural modeling, which works within Unity, so there is no need to switch back and forth between modeling tools and Unity. Specific examples of actual use in game development are also explained in the form of \"I want to do XX->How to implement\"."
  }
},
{
  "thumbnailUrl": "2021120501.jpg",
  "creationDate": "2021-12-05",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "Houdini19 Karma 初見所感・備忘録・Tips",
      "en": "Houdini19 Karma First impressions, memorandum and tips"
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/3c8fc415c4349d9f2c43",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120501,
  "summary": {
      "ja": "Houdini19のKarmaレンダラーの更新に関する所感やTipsを記載しています。この記事では、改善されたUIやパラメータ、レンダリング速度の向上など、Karmaの全体的な評価と使用感を共有しています。また、特にKarmaCPUとKarmaXPUの性能について詳しく述べられています。",
      "en": "This article describes our findings and tips regarding the Karma renderer update for Houdini19. The article shares an overall assessment and feel for Karma, including the improved UI, parameters, and rendering speed. It also details the performance of the KarmaCPU and KarmaXPU in particular."
  }
},
{
  "thumbnailUrl": "2021120601.jpg",
  "creationDate": "2021-12-06",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "複数入力に対しPackするツールを作った話",
      "en": "A story about creating a tool that packs for multiple inputs."
  },
  "articleUrl": "https://kickbase.net/entry/multi_packer",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120601,
  "summary": {
      "ja": "この記事では、複数の入力に対応しストリームごとにPackするHDA「Multi Packer」の作成プロセスを紹介しています。サブネット化、For-Each Numberの利用、ObjectMergeを用いたアクセス方法など、ツールの構築に関する具体的な手順が詳細に説明されています。",
      "en": "This article introduces the process of creating a Multi Packer, an HDA that supports multiple inputs and packs them by stream. It details the specific steps involved in building the tool, including subnetting, using For-Each Number, and how to access it using ObjectMerge."
  }
},
{
  "thumbnailUrl": "2021120701.jpg",
  "creationDate": "2021-12-07",
  "author": {
      "name": "@kurosawa",
      "twitterIcon": "kurosawa.jpg",
      "qiitaUrl": "https://qiita.com/kurosawa",
      "twitterUrl": "https://twitter.com/kurosawa"
  },
  "title": {
      "ja": "Houdini Engine for Unreal Engine ことはじめ",
      "en": "Introduction to Houdini Engine for Unreal Engine"
  },
  "articleUrl": "https://note.com/thesaurus/n/ne761f1c02fb0",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120701,
  "summary": {
      "ja": "この記事では、Houdini Engine for Unreal Engineの無償化により、HoudiniとUnreal Engine間の作業がより効率的になったことを紹介しています。Houdini Engineは、Houdiniを使用しないスタッフでもUnreal Engine上でHoudiniの機能を利用できるようにするプラグインです。洞窟のシーンを例に、自動生成されるメッシュ、エフェクト、ライト配置などの機能を説明しています。HoudiniとUnreal Engineの連携についての重要なポイントと、さまざまなパラメータの説明が含まれています。",
      "en": "This article describes how the free Houdini Engine for Unreal Engine makes working between Houdini and Unreal Engine more efficient. Houdini Engine is a plug-in that allows non-Houdini staff to use Houdini's functionality on the Unreal Engine. Using a cave scene as an example, the presentation explains the features such as auto-generated meshes, effects, light placement, etc. It includes important points about the integration between Houdini and the Unreal Engine and a description of the various parameters."
  }
},
{
  "thumbnailUrl": "2021120801.jpg",
  "creationDate": "2021-12-08",
  "author": {
      "name": "@70_cg_art",
      "twitterIcon": "70_cg_art.jpg",
      "qiitaUrl": "https://qiita.com/70_cg_art",
      "twitterUrl": "https://twitter.com/70_cg_art"
  },
  "title": {
      "ja": "チュートリアルの履修が楽になるフォルダ構成",
      "en": "Folder structure for easier tutorial completion"
  },
  "articleUrl": "https://qiita.com/70_cg_art/items/9248033d1e542499d297",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120801,
  "summary": {
      "ja": "Houdiniのチュートリアルやプロジェクトの管理を効率化するためのフォルダ構成に関する記事です。この記事では、ファイルの保存場所やプロジェクト設定が混乱しやすい問題を解決するために、事前に必要なルールやファイルを作成する方法を提案しています。具体的なフォルダ構成の例として、hipファイル、キャッシュファイル、バッチファイルの管理方法について説明し、Houdiniの起動からシーンの保存、キャッシュの取得方法までを解説しています。",
      "en": "This is an article about folder organization to streamline the management of Houdini tutorials and projects. The article suggests ways to create the necessary rules and files in advance to solve the problem of confusing file storage locations and project settings. As an example of a specific folder structure, the article explains how to manage HIP files, cache files, and batch files, and explains how to start Houdini, save scenes, and retrieve the cache."
  }
},
{
  "thumbnailUrl": "2021120901.jpg",
  "creationDate": "2021-12-09",
  "author": {
      "name": "@daisea3e1203",
      "twitterIcon": "daisea3e1203.jpg",
      "qiitaUrl": "https://qiita.com/daisea3e1203",
      "twitterUrl": "https://twitter.com/daisea3e1203"
  },
  "title": {
      "ja": "Rig PoseノードからHDAへの大量のパラメータ追加を楽に行う",
      "en": "Easily add a large number of parameters from the Rig Pose node to the HDA"
  },
  "articleUrl": "https://qiita.com/daisea3e1203/items/1537bb436987b5fd55eb",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120901,
  "summary": {
      "ja": "この記事は、Kinefxを用いたリグ作成時のRig Poseノードから親HDAへのパラメータ追加を自動化するためのPythonスクリプトに関するものです。特に、パラメータのpromote作業を簡素化するためのスクリプトの作成を目的としています。記事では、ParmTupleやParmTemplateGroupなどのクラスの説明、スクリプトの実装方法、パラメータの追加と参照設定、そして複数のパラメータを同時に追加する方法について詳しく解説しています。また、ロックされているパラメータの取り扱いや、より理解しやすいパラメータ名の付け方についても説明されています。",
      "en": "This article is about a Python script to automate the addition of parameters from the Rig Pose node to the parent HDA when creating a rig using Kinefx. In particular, it aims to create scripts to simplify the task of promoting parameters. The article describes classes such as ParmTuple and ParmTemplateGroup, details how to implement scripts, add and reference parameters, and how to add multiple parameters simultaneously. It also explains how to handle locked parameters and how to name parameters in a more understandable way."
  }
},
{
  "thumbnailUrl": "2021121001.jpg",
  "creationDate": "2021-12-10",
  "author": {
      "name": "@tanitta",
      "twitterIcon": "tanitta.jpg",
      "qiitaUrl": "https://qiita.com/tanitta",
      "twitterUrl": "https://twitter.com/tanitta"
  },
  "title": {
      "ja": "HoudiniでPythonの静的型検査をやってみる",
      "en": "Try Python static type checking in Houdini."
  },
  "articleUrl": "https://tanitta.hatenablog.com/entry/2021/12/10/191729?_ga=2.210698640.442893257.1639126137-730120998.1564028130",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121001,
  "summary": {
      "ja": "この記事では、Houdini 19でPython 3系に更新されたことを受け、静的型検査の方法とその利点について説明しています。静的型検査は、プログラム実行前に型の矛盾を調べるプロセスです。Houdini上でPythonスクリプトの型検査を行うために、Python 3.5から導入されたTypeHintsという仕組みとmypyというツールを使用します。具体的には、Python SOPとHDA定義内のスクリプトに注目し、これらをmypyで検査します。作者はHoudiniで簡単に型検査を行うためのツール、houpytypecheckerを作成し、その導入方法と使用例を紹介しています​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article discusses static type checking and its benefits following the update to the Python 3 series in Houdini 19. Static type checking is the process of checking for type inconsistencies prior to program execution; to perform type checking of Python scripts on Houdini, we use a mechanism called TypeHints, introduced in Python 3.5, and a tool called mypy. Specifically, the author focuses on scripts within Python SOPs and HDA definitions and inspects these with mypy. The author has created a tool for easy type checking in Houdini, houpytypechecker, and shows you how to install and use it The author has created a tool for easy type checking in Houdini."
  }
},
{
  "thumbnailUrl": "2021121101.jpg",
  "creationDate": "2021-12-11",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "今年Houdini関係で登壇して公開した資料まとめ",
      "en": "Summary of materials that I have presented and published this year related to Houdini"
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/1b7284c61ad4b2b461f9",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121101,
  "summary": {
      "ja": "この記事では、著者が2021年に行ったHoudini関連のプレゼンテーションと、その際に使用した資料や動画の概要を紹介しています。具体的な内容としては、Houdiniを使用したNPRエフェクトの作成、UnityでのRealtimeVFXの実践解説、そしてCGWORLD 2021クリエイティブカンファレンスでのVFX Breakdownの紹介が含まれています。これらの資料は業界の活性化と後続の学習者のために公開されており、Houdiniの学習や業務に役立つことが期待されています​​​​​​​​​​。",
      "en": "This article outlines the author's 2021 Houdini-related presentations and the materials and videos used in them. Specific content includes the creation of NPR effects using Houdini, a hands-on explanation of RealtimeVFX in Unity, and a VFX Breakdown at the CGWORLD 2021 Creative Conference. These materials are being made available for the revitalization of the industry and for subsequent learners, and are expected to be useful for learning and working with Houdini! The VFX Breakdown is a comprehensive guide to the Houdini industry and is available for download."
  }
},
{
  "thumbnailUrl": "2021121201.jpg",
  "creationDate": "2021-12-12",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "ComponentBuilderで遊ぼう",
      "en": "Let's play with ComponentBuilder!"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/houdini/solaris/component_builder",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121201,
  "summary": {
      "ja": "Houdini 19に導入されたComponent Builderは、USDアセットの作成過程を簡素化します。アセットとは、モデルやマテリアル、エフェクトなどを指し、USD形式で管理されます。Component Builderを利用すると、USDアセットの構築、マテリアルの追加、ペイロードの構造追加が容易になります。また、マテリアルを分割し、別レイヤーとして出力する機能もあり、バリアントや継承を使用してアセットのバリエーションを効率的に管理できます。",
      "en": "Component Builder, introduced in Houdini 19, simplifies the process of creating USD assets. Assets are models, materials, effects, etc., and are managed in USD format, and Component Builder makes it easy to build USD assets, add materials, and add payload structure. It also provides the ability to split materials and output them as separate layers, and to efficiently manage asset variants using variants and inheritance."
  }
},
{
  "thumbnailUrl": "2021121301.jpg",
  "creationDate": "2021-12-13",
  "author": {
      "name": "@55hertz",
      "twitterIcon": "55hertz.jpg",
      "qiitaUrl": "https://qiita.com/55hertz",
      "twitterUrl": "https://twitter.com/55hertz"
  },
  "title": {
      "ja": "Mixamo to Cascadeur to Houdini（KineFX）モーション",
      "en": "Mixamo to Cascadeur to Houdini (KineFX) motion"
  },
  "articleUrl": "https://qiita.com/55hertz/items/167628f6e4df2683f07f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121301,
  "summary": {
      "ja": "この記事では、AdobeのMixamoから取得したモーションデータをCascadeurで編集し、その後Houdini（KineFX）で使用する一連のプロセスを紹介しています。作者はMixamoで複数のモーションを選び、Cascadeurでこれらを取り込み、必要に応じて調整します。次に、これらのモーションをHoudiniに取り込み、リターゲットを行います。さらに、Rig attrib VOPを使用して注視点や接地などの追加制御を行う方法を説明しています。最後に、単にモーションをつなぐだけでは不自然さが出ることと、実際の動きを観察する重要性を指摘しています​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes a series of processes in which motion data acquired from Adobe's Mixamo is edited in Cascadeur and then used in Houdini (KineFX). The author selects multiple motions in Mixamo, imports these in Cascadeur, and adjusts them as needed. Next, these motions are imported into Houdini and retargeted. In addition, the author explains how to use Rig attrib VOP to provide additional controls such as gazing points and grounding. Finally, he points out that simply connecting motions can be unnatural and the importance of observing the actual motion The following are a few examples of the use of VOPs in the past"
  }
},
{
  "thumbnailUrl": "2021121401.jpg",
  "creationDate": "2021-12-14",
  "author": {
      "name": "@talkyren",
      "twitterIcon": "talkyren.jpg",
      "qiitaUrl": "https://qiita.com/talkyren",
      "twitterUrl": "https://twitter.com/talkyren"
  },
  "title": {
      "ja": "HoudiniのVEXを用いた雪の結晶の生成シミュレーションの一例",
      "en": "An example of snowflake growth simulation using VEX in Houdini"
  },
  "articleUrl": "https://qiita.com/talkyren/items/1b806c8d28fa8cbd2ebe",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121401,
  "summary": {
      "ja": "この記事は、HoudiniのVEXを用いて雪の結晶を生成するシミュレーションの方法について説明しています。作者はCGスタジオでの経験を活かし、実際の論文を参考にしたシミュレーションを紹介しています。シミュレーションでは、正六角柱を基にした生成フィールド、各格子の「結晶分量」「拡散分量」「境界分量」などを計算し、環境パラメータに基づいて雪の結晶が形成されます​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to simulate the generation of snowflakes using VEX in Houdini. The author uses his experience in a CG studio to introduce the simulation, which is based on an actual paper. In the simulation, snow crystals are formed based on environmental parameters by calculating the generating field based on regular hexagonal prisms, the \"crystal fraction,\" \"diffusion fraction,\" and \"boundary fraction\" of each lattice, etc.  The simulation is based on a regular hexagonal prism."
  }
},
{
  "thumbnailUrl": "2021121501.jpg",
  "creationDate": "2021-12-15",
  "author": {
      "name": "@YuriSerizawa",
      "twitterIcon": "YuriSerizawa.jpg",
      "qiitaUrl": "https://qiita.com/YuriSerizawa",
      "twitterUrl": "https://twitter.com/YuriSerizawa"
  },
  "title": {
      "ja": "[UE4]Houdini EngineにEUWを組み合わせてちょっと使いやすくしてみる",
      "en": "[UE4] Combining EUW with Houdini Engine to make it a little easier to use."
  },
  "articleUrl": "https://qiita.com/YuriSerizawa/items/726395ad0968f22a99ef",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121501,
  "summary": {
      "ja": "この記事では、Houdini EngineとEditor Utility Widget(EUW)を組み合わせて、Unreal Engine 4 (UE4)で使いやすくする方法について述べられています。Houdini Asset Descriptor (HDA)をUE4で操作しやすくするため、EUWを利用して初期設定やベイク機能を容易に実行できるツールが紹介されています。この方法では、HoudiniAssetActorのパラメーター操作を最小限に抑え、Houdini Engineのワークフローを効率化できます​​​​​​​​​​​​​​​",
      "en": "This article discusses how the Houdini Engine can be combined with the Editor Utility Widget (EUW) for ease of use in Unreal Engine 4 (UE4). In order to make Houdini Asset Descriptor (HDA) easier to work with in UE4, a tool is introduced to facilitate the initial setup and baking functions using EUW. This method minimizes the manipulation of HoudiniAssetActor parameters and streamlines the Houdini Engine workflow.  "
  }
},
{
  "thumbnailUrl": "2021121601.jpg",
  "creationDate": "2021-12-16",
  "author": {
      "name": "@TF_siri",
      "twitterIcon": "TF_siri.jpg",
      "qiitaUrl": "https://qiita.com/TF_siri",
      "twitterUrl": "https://twitter.com/TF_siri"
  },
  "title": {
      "ja": "水に濡れて張り付いて透ける布",
      "en": "Cloth that sticks and shows through when wet with water"
  },
  "articleUrl": "https://qiita.com/TF_siri/items/e203ecfbcb0a772786a4",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121601,
  "summary": {
      "ja": "この記事は、Houdiniを使用して水に濡れた布が張り付いて透ける現象をシミュレーションする方法について説明しています。Vellum Fluidの作成方法や、アクティブなglueを変更する方法が中心となっています。布と水のシミュレーションを分けて、それぞれのVellum Solverの設定を調整することで、リアルな濡れた布の挙動を再現しています​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article explains how to simulate the phenomenon of wet cloth sticking to water and becoming transparent using Houdini, focusing on how to create Vellum Fluid and modify the active glue. The cloth and water simulations are separated and the Vellum Solver settings for each are adjusted to reproduce realistic wet cloth behavior. ."
  }
},
{
  "thumbnailUrl": "2021121701.jpg",
  "creationDate": "2021-12-17",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "特定の方向からオイラー角を求める",
      "en": "Find the Euler angle from a specific direction"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/55be3f432783fc979b16",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121701,
  "summary": {
      "ja": "この記事では、HoudiniのVEXを用いて特定の方向からオイラー角を求める方法を紹介しています。クォータニオンからオイラー角を返す関数や、ベクトルAをベクトルBに向けるクォータニオンを返す関数などを用い、オイラー角の計算を行っています。さらに、特定のオイラー角と回転順から回転マトリックスを生成するWrangleコードも提供されています",
      "en": "This article shows how to find the Euler angle from a specific direction using Houdini's VEX. Functions that return Euler angles from quaternions and functions that return quaternions that direct vector A to vector B are used to calculate Euler angles. In addition, Wrangle code is provided to generate a rotation matrix from a specific Euler angle and rotation order"
  }
},
{
  "thumbnailUrl": "2021121801.jpg",
  "creationDate": "2021-12-18",
  "author": {
      "name": "@yohanashima",
      "twitterIcon": "yohanashima.jpg",
      "qiitaUrl": "https://qiita.com/yohanashima",
      "twitterUrl": "https://twitter.com/yohanashima"
  },
  "title": {
      "ja": "[記事削除済み] Geometry ShaderをSOPで再現してみる",
      "en": "[Article deleted] Try to reproduce Geometry Shader with SOP"
  },
  "articleUrl": "",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121801,
  "summary": {
      "ja": "この記事では、UnityでのKeijiro神のGeometry Shaderを使用したVFX作品をHoudiniのSOPで再現するプロジェクトが紹介されています。Geometry Shaderは頂点操作に特化したシェーダーで、Houdiniでの再現には三角形、四角形、立方体への変形処理が用いられています。各作例では、変形のサイズや位置、タイミングを細かく制御し、著者はHipファイルも公開しています。このプロジェクトは、Houdiniを活用したGeometry Shaderの可能性を探るものです。",
      "en": "This article presents a project to reproduce in Houdini SOP a VFX work using the Geometry Shader of Keijiro God in Unity.Geometry Shader is a shader specialized for vertex manipulation, and its reproduction in Houdini uses triangle, The Geometry Shader is a shader specialized for vertex manipulation, and is reproduced in Houdini by transforming triangles, rectangles, and cubes. In each example, the size, position, and timing of the deformations are finely controlled, and the author has also published a Hip file. This project explores the potential of Geometry Shader utilizing Houdini."
  }
},
{
  "thumbnailUrl": "2021121901.jpg",
  "creationDate": "2021-12-19",
  "author": {
      "name": "@TrsNium",
      "twitterIcon": "TrsNium.jpg",
      "qiitaUrl": "https://qiita.com/TrsNium",
      "twitterUrl": "https://twitter.com/TrsNium"
  },
  "title": {
      "ja": "HoudiniでWireにディテールを与える",
      "en": "Giving Detail to Wire in Houdini"
  },
  "articleUrl": "https://qiita.com/TrsNium/items/729f57764007e7360e68",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121901,
  "summary": {
      "ja": "Houdiniを使用してWire（線）にディテールを追加する方法について述べられています。具体的には、ボロノイを利用して6角形の模様をWireに付ける方法、Wireの表面に文字を配置する手法、そしてWireから別のWireを生やすプロセスが紹介されています。これらの方法はHoudiniの特定のSOPやUVの利用に基づいています。",
      "en": "It discusses how to add detail to a Wire (line) using Houdini. Specifically, it shows how to use Voronoi to attach a hexagonal pattern to a Wire, how to place text on the surface of a Wire, and the process of growing another Wire from a Wire. These methods are based on the use of specific SOPs and UVs in Houdini."
  }
},
{
  "thumbnailUrl": "2021122001.jpg",
  "creationDate": "2021-12-20",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "ぶっ刺しオブジェクトをブレンドする",
      "en": "Blend stabbing objects"
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2021/12/blog-post.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122001,
  "summary": {
      "ja": "この記事では、オブジェクトのブレンドに関する2つのテクニックが紹介されています。初級編では、シンプルにSphereの法線を円柱に移す方法が示され、中級編では補助ジオメトリをプロシージャルに作成し、それぞれの法線をブレンドする方法が説明されています。この技術は、円柱と球の境界に沿った線の傾きを作成する際に役立ちます。最終的には、RaySopを使用してジオメトリを円柱側と球側にそれぞれ貼り付け、スムーズな接続を実現します。",
      "en": "This article presents two techniques for blending objects. The beginner's section shows how to simply transfer the normals of a Sphere to a cylinder, while the intermediate section explains how to procedurally create auxiliary geometry and blend the normals of each. This technique is useful in creating the slopes of the lines along the boundaries between the cylinder and the sphere. Finally, RaySop is used to attach the geometry to the cylinder and sphere sides, respectively, to create a smooth connection."
  }
},
{
  "thumbnailUrl": "2021122101.jpg",
  "creationDate": "2021-12-21",
  "author": {
      "name": "@yu_nnnnnnnn",
      "twitterIcon": "yu_nnnnnnnn.jpg",
      "qiitaUrl": "https://qiita.com/yu_nnnnnnnn",
      "twitterUrl": "https://twitter.com/yu_nnnnnnnn"
  },
  "title": {
      "ja": "TextureSheetsの解説と検証していきます",
      "en": "TextureSheets will be explained and verified."
  },
  "articleUrl": "https://wakumoku.com/2021/12/19/texture-sheets%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%82%8b/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122101,
  "summary": {
      "ja": "Houdini Labのtexture sheets機能の検証に関する記事です。Texture sheetsとは、連番イメージを一枚の画像に並べたもので、リアルタイムエンジンでのエフェクト作成に使用されます。記事では、Houdiniでのエフェクト素材作成から始まり、labs texture sheetsとmantraノードの作成・設定、出力されたデータの確認と調整の過程を詳述しています。また、mantra以外のレンダラーによるtexture sheetsの可能性も検討されています。",
      "en": "This article examines the texture sheets feature in Houdini Lab, which is used to create effects in real-time engines by arranging sequentially numbered images into a single image. The article details the process of creating effect materials in Houdini, creating and setting up lab texture sheets and mantra nodes, and checking and adjusting the output data. It also discusses the possibility of using texture sheets with renderers other than mantra."
  }
},
{
  "thumbnailUrl": "2021122201.jpg",
  "creationDate": "2021-12-22",
  "author": {
      "name": "@Satsuki-Sensei",
      "twitterIcon": "Satsuki-Sensei.jpg",
      "qiitaUrl": "https://qiita.com/Satsuki-Sensei",
      "twitterUrl": "https://twitter.com/Satsuki-Sensei"
  },
  "title": {
      "ja": "Pixel Wrangleを発見しました",
      "en": "We found Pixel Wrangle!"
  },
  "articleUrl": "https://qiita.com/Satsuki-Sensei/items/29fc51b364e7deee546a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122201,
  "summary": {
      "ja": "この記事では、HoudiniのWrangleノードについて紹介しています。Wrangleは、VEXプログラミング言語を使用して3Dシーンに対する精密な操作を可能にするノードです。記事では、画像操作に特化した「Pixel Wrangle」という概念を探求し、その機能と使用方法を詳細に説明しています。著者は、HoudiniのCOP Network（Compositing Operators Network）を使用し、VOPとSnippetノードを組み合わせることでPixel Wrangleを作成し、画像のピクセル単位の処理を実行する方法を解説しています。",
      "en": "This article introduces the Wrangle node in Houdini, a node that allows precise manipulation of 3D scenes using the VEX programming language. The article explores the concept of the Pixel Wrangle, which is dedicated to image manipulation, and details its capabilities and use. The author explains how to use Houdini's COP Network (Compositing Operators Network) and combine VOP and Snippet nodes to create a Pixel Wrangle to perform pixel-by-pixel processing of images."
  }
},
{
  "thumbnailUrl": "2021122301.jpg",
  "creationDate": "2021-12-23",
  "author": {
      "name": "@taichi-i",
      "twitterIcon": "taichi-i.jpg",
      "qiitaUrl": "https://qiita.com/taichi-i",
      "twitterUrl": "https://twitter.com/taichi-i"
  },
  "title": {
      "ja": "Python State Info Panel について初歩的な確認",
      "en": "Initial review of the Python State Info Panel"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/4411665478041",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122301,
  "summary": {
      "ja": "この記事では、Houdini19のPython state info panelsについて説明しています。この機能は、ユーザーインターフェイスの視認性を向上させることを目的としており、Pythonを使用して作業中のツールのヒントや現在の設定などの情報をビューアに表示することができます。著者は、Houdini内でPython Stateを使って、キーバインドやツールの設定などをビューア上で直接確認できる方法を解説しています。",
      "en": "This article describes the Python state info panels in Houdini19. This feature is intended to improve the visibility of the user interface and allows the viewer to display information such as tips and current settings for the tool you are working with using Python. The author explains how Python State can be used within Houdini to view key bindings, tool settings, etc. directly on the viewer."
  }
},
{
  "thumbnailUrl": "2021122401.jpg",
  "creationDate": "2021-12-24",
  "author": {
      "name": "@ts_bros",
      "twitterIcon": "ts_bros.jpg",
      "qiitaUrl": "https://qiita.com/ts_bros",
      "twitterUrl": "https://twitter.com/ts_bros"
  },
  "title": {
      "ja": "vegetation modeling&tree_rigの紹介",
      "en": "Introduction to vegetation modeling&tree_rig"
  },
  "articleUrl": "https://msjbinc.blogspot.com/2021/12/startup-vegetation-modeling-tree-rig.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122401,
  "summary": {
      "ja": "この記事では、Houdiniを使用した植生モデリングとTreeSimulationに関する技術を紹介しています。著者は、様々な種類の植物（葉っぱ、シダ、ヤシなど）のCGモデリングプロセスについて説明し、各植物の特徴に応じたモデリング手法を探求しています。また、SolarisでのLookdevとMantraを使用したレンダリングについても触れています。記事の最後では、著者が直面した課題と今後のスキルアップのための計画についても言及しています。",
      "en": "This article describes the Python state info panels in Houdini19. This feature is intended to improve the visibility of the user interface and allows the viewer to display information such as tips and current settings for the tool you are working with using Python. The author explains how Python State can be used within Houdini to view key bindings, tool settings, etc. directly on the viewer."
  }
},
{
  "thumbnailUrl": "2021122501.jpg",
  "creationDate": "2021-12-25",
  "author": {
      "name": "@procedural_design",
      "twitterIcon": "procedural_design.jpg",
      "qiitaUrl": "https://qiita.com/procedural_design",
      "twitterUrl": "https://twitter.com/procedural_design"
  },
  "title": {
      "ja": "Procedural Hard Surface ModelingのためのWorley noiseの実装",
      "en": "Implementation of Worley noise for Procedural Hard Surface Modeling."
  },
  "articleUrl": "https://qiita.com/procedural_design/items/d7689f0074c4a9cb5927",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122501,
  "summary": {
      "ja": "この記事では、Houdiniを使用したプロシージャル・ハードサーフェスモデリングにおけるWorley noiseの実装について説明しています。Worley noiseは、空間内のランダムなポイントからの距離を基にしたノイズ関数で、メカニカルな印象を与えるデザインに適しています。著者は、Worley noiseの概念、Houdini内での様々な実装方法、および自作する理由を解説し、面情報の取得とトポロジーの整理についても詳しく説明しています。また、ユークリッド距離やマンハッタン距離など、異なる距離の概念を用いたWorley noiseの応用例も示しています。",
      "en": "This article describes the implementation of Worley noise in procedural hard surface modeling using Houdini.Worley noise is a noise function based on the distance from a random point in space that is used to create mechanical-looking designs that are It is suitable for mechanical-looking designs. The author explains the concept of Worley noise, its various implementations within Houdini and the reasons for creating your own, and goes into detail about obtaining surface information and organizing topology. He also shows examples of Worley noise applications using different distance concepts, such as Euclidean and Manhattan distances."
  }
}






,{
  "thumbnailUrl": "2021120102.jpg",
  "creationDate": "2021-12-01",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "簡単なプロシージャル電柱",
      "en": "Simple Procedural Poles"
  },
  "articleUrl": "https://nullnode.wixsite.com/houdinipsalm/post/houdini-advent-calendar-2021-day-1st",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120102,
  "summary": {
      "ja": "この記事では、Houdiniを使用してプロシージャル電柱を作成する方法について説明されています。電柱の高さや電線の数を変更できるシンプルなネットワークが紹介されており、最優先事項として電線が伸び縮みする機能が強調されています。基本的な手順として、円形のポリゴンを作成し、これを分割して電柱の形にする工程が含まれています。最終的には、電柱同士の距離を調整することで電線の長さを変更できるようになっています​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​。",
      "en": "This article describes how to create procedural utility poles using Houdini. A simple network is presented that allows the height of the poles and the number of wires to be changed, with the ability to stretch and contract the wires highlighted as a top priority. The basic procedure includes the process of creating circular polygons, which are then divided to form poles. Finally, the length of the wires can be changed by adjusting the distance between poles  ."
  }
},
{
  "thumbnailUrl": "2021120202.jpg",
  "creationDate": "2021-12-02",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "InlineUSDの使い方",
      "en": "How to use InlineUSD"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/dcc/Houdini/SOLARIS/inline_usd",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120202,
  "summary": {
      "ja": "InlineUSDは、HoudiniのLOP環境で利用できるノードで、直接USDAsciiを書いてStageを出力する機能を有しています。これにより、USDAscii形式での手書きが可能となり、Houdiniのエクスプレッション関数の埋め込みも行えます。InlineUSDノードにプロパティを追加することで、それらがUSDに反映され、SyntaxErrorの場所を特定しやすくするエラー表示機能も備えています。InlineUSDは、USDAsciiEditorとして、またプロパティの埋め込みテンプレートとして利用できます。",
      "en": "InlineUSD is a node available in Houdini's LOP environment that has the ability to directly write USDAscii and output Stage. By adding properties to the InlineUSD node, they are reflected in the USD, and there is an error display function to help locate SyntaxError. InlineUSD can be used as a USDAsciiEditor and as a template for embedding properties."
  }
},
{
  "thumbnailUrl": "2021120302.jpg",
  "creationDate": "2021-12-03",
  "author": {
      "name": "@kei_iketani",
      "twitterIcon": "kei_iketani.jpg",
      "qiitaUrl": "https://qiita.com/kei_iketani",
      "twitterUrl": "https://twitter.com/kei_iketani"
  },
  "title": {
      "ja": "Houdini ApprenticeからMayaにオブジェクトを読み込む裏ワザ！（修正済み）",
      "en": "Backdoor method to import objects from Houdini Apprentice to Maya! (Fixed)"
  },
  "articleUrl": "https://note.com/johnkparkh13/n/n841b189ac521",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120302,
  "summary": {
      "ja": "この記事では、Houdini ApprenticeからMayaへのオブジェクトの移行方法について説明されています。Houdini Apprenticeは無料で高機能なツールですが、レンダリング解像度の制限やウォーターマークの存在などの不便な点があります。この記事では、Houdiniで作成したオブジェクトをMayaに移す方法として、OBJ Sequences Import/Exportツールの使用が紹介されています。この方法では、OBJ形式でキャッシュを作成し、Mayaでこれをインポートしてアニメーションを再生することができます​​​​​​​​。",
      "en": "This article describes how to transfer objects from Houdini Apprentice to Maya.Houdini Apprentice is a free and powerful tool, but it has some inconveniences such as limited rendering resolution and the presence of watermarks. This article describes the use of the OBJ Sequences Import/Export tool as a way to transfer objects created in Houdini to Maya. This method creates a cache in OBJ format, which can then be imported in Maya to play back the animation The OBJ Sequences Import/Export tool is used to transfer the animation to Maya."
  }
},
{
  "thumbnailUrl": "2021120402.jpg",
  "creationDate": "2021-12-04",
  "author": {
      "name": "@ijiVFX",
      "twitterIcon": "ijiVFX.jpg",
      "qiitaUrl": "https://qiita.com/ijiVFX",
      "twitterUrl": "https://twitter.com/ijiVFX"
  },
  "title": {
      "ja": "爆発で硬い地面がえぐれた様な跡を作るよ",
      "en": "The explosion will leave a mark that looks like the hard ground has been gouged out."
  },
  "articleUrl": "https://qiita.com/ijiVFX/items/66c29070c23a2f99d38b",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120402,
  "summary": {
      "ja": "この記事では、Houdiniを使用して硬い地面に爆発跡を作る方法について説明されています。まず、スフィアをボロノイで分割し、外側を剥がして内側の重複した面を削除します。次に、Circleを使用してひび割れ部分を作成し、FindShortestPathを使用してひびのラインを生成します。その後、ひびの断面を作成し、ヒビ形状を完成させます。最終的には、この地面をゲームエンジンに持っていき、視差マップを使用してリアルな効果を実現します​​​​​​​​​​​​。",
      "en": "This article describes how to create explosion marks on hard ground using Houdini. First, the sphere is divided with Voronoi, then the outside is stripped to remove the inner overlapping surfaces. Next, use Circle to create the cracked area and FindShortestPath to generate the crack line. Then create a cross-section of the crack to complete the crack shape. Finally, take this ground to the game engine and use parallax maps to achieve realistic effects ."
  }
},
{
  "thumbnailUrl": "2021120502.jpg",
  "creationDate": "2021-12-05",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "「枠内」な (バグ) レポートの書き方",
      "en": "How to write an \"in the box\" (bug) report"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2021/12/how-to-write-on-target-bug-report.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120502,
  "summary": {
      "ja": "記事は効果的なバグレポートの作成方法について説明しています。報告しなければ問題は解決されないとのアナロジーを用い、時間をかけずに「枠内」なレポートを書く方法を紹介しています。有効なレポートには、問題の概要、再現手順、補足情報が含まれるべきであるとされています。また、機能改善の要望については、問題を解決しようとしていることとそれを達成する上での障害を明示することが重要です。さらに、Houdiniのデイリービルドを確認し、問題が解決されているかを確認することも勧められています。最後に、送られたレポートが多くの開発者によって見られ、全員がHoudiniのすべての機能に精通しているわけではないことが強調されています​",
      "en": "The article describes how to create an effective bug report. Using the analogy that a problem will not be solved unless it is reported, the article shows how to write an \"in the frame\" report without spending too much time on it. An effective report should include a summary of the problem, steps to reproduce it, and any supplemental information. For feature improvement requests, it is also important to clearly identify the problem you are trying to solve and the obstacles to achieving it. In addition, it is also recommended to check the daily build of Houdini to see if the issue has been resolved. Finally, it is emphasized that the reports sent are seen by many developers and not everyone is familiar with all the features of Houdini!"
  }
},
{
  "thumbnailUrl": "2021120602.jpg",
  "creationDate": "2021-12-06",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "[記事削除済み] LayoutAssetGalleryとLayout",
      "en": "[Article deleted] LayoutAssetGallery and Layout"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/10_Houdini/11_SOLARIS/17_layout_asset_gallery/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120602,
  "summary": {
      "ja": "Houdini 19では、USDアセットの配置（レイアウト）機能が大幅に強化されています。LayoutノードとLayoutAssetGalleryを使用すると、インスタンスの配置が直感的に行えるようになります。まずLayoutノードでPointInstancerノードを作成し、LayoutAssetGalleryからアセットを読み込みます。アセットはDrag＆DropでPointInstancerに登録され、Brushツールを使ってビューポート上に配置できます。配置されたオブジェクトは自動で適切な設置を行います。範囲指定での配置や配置したポイントの削除も可能です。Layout用のアセットの追加はComponentBuilderを使って簡単に行え、最終的にはUSD ROPで出力が可能です。この強化されたレイアウト機能により、非常に扱いやすく強力なレイアウト環境が提供されています。",
      "en": "The placement (layout) of USD assets has been greatly enhanced in Houdini 19, and the Layout node and LayoutAssetGallery allow for intuitive placement of instances. First, create a PointInstancer node in the Layout node and load assets from LayoutAssetGallery. The assets are registered in PointInstancer with Drag&Drop and can be placed on the viewport using the Brush tool. Placed objects are automatically placed appropriately. Adding assets for layout is easy with the ComponentBuilder, and the final output is available in USD ROP. This enhanced layout functionality provides a very easy-to-use and powerful layout environment."
  }
},
{
  "thumbnailUrl": "2021120702.jpg",
  "creationDate": "2021-12-07",
  "author": {
      "name": "@d-gfx",
      "twitterIcon": "d-gfx.jpg",
      "qiitaUrl": "https://qiita.com/d-gfx",
      "twitterUrl": "https://twitter.com/d-gfx"
  },
  "title": {
      "ja": "SDFについて（その１：基礎および可視化方法について）",
      "en": "About SDF (Part 1: Basics and Visualization Methods)"
  },
  "articleUrl": "https://dlanggraphics.blogspot.com/2021/12/houdini-apprentice-advent-calendar-2021-01.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120702,
  "summary": {
      "ja": "この記事は、Houdiniを使用してSDF（Signed Distance Field/Function）について解説する内容です。SDFは境界からの距離を正負の符号で示す関数や場で、Houdiniでの可視化方法が詳述されています。例えば、原点からの距離場や特定の点から広がるDistance Fieldの例が挙げられ、これらはHoudiniを用いた具体的な可視化手法により説明されています。また、SDFの概念を3次元で計算し可視化する方法や、HoudiniにおけるSDFの取り扱いについても触れられています。",
      "en": "This article is about Signed Distance Field/Function (SDF) using Houdini; SDF is a function or field that shows the distance from a boundary with a positive or negative sign and details how to visualize it in Houdini. For example, examples of Distance Fields from the origin and Distance Fields extending from a specific point are given, and these are illustrated with specific visualization methods using Houdini. Also discussed are how to compute and visualize the concept of SDF in 3D and how to handle SDF in Houdini."
  }
},
{
  "thumbnailUrl": "2021120802.jpg",
  "creationDate": "2021-12-08",
  "author": {
      "name": "@d-gfx",
      "twitterIcon": "d-gfx.jpg",
      "qiitaUrl": "https://qiita.com/d-gfx",
      "twitterUrl": "https://twitter.com/d-gfx"
  },
  "title": {
      "ja": "SDFについて（その２：xyzdist の利用）",
      "en": "About SDF (Part 2: Using xyzdist)"
  },
  "articleUrl": "https://dlanggraphics.blogspot.com/2021/12/houdini-apprentice-advent-calendar-2021-02.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120802,
  "summary": {
      "ja": "この記事は、SDF（Signed Distance Field/Function）に関するシリーズの第2部です。ここでは、Houdiniを使用して、関数では表現しにくい複雑なポリゴンメッシュからSDFを作成する方法に焦点を当てています。Houdiniの機能「VDB from Polygons」を使ってSDFを作成する方法が紹介されています。また、記事では「xyzdist」というVEX関数を使用して、ポリゴンメッシュを対象としたSigned Distance Functionを実装する方法を詳しく解説しています。この関数を用いることで、ポイントからジオメトリまでの距離を計算し、SDFを構築することが可能です。さらに、内部と外部を判定するための技術的な説明も含まれており、内積を使用してジオメトリの内外を判断する方法が示されています。",
      "en": "This article is the second part of a series on SDF (Signed Distance Field/Function). The focus here is on how to use Houdini to create SDFs from complex polygon meshes that are difficult to represent with functions; the article shows how to use Houdini's \"VDB from Polygons\" feature to create SDFs. The article also details how to implement a Signed Distance Function for polygon meshes using the \"xyzdist\" VEX function. Using this function, it is possible to calculate the distance from a point to the geometry and construct an SDF. Also included is a technical description of determining inside vs. outside, showing how to use inner products to determine whether geometry is inside or outside."
  }
},
{
  "thumbnailUrl": "2021120902.jpg",
  "creationDate": "2021-12-09",
  "author": {
      "name": "@d-gfx",
      "twitterIcon": "d-gfx.jpg",
      "qiitaUrl": "https://qiita.com/d-gfx",
      "twitterUrl": "https://twitter.com/d-gfx"
  },
  "title": {
      "ja": "SDFについて（その３：応用例）",
      "en": "About SDF (Part 3: Applications)"
  },
  "articleUrl": "https://dlanggraphics.blogspot.com/2021/12/houdini-apprentice-advent-calendar-2021-03.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021120902,
  "summary": {
      "ja": "記事では、SDF（Signed Distance Field/Function）の応用例について説明されています。レイマーチングで使用されるSDFの合成方法（Union、Intersection、Subtraction）が紹介され、滑らかな合成のテクニックも解説されています。実用例として、異なるパーツを組み合わせたメッシュを滑らかにする方法が示され、HoudiniにおけるSDFの不正確性についても言及されています。",
      "en": "The article describes applications of SDF (Signed Distance Field/Function). The SDF synthesis methods used in ray marching (Union, Intersection, Subtraction) are introduced and techniques for smooth synthesis are described. As a practical example, a method for smoothing a mesh of different parts is shown, and the inaccuracies of SDF in Houdini are discussed."
  }
},
{
  "thumbnailUrl": "2021121002.jpg",
  "creationDate": "2021-12-10",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "Match Size を最初のフレームだけ適用",
      "en": "Apply Match Size only to the first frame"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2021/12/match-size-only-on-first-frame.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121002,
  "summary": {
      "ja": "この記事では、Houdiniの「Match Size」ノードの使い方と、特定の問題の解決方法について説明されています。このノードはオブジェクトの位置合わせに便利ですが、スモークシミュレーションなどでバウンディングボックスが変化する場合、毎フレーム移動してしまう問題があります。記事では、最初のフレームだけでオブジェクトを移動させ、その後の再計算を回避する方法を紹介しています。これにより、どんな位置や他のソフトウェアからのデータでも適切に対応できるようになります。",
      "en": "This article describes how to use Houdini's \"Match Size\" node and how to solve certain problems. This node is useful for aligning objects, but has the problem of moving objects every frame when the bounding box changes, such as in a smoke simulation. The article shows how to move the object only in the first frame and avoid subsequent recalculations. This allows for proper handling of data from any position or other software."
  }
},
{
  "thumbnailUrl": "2021121102.jpg",
  "creationDate": "2021-12-11",
  "author": {
      "name": "@Borndigital_Yoshida",
      "twitterIcon": "Borndigital_Yoshida.jpg",
      "qiitaUrl": "https://qiita.com/Borndigital_Yoshida",
      "twitterUrl": "https://twitter.com/Borndigital_Yoshida"
  },
  "title": {
      "ja": "Houdini19で簡単にOCIO（ミニマム設定）を設定する",
      "en": "Easy OCIO (minimum settings) in Houdini19"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/4412128745753",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121102,
  "summary": {
      "ja": "この記事では、Houdini19でOCIOを最小限の設定で簡単にセットアップする方法を紹介しています。SideFX Labsを利用して、Preferencesアイコンをクリックし、OCIO ACES 1.2（Minimal）を有効にする手順を説明しています。設定を適用すると、関連するjsonファイルが生成されます。さらに、PyroレンダリングでのACESカラースペースの利用が推奨されており、OCIOのデフォルトディスプレイとビューを環境変数で設定する方法も解説されています​",
      "en": "This article shows how to easily set up OCIO in Houdini19 with minimal settings, using SideFX Labs, clicking on the Preferences icon and following the steps to enable OCIO ACES 1.2 (Minimal). Once the settings are applied, the associated json file is generated. In addition, it recommends using the ACES color space for Pyro rendering and explains how to set the default display and view for OCIO with environment variables"
  }
},
{
  "thumbnailUrl": "2021121202.jpg",
  "creationDate": "2021-12-12",
  "author": {
      "name": "@kkcg",
      "twitterIcon": "kkcg.jpg",
      "qiitaUrl": "https://qiita.com/kkcg",
      "twitterUrl": "https://twitter.com/kkcg"
  },
  "title": {
      "ja": "ぶら下げたこんにゃくを顔面にぶつける in Houdini",
      "en": "Dangling konnyaku hit in the face in Houdini"
  },
  "articleUrl": "https://kk-cg.net/?p=82",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121202,
  "summary": {
      "ja": "この記事は、Houdiniを使って「糸で吊るしたこんにゃくを顔にぶつける」シミュレーションを作成する過程を詳細に説明しています。こんにゃくの物理的挙動を現実で確認し、そのデータを基にHoudiniでシミュレーションを行う。こんにゃくの大きさと重さを測定し、Houdiniの単位に合わせてモデルを作成。Vellum Tetrahedralを使用してSoft BodyのSimulationを実施し、こんにゃくの挙動を再現。さらに、Vellum Constraintsを用いて、こんにゃくを糸で吊るし、最終的なシミュレーションを完成させるプロセスが説明されています。",
      "en": "This article details the process of using Houdini to create a \"konjac hanging by a string and hitting you in the face\" simulation. The physical behavior of the konjac is confirmed in reality, and the data is used to create a simulation in Houdini. The size and weight of the konjac is measured and a model is created to match the Houdini units; a Soft Body Simulation is performed using Vellum Tetrahedral to reproduce the konjac's behavior. The article then describes the process of using Vellum Constraints to hang the konjac by a string to complete the final simulation."
  }
},
{
  "thumbnailUrl": "2021121302.jpg",
  "creationDate": "2021-12-13",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "ナイトライフにちなむ布地をプレゼントします",
      "en": "We present fabrics associated with nightlife."
  },
  "articleUrl": "https://qiita.com/Alidade/items/72bccf2bba38e017d33c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121302,
  "summary": {
      "ja": "この記事では、Houdiniを使用して作成された、冬の季節にふさわしいパーティドレス用の布地について紹介されています。作者はこの布地をHDA形式で配布しており、キャラクターの衣装や画面の密度を高める効果に使用できると説明しています。また、Vellumソルバーを使った指針としても利用できると述べています​​。",
      "en": "This article describes a fabric created using Houdini for a party dress appropriate for the winter season. The author distributes this fabric in HDA format and explains that it can be used for character costumes and screen density effects. He also states that it can be used as a guideline using the Vellum solver."
  }
},
{
  "thumbnailUrl": "2021121402.jpg",
  "creationDate": "2021-12-14",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "MaterialXで遊ぶ",
      "en": "Playing with MaterialX"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/d4459493248b147f4ea6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121402,
  "summary": {
      "ja": "Houdini 19.0からMaterialXへの対応が始まり、この記事ではMaterialXの基本的な使い方やシェーダーグラフのビューイング、OSL/MDL/GLSLへの変換方法が解説されています。また、MaterialXの公式サイトのリンクや、MaterialXファイルをSolarisでインポートする方法、Pythonを使用したMaterialXスクリプトの基本的なコード例が提供されています​​​​​​​​​​。",
      "en": "Houdini 19.0 began supporting MaterialX, and this article explains basic MaterialX usage, shader graph viewing, and OSL/MDL/GLSL conversion methods. It also provides links to the official MaterialX website, how to import MaterialX files in Solaris, and basic code examples of MaterialX scripts using Python The following is a brief overview of the MaterialX scripting process."
  }
},
{
  "thumbnailUrl": "2021121502.jpg",
  "creationDate": "2021-12-15",
  "author": {
      "name": "@Borndigital_Yoshida",
      "twitterIcon": "Borndigital_Yoshida.jpg",
      "qiitaUrl": "https://qiita.com/Borndigital_Yoshida",
      "twitterUrl": "https://twitter.com/Borndigital_Yoshida"
  },
  "title": {
      "ja": "Houdini19のビューポートでPyroのMotionVectorやNormalを確認する",
      "en": "Check Pyro's MotionVector and Normal in the Houdini19 viewport."
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/4412125577369",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121502,
  "summary": {
      "ja": "Houdini 19でのビューポートの改善についての記事です。特に、モーションベクトルとNORMALをビューポートで直接表示する方法が紹介されています。これにより、以前はMantraでのレンダリングが必要だった確認作業が、ビューポート内でインタラクティブに行えるようになりました。さらに、Flipbookテクスチャシートの作成方法についても説明されています​​​​​​​​。",
      "en": "This article is about the viewport improvements in Houdini 19. In particular, it shows how motion vectors and NORMAL can be displayed directly in the viewport. This allows for confirmation tasks that previously required rendering in Mantra to be done interactively in the viewport. In addition, it explains how to create a Flipbook texture sheet The Flipbook Texture Sheets are available for use in the Mantra viewport."
  }
},
{
  "thumbnailUrl": "2021121602.jpg",
  "creationDate": "2021-12-16",
  "author": {
      "name": "@okada_takuya",
      "twitterIcon": "okada_takuya.jpg",
      "qiitaUrl": "https://qiita.com/okada_takuya",
      "twitterUrl": "https://twitter.com/okada_takuya"
  },
  "title": {
      "ja": "Houdini 19.0 版 バリエーションコピー　~Merge Packedの使用~",
      "en": "Houdini 19.0 version Variant Copy ~Using Merge Packed"
  },
  "articleUrl": "https://qiita.com/okada_takuya/items/aca23e14209d4cedd574",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121602,
  "summary": {
      "ja": "Houdini 19.0で導入された新しいMergeノード、Merge Packedの使用方法について説明しています。これにより、以前のバージョンで必要だった複数の工程を単一のノードで実行できるようになりました。記事では、Merge Packedノードの特徴や設定方法、そして従来のバリエーションコピーの方法についてのおさらいも含まれています​​​​​​。",
      "en": "Learn how to use Merge Packed, the new Merge node introduced in Houdini 19.0. This allows multiple processes that were required in previous versions to be performed in a single node. The article also includes a review of the Merge Packed node's features, how to set it up, and how to copy the traditional variations ."
  }
},
{
  "thumbnailUrl": "2021121702.jpg",
  "creationDate": "2021-12-17",
  "author": {
      "name": "@shige_ktgw",
      "twitterIcon": "shige_ktgw.jpg",
      "qiitaUrl": "https://qiita.com/shige_ktgw",
      "twitterUrl": "https://twitter.com/shige_ktgw"
  },
  "title": {
      "ja": "VOPを使ってVolume Deform",
      "en": "Volume Deform with VOP"
  },
  "articleUrl": "http://nomoreretake.net/2021/12/17/houdinivop_volume-deformer/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121702,
  "summary": {
      "ja": "この記事は、HoudiniのVolume Deform機能に関する解説です。Houdiniバージョン19に追加されたVolume Deformer(SOP)を使わず、VOP（Volume Operator）を用いたボリュームの捻じ曲げ方法を紹介しています。著者は、Volume Sample(VOP)を用いた手法を示し、煙のシンプルな例を通じてそのプロセスを説明しています。ネットワークの構成とVolumeVOP内の処理手順について詳しく述べ、ボクセルの位置情報を変更して煙を捻じる方法を説明しています。さらに、VDB Active(SOP)を使ってVolumeの領域を広げる重要性にも触れ、他の変形方法やHoudini19のVolume Deform(SOP)の便利さも言及しています。記事は、Houdiniの知識が進化する中で古くなる可能性があるが、何らかの形で役立つことを願って締めくくられています。",
      "en": "This article is a commentary on Houdini's Volume Deform feature, showing how to twist volumes using the Volume Operator (VOP) instead of the Volume Deformer (SOP), which was added to Houdini version 19. The author demonstrates the method using Volume Sample (VOP) and explains the process through a simple example of smoke. The configuration of the network and the processing steps within the volumeVOP are described in detail, explaining how to twist the smoke by changing the voxel location information. It also touches on the importance of using VDB Active (SOP) to extend the area of the volume, and mentions other deformation methods and the usefulness of Volume Deform (SOP) in Houdini19. The article concludes with the hope that it will be useful in some way, although it may become outdated as Houdini knowledge evolves."
  }
},
{
  "thumbnailUrl": "2021121802.jpg",
  "creationDate": "2021-12-18",
  "author": {
      "name": "@indyzone",
      "twitterIcon": "indyzone.jpg",
      "qiitaUrl": "https://qiita.com/indyzone",
      "twitterUrl": "https://twitter.com/indyzone"
  },
  "title": {
      "ja": "Gas Project Non Divergentについて",
      "en": "About Gas Project Non Divergent"
  },
  "articleUrl": "https://houdinifx.jp/blog/gas-project-non-divergent%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6/",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121802,
  "summary": {
      "ja": "この記事では、Houdiniでの煙や水などの流体シミュレーションにおける発散(Divergence)の制御に用いる「Gas Project Non Divergent DOPノード」について説明しています。流体計算では「流入量 – 流出量 = 0」という質量保存則に従い、これを「Divergence-Free(発散なし)」状態と呼びます。このノードは流体の挙動を制御するVelocity Fieldに渦を生成するために重要です。関連する他のノードとして「Gas Project Non Divergent Adaptive DOP」、「Gas Project Non Divergent Multigrid DOP」、「Gas Project Non Divergent Variational DOP」があります。また、Pyro Solver SOPノードやSmoke Solver SOPノードなどにはこのノードが組み込まれています​​​​​​​​​​。",
      "en": "This article describes the Gas Project Non Divergent DOP node, which is used to control divergence in fluid simulations such as smoke and water in Houdini. In fluid calculations, the law of conservation of mass is \"inflow - outflow = 0,\" and this is called the \"Divergence-Free\" state. This node is important for creating vortices in the Velocity Field that control the behavior of the fluid. Other related nodes are \"Gas Project Non Divergent Adaptive DOP\", \"Gas Project Non Divergent Multigrid DOP\" and \"Gas Project Non Divergent Variational DOP\". This node is also incorporated in the Pyro Solver SOP node, Smoke Solver SOP node, etc. The Pyro Solver SOP node and the Smoke Solver SOP node are also embedded."
  }
},
{
  "thumbnailUrl": "2021121902.jpg",
  "creationDate": "2021-12-19",
  "author": {
      "name": "@bechica",
      "twitterIcon": "bechica.jpg",
      "qiitaUrl": "https://qiita.com/bechica",
      "twitterUrl": "https://twitter.com/bechica"
  },
  "title": {
      "ja": "これから Houdini を始めるあなたへ",
      "en": "Getting Started with Houdini"
  },
  "articleUrl": "https://qiita.com/bechica/items/62dda8ddd99db482bee1",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021121902,
  "summary": {
      "ja": "この記事は、初心者向けにHoudiniを学ぶための講座資料をまとめたものです。記事の内容は講座の序盤部分を中心に構成されており、最小単位の作例を通して頻出する機能を詳しく解説しています。内容は、環境構築、画面構成・基本操作、RBD、VEX、VOP、そして非公開部分としてVDB、Vellum、Pyro、FLIP、POP、Height Fieldに関するテーマが含まれています​​​​。",
      "en": "This article is a compilation of course material for beginners to learn Houdini. The content of the article is organized around the early part of the course and explains frequently used functions in detail through the smallest of examples. Topics include environment setup, screen structure and basic operations, RBD, VEX, VOP, and a private section on VDB, Vellum, Pyro, FLIP, POP, and Height Field. The program is open to the public."
  }
},
{
  "thumbnailUrl": "2021122002.jpg",
  "creationDate": "2021-12-20",
  "author": {
      "name": "@ryuji_shirai",
      "twitterIcon": "ryuji_shirai.jpg",
      "qiitaUrl": "https://qiita.com/ryuji_shirai",
      "twitterUrl": "https://twitter.com/ryuji_shirai"
  },
  "title": {
      "ja": "MatrixのアレをHoudiniで作ってみた",
      "en": "I made the Matrix thing in Houdini."
  },
  "articleUrl": "https://qiita.com/ryuji_shirai/items/9ee0f26968bdef66ea22",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122002,
  "summary": {
      "ja": "この記事では、Houdiniを使用して、映画「Matrix」に触発されたアニメーションの作成方法について説明しています。重要なポイントとして、エクセルからインポートした寿司ネタのリストを使い、異なる文字を各ポイントに貼り付け、アルファを使って表現する手法を紹介しています。また、ランダムにコードの内容が変化するアニメーションや、グラデーションのように流れるコードの作成方法も詳しく解説しています​​​​​​​​​​。",
      "en": "This article describes how to use Houdini to create an animation inspired by the movie Matrix. As an important point, it introduces the technique of using a list of sushi items imported from Excel, pasting different characters to each point, and using alpha to represent them. It also details how to create animations that randomly change the content of the code and how to create code that flows like a gradient! The book also includes a section on how to create a code that flows like a gradient."
  }
},
{
  "thumbnailUrl": "2021122102.jpg",
  "creationDate": "2021-12-21",
  "author": {
      "name": "@Bosshi",
      "twitterIcon": "Bosshi.jpg",
      "qiitaUrl": "https://qiita.com/Bosshi",
      "twitterUrl": "https://twitter.com/Bosshi"
  },
  "title": {
      "ja": "Houdiniでバリエーション作成！",
      "en": "Creating variations in Houdini!"
  },
  "articleUrl": "https://qiita.com/Bosshi/items/08f1d62024fa39bd319f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122102,
  "summary": {
      "ja": "この記事では、Houdiniで「Takeを使ったバリエーション作成」について説明しています。Takeを使用することで、異なるパラメータを持つ複数のシーンを作成し、瞬時に切り替えることが可能です。具体的な方法として、新しいシーン(Take)を作成し、パラメータを変更する手順が紹介されています。これにより、複数の異なる見た目のシーンを一つのhipファイル内で管理できます​​​​​​​​。",
      "en": "This article discusses \"Creating Variations with Take\" in Houdini; Take allows you to create multiple scenes with different parameters and switch between them instantly. In concrete terms, the procedure for creating a new scene (Take) and changing its parameters is presented. This allows you to manage multiple different looking scenes within a single hip file! The HIP file is a file that contains a list of all the different scenes that can be created."
  }
},
{
  "thumbnailUrl": "2021122202.jpg",
  "creationDate": "2021-12-22",
  "author": {
      "name": "@shin_t_o_",
      "twitterIcon": "shin_t_o_.jpg",
      "qiitaUrl": "https://qiita.com/shin_t_o_",
      "twitterUrl": "https://twitter.com/shin_t_o_"
  },
  "title": {
      "ja": "Houdiniのattributeをデータベースにして都市データを扱ってみる(1. 実装編)",
      "en": "Try to handle city data by using Houdini's attribute as a database (1. Implementation)"
  },
  "articleUrl": "https://qiita.com/shin_t_o_/items/c10341115efb3f35cdb0",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122202,
  "summary": {
      "ja": "この記事は、Mapbox経由で読み込んだマップデータをHoudiniのattributeとして使用し、建物名や最短経路検索などを実装するテストについて説明しています。また、Google Maps PlatformのPlaces APIを使い、緯度経度情報をベースにしてスポット情報を検索し、Mapboxデータと連携しています。このプロジェクトは、3Dデータとビジュアライゼーションに焦点を当てた長期的な趣味プロジェクトの一環として位置づけられています​​​​​​​​​​。",
      "en": "This article describes a test that uses map data loaded via Mapbox as an attribute in Houdini to implement building names and shortest path searches. It also uses the Places API of Google Maps Platform to search for spot information based on latitude and longitude information and link it to Mapbox data. This project is part of a long-term hobby project focused on 3D data and visualization The project is part of a long-term hobby project focused on 3D data and visualization."
  }
},
{
  "thumbnailUrl": "2021122302.jpg",
  "creationDate": "2021-12-23",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "Event Scriptを利用してWrangleのRun Overを表示する",
      "en": "Display Wrangle's Run Over using Event Script"
  },
  "articleUrl": "https://kickbase.net/entry/houdini_event_script",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122302,
  "summary": {
      "ja": "この記事では、HoudiniのEvent Script機能を利用して、Wrangleの対象（Run Over）をネットワークエディタ上で表示する方法について紹介しています。この機能を使うと、特定のノードが作成されたときに自動的にスクリプトが実行され、Run Overの対象をユーザーデータとしてセットします。この方法は、Houdini全体で使えるPythonスクリプトに基づいています​​​​​​​​​​。",
      "en": "This article shows how to use Houdini's Event Script feature to display the target of a Wrangle (Run Over) in the Network Editor. Using this feature, a script is automatically executed when a particular node is created, setting the Run Over target as user data. This method is based on a Python script that can be used throughout Houdini Run Over."
  }
},
{
  "thumbnailUrl": "2021122402.jpg",
  "creationDate": "2021-12-24",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "なぜ USD を使うのか? なぜ Solaris を使うのか?",
      "en": "Why Use USD? Why Solaris?"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2021/12/why-use-usd-why-use-solaris.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122402,
  "summary": {
      "ja": "このブログ記事では、Universal Scene Description (USD)とSolarisの使用理由について解説しています。USDは3Dシーンを汎用的に定義するファイルフォーマットで、効率的なパイプライン、直接レンダリング、軽量性、強力なインスタンシングなどの利点があります。SolarisはレイアウトとライティングのためのネイティブUSD環境で、変換ロスがなく、USD演算子で操作できることが特徴です​​​​​​。",
      "en": "This blog post explains why we use Universal Scene Description (USD) and Solaris. USD is a file format that defines a 3D scene in a generic way and offers advantages such as efficient pipelining, direct rendering, light weight, and powerful instancing. Solaris is the native USD environment for layout and lighting, with no conversion loss and the ability to operate with USD operators. Solaris is a native USD environment for layout and lighting, with no conversion losses and the ability to operate with USD operators."
  }
},
{
  "thumbnailUrl": "2021122502.jpg",
  "creationDate": "2021-12-25",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "TouchDesignerからHoudiniへKinectの情報を持っていきたい",
      "en": "I want to bring Kinect information from TouchDesigner to Houdini."
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/3cbb20131a3cf490bda7",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2021122502,
  "summary": {
      "ja": "この記事では、TouchDesignerを通じてKinectの情報をHoudiniに転送する方法について説明しています。著者は、フェイシャルやモーションキャプチャの技術を調査している中で、このアイデアを思いつきました。ただし、Houdiniでモーションキャプチャを扱う一般的な方法と比較して、この手法は必ずしも簡単ではないとしています。記事は、実際のデータ接続プロセスと、その際に遭遇した問題についても触れています​​​​​​​​​​​​。",
      "en": "This article describes how to transfer Kinect information to Houdini through TouchDesigner. The author came up with this idea while researching facial and motion capture techniques. However, he states that this method is not necessarily easier than the common way of handling motion capture in Houdini. The article also discusses the actual data connection process and the problems encountered ."
  }
}







,
{
  "thumbnailUrl": "2022120101.jpg",
  "creationDate": "2022-12-01",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "Houdini x Unity : VAT関連Tips & 備忘録",
      "en": "Houdini x Unity : VAT Tips & Memorandum"
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/4469ec6ccce3c53f4d37",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120101,
  "summary": {
      "ja": "この記事は、Houdini x UnityでのVertex Animation Textures（VAT）関連のTipsと備忘録を提供します。UnityでのVATの使用が増えている中、安定性に関する検証を行い、得られた知見を共有しています。特に、VAT3.0は安定動作しなかったため、VAT2.1の使用が推奨されています。Houdini19.5とSideFXLabsのバージョンを18.5.462にすることで最も安定するとされています​​​​​。",
      "en": "This article provides Vertex Animation Textures (VAT) related tips and memorandum in Houdini x Unity.With the increasing use of VAT in Unity, we have tested the stability and share our findings. In particular, the use of VAT 2.1 is recommended, as VAT 3.0 did not work stably; Houdini 19.5 and SideFXLabs version 18.5.462 are considered most stable The most stable version is Houdini 19.5 and SideFXLabs 18.5.462."
  }
},
{
  "thumbnailUrl": "2022120201.jpg",
  "creationDate": "2022-12-02",
  "author": {
      "name": "@PontaYamazato",
      "twitterIcon": "PontaYamazato.jpg",
      "qiitaUrl": "https://qiita.com/PontaYamazato",
      "twitterUrl": "https://twitter.com/PontaYamazato"
  },
  "title": {
      "ja": "「音の絵」について",
      "en": "About Sound Pictures"
  },
  "articleUrl": "https://note.com/pontayamazato/n/ncfe782b60d62",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120201,
  "summary": {
      "ja": "この記事では、作者がアニメーション制作で用いる「音の絵」という手法について紹介しています。「音の絵」とは、音楽をアニメーションの駆動力として利用する手法で、具体的にはMidi In CHOP Nodeを使い、標準Midiファイルのデータを利用します。これにより、音楽とアニメーションを一致させることが可能になります​​​​​​",
      "en": "This article introduces the \"sound picture\" technique that the author uses in animation production. The \"sound picture\" method uses music as the driving force for animation, specifically using Midi In CHOP Node and data from standard Midi files. This makes it possible to match music and animation"
  }
},
{
  "thumbnailUrl": "2022120301.jpg",
  "creationDate": "2022-12-03",
  "author": {
      "name": "@sasaki_0222",
      "twitterIcon": "sasaki_0222.jpg",
      "qiitaUrl": "https://qiita.com/sasaki_0222",
      "twitterUrl": "https://twitter.com/sasaki_0222"
  },
  "title": {
      "ja": "Multi-directional Contribution Maps の書き出し設定について",
      "en": "Export settings for Multi-directional Contribution Maps"
  },
  "articleUrl": "https://qiita.com/sasaki_0222/items/96ee2df29f0abc8f05d3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120301,
  "summary": {
      "ja": "この記事はMulti-directional Contribution (MDC) Mapsの書き出し設定に関するTipsや備忘録を提供します。MDC MapsはHoudiniHIVE 2021で紹介された手法で、ライティング情報をダイナミックに計算することができます。しかし、実装から1年近く経っても情報が少なく、本記事は基礎資料としての役割を果たすことを目指しています​​​​​​​​。",
      "en": "This article provides tips and memorandums on setting up Multi-directional Contribution (MDC) Maps export.MDC Maps is a method introduced in HoudiniHIVE 2021 that allows dynamic computation of lighting information. However, there is little information available almost a year after its implementation, and this article aims to serve as a basic resource! ."
  }
},
{
  "thumbnailUrl": "2022120401.jpg",
  "creationDate": "2022-12-04",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "HDK: Houdini Development Kit入門",
      "en": "HDK: Introduction to Houdini Development Kit"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/14cb1804ba426d7b287f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120401,
  "summary": {
      "ja": "HDK（Houdini Development Kit）は、Houdiniのさまざまな領域をカスタマイズするためのC++ライブラリの集合です。この記事では、HDKの使い方や、Houdiniをインストールした際に含まれるHDKのコンポーネント、Visual Studioの必要性、そして初心者向けのHDKプログラムの作成方法について説明しています",
      "en": "The HDK (Houdini Development Kit) is a set of C++ libraries for customizing various areas of Houdini. This article explains how to use the HDK, the HDK components included when you install Houdini, the need for Visual Studio, and how to create an HDK program for beginners! "
  }
},
{
  "thumbnailUrl": "2022120501.jpg",
  "creationDate": "2022-12-05",
  "author": {
      "name": "@takavfx",
      "twitterIcon": "takavfx.jpg",
      "qiitaUrl": "https://qiita.com/takavfx",
      "twitterUrl": "https://twitter.com/takavfx"
  },
  "title": {
      "ja": "Houdini を Python 3 でやる!!! Part.2",
      "en": "Houdini with Python 3! Part.2"
  },
  "articleUrl": "https://qiita.com/takavfx/items/13e1059408d9ecf06a34",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120501,
  "summary": {
      "ja": "この記事は、HoudiniのPython 3対応の経緯と将来予測について説明しています。Houdiniはバージョン18.5からPython 3を標準で採用し、特に問題なく使えるようになりました。Python 3の便利な機能、特にPathlibとEnum、YamlとDataclassを使ったHoudiniノードの生成について具体的な例とともに解説しています​​​​​​​​​​​​。",
      "en": "This article describes the history of Houdini's Python 3 support and future projections. Dataclass, with concrete examples. The book is available in English, French, German, Italian, French, Spanish, Italian and Japanese. "
  }
},
{
  "thumbnailUrl": "2022120601.jpg",
  "creationDate": "2022-12-06",
  "author": {
      "name": "@sugiggy",
      "twitterIcon": "sugiggy.jpg",
      "qiitaUrl": "https://qiita.com/sugiggy",
      "twitterUrl": "https://twitter.com/sugiggy"
  },
  "title": {
      "ja": "ダイナミックオプティマイズサブディビジョン(長っ)",
      "en": "Dynamic Optimization Subdivision"
  },
  "articleUrl": "https://sugi-iggy.blogspot.com/2022/12/blog-post.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120601,
  "summary": {
      "ja": "この記事では、別のジオメトリからの距離に応じてサブディビジョンの細かさをコントロールする技術が紹介されています。この方法は、破壊される部分にディテールを持たせたいエフェクト制作時に特に役立ちます。簡素なネットワークを使い、グリッドのプリミティブにラインからの距離に応じたアトリビュートを持たせ、Subdivideの回数を設定します。この技術により、データの最適化を図り、後工程への影響を軽減できます。",
      "en": "This article introduces a technique for controlling the fineness of subdivisions according to their distance from another geometry. This method is especially useful when creating effects where you want to have detail in the areas to be destroyed. Using a simple network, the number of Subdivide times is set by having the grid primitives have attributes based on their distance from the line. This technique optimizes the data and reduces the impact on post-processing."
  }
},
{
  "thumbnailUrl": "2022120701.jpg",
  "creationDate": "2022-12-07",
  "author": {
      "name": "@70_cg_art",
      "twitterIcon": "70_cg_art.jpg",
      "qiitaUrl": "https://qiita.com/70_cg_art",
      "twitterUrl": "https://twitter.com/70_cg_art"
  },
  "title": {
      "ja": "Edge Slideを作る【モデリングツール】",
      "en": "Create Edge Slide [Modeling Tool]."
  },
  "articleUrl": "https://qiita.com/70_cg_art/items/86343868180afa0b942a",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120701,
  "summary": {
      "ja": "この記事は、HoudiniでBlenderやMayaのEdge Slideのような機能を実装するためのプロセスを紹介しています。著者は最初にRayノードとEdit Sopを試したものの、望んだ結果が得られなかったため、自分でノードを作成することにしました。そのプロセスには、交差するエッジを見つける、エッジに沿ってポイントをスライドさせるなどが含まれています。最終的には、自作のノードを使用してEdge Slideを実現し、問題点を洗い出し、解決策を探求しました",
      "en": "This article presents a process for implementing features like Edge Slide in Blender and Maya in Houdini. The author first tried a Ray node and Edit Sop but did not get the desired results, so he decided to create his own node. The process included finding intersecting edges, sliding points along edges, etc. In the end, I used the homemade node to achieve Edge Slide, identify the problem, and explore solutions!"
  }
},
{
  "thumbnailUrl": "2022120801.jpg",
  "creationDate": "2022-12-08",
  "author": {
      "name": "@shop_0761",
      "twitterIcon": "shop_0761.jpg",
      "qiitaUrl": "https://qiita.com/shop_0761",
      "twitterUrl": "https://twitter.com/shop_0761"
  },
  "title": {
      "ja": "[Houdini] 気合でリボンを結ぶ [Vellum Brush]",
      "en": "[Houdini] Tie a ribbon with spirit [Vellum Brush]."
  },
  "articleUrl": "https://shop-0761.hatenablog.com/entry/2022/12/08/120000",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120801,
  "summary": {
      "ja": "この記事は、Vellum Brushを使用してリボンを結ぶ方法について説明しています。まず、実際のリボン結びを行い、その手順をHoudiniで再現します。Vellum Brushのセットアップが完了すると、SceneViewで編集が可能になります。シミュレーションとVellum Post Processを使用してリボンを完成させます。記事では、Houdiniとグラフィックスカードのドライバーの相性問題や、pinされている部分の確認、貫通を避ける方法なども触れられています",
      "en": "This article describes how to tie a ribbon using the Vellum Brush. First, we will tie an actual ribbon knot and recreate the procedure in Houdini; once the Vellum Brush is set up, it will be available for editing in the SceneView. Simulation and the Vellum Post Process are used to complete the ribbon. The article also discusses compatibility issues between Houdini and graphics card drivers, checking for pinned areas, and how to avoid penetration!"
  }
},
{
  "thumbnailUrl": "2022120901.jpg",
  "creationDate": "2022-12-09",
  "author": {
      "name": "@Borndigital_Yoshida",
      "twitterIcon": "Borndigital_Yoshida.jpg",
      "qiitaUrl": "https://qiita.com/Borndigital_Yoshida",
      "twitterUrl": "https://twitter.com/Borndigital_Yoshida"
  },
  "title": {
      "ja": "SolarisでMaterialXファイルを保存して、再利用する",
      "en": "Save and reuse MaterialX files in Solaris"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/13156119863705",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120901,
  "summary": {
      "ja": "この記事は、Houdiniに搭載されたSolarisでLookdevを行うコンテキストについて紹介しています。SolarisはUSDで動作し、取り込まれたものはすべてUSDになります。ジオメトリとマテリアルをUSDアセットとして管理する際には、MaterialXが有用です。MaterialXはオープンソースで、様々なRendererで使用できます。記事では、MaterialXノードの利用、保存方法、再利用のプロセスについて説明しています",
      "en": "This article introduces the context of lookdev with Solaris in Houdini; Solaris runs in USD and everything imported is in USD. MaterialX is useful for managing geometry and materials as USD assets; MaterialX is open source and can be used with a variety of Renderers. The article describes the process of using, saving, and reusing MaterialX nodes"
  }
},
{
  "thumbnailUrl": "2022121001.jpg",
  "creationDate": "2022-12-10",
  "author": {
      "name": "@_yaitasakana",
      "twitterIcon": "_yaitasakana.jpg",
      "qiitaUrl": "https://qiita.com/_yaitasakana",
      "twitterUrl": "https://twitter.com/_yaitasakana"
  },
  "title": {
      "ja": "HoduiniのjobをDeadlineに投げてみるお話",
      "en": "A story about throwing Hoduini's job to Deadline"
  },
  "articleUrl": "https://qiita.com/_yaitasakana/items/bc4aefe9d68ccd54b0a9",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121001,
  "summary": {
      "ja": "この記事は、HoudiniのジョブをDeadlineに投げる方法について述べています。Deadlineを使用することで、レンダリングサーバーを増やすことが可能です。記事では、Deadlineのインストール、設定、およびHoudiniでの使用方法について説明しています。Deadline RepositoryとClientのインストール、Houdini用のサブミッションプラグインのインストール、Deadline MonitorでのHoudini設定の追加などが詳述されています",
      "en": "This article discusses how to pitch Houdini jobs to Deadline; using Deadline allows you to increase the number of render servers. The article describes how to install, configure, and use Deadline with Houdini, including installing the Deadline Repository and Client, installing the Submission plugin for Houdini, and using the Deadline Monitor to Adding Houdini settings in Deadline Monitor is detailed."
  }
},
{
  "thumbnailUrl": "2022121101.jpg",
  "creationDate": "2022-12-11",
  "author": {
      "name": "@fereria",
      "twitterIcon": "fereria.jpg",
      "qiitaUrl": "https://qiita.com/fereria",
      "twitterUrl": "https://twitter.com/fereria"
  },
  "title": {
      "ja": "[記事削除済み] SOLARISの sopimportを攻略する",
      "en": "[Article deleted] Attack the sopimport of SOLARIS"
  },
  "articleUrl": "https://fereria.github.io/reincarnation_tech/05_DCCTool/10_Houdini/11_SOLARIS/20_sopimport/",
  "categories": "Houdini",
  "tags": "SOP LOP SOLARIS",
  "articleId": 2022121101,
  "summary": {
      "ja": "この記事は、HoudiniのSOLARISノード「sopimport」の使い方について詳しく説明しています。sopimportは、SOP（Scene Object Parameters）で作成したジオメトリをLOP（Lighting Operation）の世界に移すことができるノードです。これにより、usdexportノードを使わずにジオメトリデータをシームレスにLOPに移行できます。記事では、基本的な使い方から、Referenceでのインポート、Warningの処理方法、グループやサブセットの指定、インスタンスの作成、レイヤーパスの設定、属性の追加、アニメーションの取り扱いなど、sopimportノードの多様な機能とその活用方法を具体的に説明しています。また、SOPとLOPの組み合わせによって、大量のアセットをUSD形式で効率的に処理できることを強調しています。著者は、Houdiniを使用することで大規模なアセット制作が可能になると述べ、今後もSOLARISノードのさらなる検証を進める意向を示しています。",
      "en": "This article details the use of the SOLARIS node \"sopimport\" in Houdini. sopimport is a node that allows geometry created in SOP (Scene Object Parameters) to be transferred to the LOP (Lighting Operation) world. It is a node that allows usdexport nodes to be used in the LOP (Lighting Operation) world. This allows geometry data to be seamlessly transferred to LOP without the need for a usdexport node. The article explains in detail the various functions of the sopimport node and how to utilize them, including basic usage, importing with Reference, how to handle Warnings, specifying groups and subsets, creating instances, setting layer paths, adding attributes, handling animations, and more. The following is an explanation of the various functions of the sopimport node and how to make use of them. It also emphasizes how the combination of SOPs and LOPs allows for the efficient processing of large numbers of assets in USD format. The author states that the use of Houdini enables large-scale asset production and indicates his intention to further validate the SOLARIS node in the future."
  }
},
{
  "thumbnailUrl": "2022121201.jpg",
  "creationDate": "2022-12-12",
  "author": {
      "name": "@procedural_design",
      "twitterIcon": "procedural_design.jpg",
      "qiitaUrl": "https://qiita.com/procedural_design",
      "twitterUrl": "https://twitter.com/procedural_design"
  },
  "title": {
      "ja": "Houdini 19.5で追加されたTangent Field SOPについて",
      "en": "About the Tangent Field SOP added in Houdini 19.5"
  },
  "articleUrl": "https://qiita.com/procedural_design/items/31884002da0a353393dc",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121201,
  "summary": {
      "ja": "Houdini 19.5で追加されたTangent Field SOPは、物体表面に連続するベクトルを生成し、オブジェクトの配置をより自然に行うための機能です。動物の体毛や魚の鱗のような有機的なオブジェクトの配置に適しており、複雑な形状に沿った方向性を提供します。このノードは、形状の主曲率に基づいてベクトルを生成し、体毛や鱗、血管などの配置に役立つとともに、ハードサーフェスモデリングにも応用可能です",
      "en": "The Tangent Field SOP, added in Houdini 19.5, generates continuous vectors on the object surface for more natural placement of objects. It is ideal for placement of organic objects such as animal body hair or fish scales, and provides orientation along complex shapes. This node generates vectors based on the principal curvature of the shape and is useful for placement of body hair, scales, blood vessels, etc. and can also be applied to hard surface modeling"
  }
},
{
  "thumbnailUrl": "2022121301.jpg",
  "creationDate": "2022-12-13",
  "author": {
      "name": "@55hertz",
      "twitterIcon": "55hertz.jpg",
      "qiitaUrl": "https://qiita.com/55hertz",
      "twitterUrl": "https://twitter.com/55hertz"
  },
  "title": {
      "ja": "Solaris Karma Physical Lens shaderを試してみた",
      "en": "Tried Solaris Karma Physical Lens shader"
  },
  "articleUrl": "https://qiita.com/55hertz/items/1a665c899a8cc1afff2f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121301,
  "summary": {
      "ja": "Houdini 18.5から導入されたKarmaのレンズシェーダーについて、実写に近いレンダリングを目指して実験が行われました。このシェーダーは、カメラに物理的なレンズの特性を再現することにより、実写と同じようなフォーカス効果やボケを生み出すことができます。実験では、物理的な被写体の撮影と同様の条件下でCGモデルをレンダリングし、実写との比較を行いました。このプロセスは、ミニチュア風撮影など、多様な表現を実現する可能性を示しています",
      "en": "Experiments were conducted on Karma's Lens Shader, introduced in Houdini 18.5, with the goal of achieving renderings that closely resemble live-action. This shader can create focus effects and blurring similar to live-action by reproducing the characteristics of a physical lens on a camera. In the experiment, CG models were rendered under conditions similar to those of shooting physical subjects and compared to live action. This process demonstrates the potential to achieve a variety of expressions, such as miniature-style photography"
  }
},
{
  "thumbnailUrl": "2022121401.jpg",
  "creationDate": "2022-12-14",
  "author": {
      "name": "@TF_siri",
      "twitterIcon": "TF_siri.jpg",
      "qiitaUrl": "https://qiita.com/TF_siri",
      "twitterUrl": "https://twitter.com/TF_siri"
  },
  "title": {
      "ja": "intersect関数で色々しようの話。",
      "en": "A story about how to do various things with the intersect function."
  },
  "articleUrl": "https://qiita.com/TF_siri/items/582b095d8deec2fdeb0d",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121401,
  "summary": {
      "ja": "Houdiniのintersect関数を使った実験が紹介されています。この関数は、指定した位置から方向を見たときに最初に接触する位置を求めることができます。この機能を利用して、屈折効果を再現するレンダラーのようなものが作成されました。透明オブジェクトや色の取得、屈折の計算などが行われ、最終的には屈折効果を持つレンダリングが可能になりました。この実験は、intersect関数の多様な応用可能性を示しています",
      "en": "An experiment using Houdini's intersect function is presented. This function can find the position of the first contact when looking in a direction from a specified position. Using this function, a kind of renderer was created to reproduce refraction effects. Transparent objects and colors were acquired, refractions were calculated, and finally a rendering with refraction effects was possible. This experiment demonstrates the versatile applicability of the intersect function"
  }
},
{
  "thumbnailUrl": "2022121501.jpg",
  "creationDate": "2022-12-15",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "CGWORLD 2022 クリエイティブカンファレンス登壇内容の振り返り",
      "en": "CGWORLD 2022 Creative Conference Speakers' Reflections"
  },
  "articleUrl": "https://kickbase.net/entry/cgwcc2022",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121501,
  "summary": {
      "ja": "CGWORLD 2022 クリエイティブカンファレンスでの講演「カプセル化しないHDAを作ってみよう」についての振り返りです。この講演では、配布や再利用が容易で、編集可能なネットワークを構築できるツールの作成が紹介されました。HDAの作成から、自動化されたシェルフツールの使用まで、Pythonを用いたネットワーク構築のプロセスが詳述されています。このアプローチは、Houdiniの応用の幅を広げ、多くのシーンに対応可能なツールの開発を可能にします",
      "en": "This is a recap of my talk at the CGWORLD 2022 Creative Conference, \"Creating HDA without Encapsulation\". This talk presented the creation of a tool that allows the creation of editable networks that can be easily distributed and reused, detailing the process of building networks using Python, from the creation of HDAs to the use of automated shelf tools. This approach expands the range of applications of Houdini and allows for the development of tools that can be used for many scenes!"
  }
},
{
  "thumbnailUrl": "2022121601.jpg",
  "creationDate": "2022-12-16",
  "author": {
      "name": "@TrsNium",
      "twitterIcon": "TrsNium.jpg",
      "qiitaUrl": "https://qiita.com/TrsNium",
      "twitterUrl": "https://twitter.com/TrsNium"
  },
  "title": {
      "ja": "フルプロシージャル社寺建設",
      "en": "Full procedural shrine and temple construction"
  },
  "articleUrl": "https://qiita.com/TrsNium/items/bd77659b8b2fb47b4463",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121601,
  "summary": {
      "ja": "Houdiniを使用して、日本の古来の木造建築をプロシージャルに作成する方法が紹介されています。この方法では、床、柱、屋根などの基本要素を生成するためのノードが用意されており、これらを組み合わせることで様々な形状の社寺を作成することができます。木組みのデザインや屋根の形状など、様々な要素がパラメータで調整可能で、複雑な外観の建築物の生成が可能です",
      "en": "A method for procedurally creating ancient Japanese wooden architecture using Houdini is presented. In this method, nodes are provided to generate basic elements such as floors, columns, and roofs, which can be combined to create shrines and temples of various shapes. Various elements, such as the design of the wooden structure and the shape of the roof, can be adjusted with parameters to generate complex looking buildings!"
  }
},
{
  "thumbnailUrl": "2022121701.jpg",
  "creationDate": "2022-12-17",
  "author": {
      "name": "@minami110",
      "twitterIcon": "minami110.jpg",
      "qiitaUrl": "https://qiita.com/minami110",
      "twitterUrl": "https://twitter.com/minami110"
  },
  "title": {
      "ja": "KineFX で Procedual Rigging をつくる",
      "en": "Creating Procedural Rigging with KineFX"
  },
  "articleUrl": "https://scrapbox.io/hounotes/KineFX_%E3%81%A7_Procedual_Rigging_%E3%82%92%E3%81%A4%E3%81%8F%E3%82%8B",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121701,
  "summary": {
      "ja": "この記事は、HoudiniのKineFXを用いたProcedural Riggingの制作過程について解説しています。Houdiniバージョン19.5における新機能を活用し、キャラクターセットアップがより洗練されている点を強調しています。まず、ボリュームベースのモデリングから始め、Houdini 19.5で導入されたCapture Geo Shapesを使用したスキニングを行います。次に、スキン済みのジオメトリにBlend shapesを追加し、Character HDAを作成します。その後、Control Rigをセットアップし、専用のコントローラを作成しています。これにより、アニメーションに追従するコントローラやショット専用のコントローラを簡単に構築でき、KineFXの利点を活かしています。記事では、Houdiniの公式チュートリアル「Character Workflow」を参考にしながら、シンプルなControl Rigを構築しています。最後に、Rig HDAのUIとEdit Operator Type Propertiesについて触れ、アニメーションの柔軟性と効率性を強調しています。",
      "en": "This article describes the process of creating Procedural Rigging using Houdini's KineFX, highlighting the new features in Houdini version 19.5 that allow for more sophisticated character setups. It begins with volume-based modeling, followed by skinning using Capture Geo Shapes introduced in Houdini 19.5. Next, we add Blend shapes to the skinned geometry to create Character HDA. We then set up a Control Rig and create a dedicated controller. This makes it easy to build controllers that follow the animation or are dedicated to a shot, taking advantage of KineFX. In the article, a simple Control Rig is built using the official Houdini tutorial \"Character Workflow\" as a reference. Finally, it touches on the Rig HDA UI and Edit Operator Type Properties, highlighting the flexibility and efficiency of animation."
  }
},
{
  "thumbnailUrl": "2022121801.jpg",
  "creationDate": "2022-12-18",
  "author": {
      "name": "@d658t",
      "twitterIcon": "d658t.jpg",
      "qiitaUrl": "https://qiita.com/d658t",
      "twitterUrl": "https://twitter.com/d658t"
  },
  "title": {
      "ja": "HDA作成ガイドライン",
      "en": "HDA Preparation Guidelines"
  },
  "articleUrl": "https://qiita.com/d658t/items/a9f785d741037021e6ee",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121801,
  "summary": {
      "ja": "この記事では、HoudiniでHDA（Houdini Digital Assets）を作成する際のガイドラインについて紹介しています。個人ルールとして、公式のノードに倣った設定や明確なオペレータ名の決定、互換性のない変更時の命名規則、ユーザーに表示する名前の視認性の高いルールなどが含まれます。また、処理速度の重視、インプットラベルの分かりやすさ、タブメニューの設定、パラメータのデフォルト値や範囲の設定、必要時のプルダウンメニューの利用、パラメータをカテゴリごとに整理し、必要に応じてグループを作成しプレビューする方法などが説明されています。さらに、HDAのヘルプページとパラメータのツールチップの作成、アイコンの設定などの修正のしやすさやバグの防止に関するアドバイスも含まれています",
      "en": "This article provides guidelines for creating HDA (Houdini Digital Assets) in Houdini. Personal rules include settings that mimic official nodes, clear operator naming, naming conventions for incompatible changes, and visibility rules for names to be displayed to the user. It also explains the emphasis on processing speed, clarity of input labels, tabbed menus, setting default values and ranges for parameters, using pull-down menus when necessary, organizing parameters by category, and creating and previewing groups as needed. Also included is advice on creating HDA help pages and parameter tooltips, setting up icons for ease of modification, and preventing bugs!"
  }
},
{
  "thumbnailUrl": "2022121901.jpg",
  "creationDate": "2022-12-19",
  "author": {
      "name": "@jhorikawa_err",
      "twitterIcon": "jhorikawa_err.jpg",
      "qiitaUrl": "https://qiita.com/jhorikawa_err",
      "twitterUrl": "https://twitter.com/jhorikawa_err"
  },
  "title": {
      "ja": "Houdiniでピクセルアートを作る（Ordered Dithering利用編）",
      "en": "Creating Pixel Art in Houdini (Using Ordered Dithering)"
  },
  "articleUrl": "https://qiita.com/jhorikawa_err/items/a88c448d40de6f764b28",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121901,
  "summary": {
      "ja": "この記事では、Houdiniを使用して2Dピクセルアートを作成する方法について解説しています。主に、Ordered Ditheringというディザリングのアルゴリズムを利用しています。このアルゴリズムは、限られた色数の中でグラデーションを表現するために使用され、Bayerによって1973年に開発されました。ピクセル化したい3D形状を準備し、グリッドに色を転写し、ディザリングアルゴリズムを使って色数を減らすことでピクセルアートを作成します。また、色のクオンタイズも加え、3Dメッシュの外のピクセルを削除する処理も含まれています",
      "en": "This article describes how to create 2D pixel art using Houdini. It mainly uses a dithering algorithm called Ordered Dithering. This algorithm is used to represent gradients in a limited number of colors and was developed by Bayer in 1973. Pixel art is created by preparing the 3D shape to be pixelated, transferring the colors to a grid, and using the dithering algorithm to reduce the number of colors. It also includes the process of removing pixels outside of the 3D mesh, in addition to quantizing the colors"
  }
},
{
  "thumbnailUrl": "2022122001.jpg",
  "creationDate": "2022-12-20",
  "author": {
      "name": "@m__a__",
      "twitterIcon": "m__a__.jpg",
      "qiitaUrl": "https://qiita.com/m__a__",
      "twitterUrl": "https://twitter.com/m__a__"
  },
  "title": {
      "ja": "カスタム座標とカスタムフィールドとポイントからフィールド直読み",
      "en": "Field direct reading from custom coordinates, custom fields and points"
  },
  "articleUrl": "https://qiita.com/m__a__/items/cd3ccf5b2423f9d227f1",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122001,
  "summary": {
      "ja": "この記事では、カスタム座標、カスタムフィールド、ポイントからフィールドを読む方法について説明しています。カスタム座標は通常のxyz座標系以外の座標を指し、ノイズやフィールド作成に有用です。カスタムフィールドは、あらかじめ用意されていないフィールドを指し、流体の動きに影響を与えるために使用されます。また、ポイントから直接フィールドを読み取る方法についても解説しており、Houdiniでの詳細な実装方法が示されています",
      "en": "This advanced article describes how to read fields from custom coordinates, custom fields, and points. Custom coordinates refer to coordinates outside of the normal xyz coordinate system and are useful for noise and field creation. Custom fields refer to fields that are not pre-prepared and are used to influence fluid motion. It also explains how to read fields directly from points and shows a detailed implementation in Houdini"
  }
},
{
  "thumbnailUrl": "2022122101.jpg",
  "creationDate": "2022-12-21",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "画像をトレースする",
      "en": "Trace an image"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/ad3bbc32fc3c7d71739d",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122101,
  "summary": {
      "ja": "この記事では、HoudiniやPythonなどで画像をトレースしてベジェ曲線を作成する方法について解説されています。オープンソースソフトウェアであるpotraceを利用し、ビットマップ画像をベクトルデータに変換するプロセスが詳述されています。著者は、potraceを用いてBMP画像をSVG形式に変換し、その後SVGデータをHoudini上で3次ベジェ曲線として取り込む方法を説明しています。これにはPythonのPILモジュールやsubprocessモジュールが使用されており、SVGパーサーとしてsvg.pathモジュールが用いられています。最終的には、このプロセスをPython SOPとしてHoudiniで実装する方法が提供されています。",
      "en": "This article describes how to trace images and create Bezier curves in Houdini and Python. It details the process of converting bitmap images to vector data using the open source software potrace. The author describes how to convert BMP images to SVG format using potrace and then import the SVG data as cubic Bezier curves in Houdini. The Python PIL and subprocess modules are used for this, and the svg.path module is used as the SVG parser. Finally, a method is provided to implement this process in Houdini as a Python SOP."
  }
},
{
  "thumbnailUrl": "2022122201.jpg",
  "creationDate": "2022-12-22",
  "author": {
      "name": "@AokTky_dori",
      "twitterIcon": "AokTky_dori.jpg",
      "qiitaUrl": "https://qiita.com/AokTky_dori",
      "twitterUrl": "https://twitter.com/AokTky_dori"
  },
  "title": {
      "ja": "CarveSOPをAttributeで制御したい。",
      "en": "I want to control CarveSOP with Attribute."
  },
  "articleUrl": "https://qiita.com/AokTky_dori/items/f8b6eb88ea87aa04e584",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122201,
  "summary": {
      "ja": "この記事では、HoudiniのCarveSOPをAttributeで制御する方法について解説されています。CarveSOPはオブジェクトに対する処理を施すノードであり、著者はこの機能をWrangleを使用して再現し、Attributeで操作可能にする方法を提供しています。プロセスには、PolyLineをスライスする位置を定義するアトリビュートの準備、及びアトリビュートに基づいてPolyLineに処理を施すステップが含まれます。このアプローチにより、複数のラインを扱う際の制御が容易になり、アニメーションにばらつきをもたせることが可能になります。",
      "en": "This article describes how to trace images and create Bezier curves in Houdini and Python. It details the process of converting bitmap images to vector data using the open source software potrace. The author describes how to convert BMP images to SVG format using potrace and then import the SVG data as cubic Bezier curves in Houdini. The Python PIL and subprocess modules are used for this, and the svg.path module is used as the SVG parser. Finally, a method is provided to implement this process in Houdini as a Python SOP."
  }
},
{
  "thumbnailUrl": "2022122301.jpg",
  "creationDate": "2022-12-23",
  "author": {
      "name": "@tanitta",
      "twitterIcon": "tanitta.jpg",
      "qiitaUrl": "https://qiita.com/tanitta",
      "twitterUrl": "https://twitter.com/tanitta"
  },
  "title": {
      "ja": "HoudiniでBlenderのblend形式のファイルを読み込む（？）HDAについて",
      "en": "Loading Blender's blend format files in Houdini (?) About HDA"
  },
  "articleUrl": "https://tanitta.hatenablog.com/entry/2022/12/25/230219?_ga=2.50517931.349575752.1671976797-730120998.1564028130",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122301,
  "summary": {
      "ja": "この記事では、Blenderのblend形式のファイルを読み込むために作成されたSOPのHDAについて詳細に説明しています。著者は、File SOPとCharacter FBX Import SOPに対応する、Blend File SOPとCharacter Blend Import SOPを開発しました。これにより、Blenderで編集したファイルをHoudini上で簡単に読み込むことが可能になり、FBXの書き出しに関連する手間が大幅に軽減されました。また、このHDAは、Blender上で行われる破壊的な作業（Modifierの適応やObjectのMerge等）をHoudini側で非破壊的に行うことができる強力な機能を備えています​",
      "en": "This article details the HDA of the SOPs created to import files in Blender's blend format. The author has developed the Blend File SOP and Character Blend Import SOP, which correspond to the File SOP and Character FBX Import SOP. This makes it possible to easily import files edited in Blender onto Houdini, greatly reducing the effort associated with FBX export. In addition, this HDA has powerful features that allow destructive work done in Blender (Modifier adaptation, Object Merge, etc.) to be done non-destructively on the Houdini side!"
  }
},
{
  "thumbnailUrl": "2022122401.jpg",
  "creationDate": "2022-12-24",
  "author": {
      "name": "@RyanZhang",
      "twitterIcon": "RyanZhang.jpg",
      "qiitaUrl": "https://qiita.com/RyanZhang",
      "twitterUrl": "https://twitter.com/RyanZhang"
  },
  "title": {
      "ja": "初プロシージャルモデリング制作の考え方とtipsのまとめ",
      "en": "Summary of ideas and tips for first procedural modeling production"
  },
  "articleUrl": "https://guncys.notion.site/tips-82036e589af84e5cb5797a39406508e2",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122401,
  "summary": {
      "ja": "この記事は、HoudiniとUE5を使用してプロシージャルアセットを作成するプロジェクトに関するものです。著者は中国の3Dモデラー、ryan zhangで、これまでBlenderを使用して多くのプロジェクトに参加してきました。Houdiniを初めて使ったこのプロジェクトでは、よりフレキシブルなツールの使用を目指し、Houdiniのバージョン19.0.589を活用しました。記事は、このプロジェクトでの学びやTipsをまとめたもので、著者はRoot StudioのメンバーとしてGUNCY'Sのプロジェクトに参加しています​",
      "en": "This article is about a project using Houdini and UE5 to create procedural assets. The author is ryan zhang, a 3D modeler from China who has worked on many projects using Blender. this is his first project using Houdini, and he took advantage of Houdini version 19.0.589 for more flexible use of the tool. The project was a great success and we are very happy with the results. The article is a compilation of learnings and tips from this project, and the author is a member of Root Studio and participated in GUNCY'S project!"
  }
},
{
  "thumbnailUrl": "2022122501.jpg",
  "creationDate": "2022-12-25",
  "author": {
      "name": "@ijiVFX",
      "twitterIcon": "ijiVFX.jpg",
      "qiitaUrl": "https://qiita.com/ijiVFX",
      "twitterUrl": "https://twitter.com/ijiVFX"
  },
  "title": {
      "ja": "勾配(Gradient)アレコレ",
      "en": "Gradient aleatoria"
  },
  "articleUrl": "https://qiita.com/ijiVFX/items/6f3d3aeea57dab481ebf",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122501,
  "summary": {
      "ja": "この記事では、Houdini上で勾配(Gradient)を作成し、様々な用途に活用する方法について詳細に説明されています。勾配は、値の高低の傾きの分布を表す概念であり、HoudiniではPolyFrameやVDB Analysisといったノードを使って簡単に計算することができます。勾配は、VFX制作やゲーム開発など、多くの分野で活用されています。例えば、草や毛、鱗の生える方向の制御、流体の動きや群衆の進行方向の制御、紙が燃え広がるような表現などに利用できます。記事では、メッシュ上の勾配を作成する例として、EdgeTransportを用いたポイントグループからの距離アトリビュートを出して勾配を作る方法が示されています。また、この記事では勾配を活用した様々な例や、Houdiniでの勾配の計算方法についても説明されています。",
      "en": "This article details how to create a gradient (Gradient) in Houdini and use it for a variety of applications. Gradient is a concept that describes the distribution of the slope of the high and low values, and can be easily calculated in Houdini using nodes such as PolyFrame and VDB Analysis. Gradient is used in many areas, including VFX production and game development. For example, it can be used to control the direction of grass, hair, and scale growth; to control the movement of fluids and the direction of crowds; and to represent paper spreading like flames. As an example of creating a gradient on a mesh, the article shows how to create a gradient by producing a distance attribute from a group of points using EdgeTransport. The article also provides various examples of utilizing gradients and how to calculate them in Houdini."
  }
}



,{
  "thumbnailUrl": "2022120102.jpg",
  "creationDate": "2022-12-01",
  "author": {
      "name": "@Shampagne",
      "twitterIcon": "Shampagne.jpg",
      "qiitaUrl": "https://qiita.com/Shampagne",
      "twitterUrl": "https://twitter.com/Shampagne"
  },
  "title": {
      "ja": "[Houdini] Parameterの変更箇所だけを一発で表示するツール",
      "en": "[Houdini] Tool to display only the changed part of Parameter in one shot."
  },
  "articleUrl": "https://qiita.com/Shampagne/items/84abbd57769910c9a855",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120102,
  "summary": {
      "ja": "この記事では、Houdiniでノードのパラメータの変更箇所のみを表示するためのツールについて説明しています。ツールを使用すると、デフォルト値から変更されたパラメータだけが表示されるようになります。ユーザーはホットキーを押すことで、変更されたパラメータのみを表示または非表示に切り替えることができます​",
      "en": "This article describes a tool in Houdini that allows you to see only the changes made to a node's parameters. The tool allows the user to see only the parameters that have been changed from their default values. The user can show or hide only the parameters that have changed by pressing a hotkey"
  }
},
{
  "thumbnailUrl": "2022120202.jpg",
  "creationDate": "2022-12-02",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "TraceSOPでキラキラした金のまつぼっくりを作ろう",
      "en": "Make sparkling gold eyelashes with TraceSOP!"
  },
  "articleUrl": "https://nullnode.wixsite.com/houdinipsalm/post/tracesop%E3%81%A7%E3%82%AD%E3%83%A9%E3%82%AD%E3%83%A9%E3%81%97%E3%81%9F%E9%87%91%E3%81%AE%E3%81%BE%E3%81%A4%E3%81%BC%E3%81%A3%E3%81%8F%E3%82%8A%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120202,
  "summary": {
      "ja": "この記事では、TraceSOPを使用してキラキラした金色の松ぼっくりを作成するプロセスが詳細に説明されています。松ぼっくりの各部分を作るためのステップが紹介されており、UVマッピング、セグメントの調整、ベンドSOPの使用、マージ、ポリエクストルード、ベンドSOPでの太らせ、アッセンブル、スフィアSOPの使用、ソートSOP、ソフトトランスフォーム、メタボールSOP、VDBからポリゴンへの変換など多数の技術が解説されています",
      "en": "This article details the process of creating a glittery golden pine cone using TraceSOP. Steps are presented to create each part of the pinecone, and numerous techniques are explained, including UV mapping, adjusting segments, using BendSOP, merging, polyextrude, fattening with BendSOP, assembling, using SphereSOP, sorting SOP, soft transforms, metaball SOP, VDB to polygon conversion, and many other techniques are explained"
  }
},
{
  "thumbnailUrl": "2022120302.jpg",
  "creationDate": "2022-12-03",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "Houdiniでプラレール自動生成",
      "en": "Automatic generation of plastic rails in Houdini"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/b22c45fe5b0ae0277224",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120302,
  "summary": {
      "ja": "この記事では、Houdiniを使用してプラレールのレールを自動生成する方法について述べています。鉄道のレールをプロシージャルに作成する従来の手法から進化させ、プラレールとしてモデリングしました。これには、プラレールのサイズと接続部の方向の制約があります。レールの自動生成には、ルート探索のエージェントを使い、ガイドラインに沿ってレールを配置する手法が使用されています。このプロセスには、複数の技術ステップが含まれており、最終的には細かい調整や再設定が必要になる場合があります",
      "en": "This article describes how to use Houdini to automatically generate plastic rails. We have evolved from the traditional method of procedurally creating railroad rails and modeled them as plastic rails. This is subject to the constraints of the size of the plastic rail and the direction of the connections. A technique was used to automatically generate the rails, using a route-finding agent to place the rails along a set of guidelines. This process involves multiple technical steps and may eventually require minor adjustments and reconfiguration"
  }
},
{
  "thumbnailUrl": "2022120402.jpg",
  "creationDate": "2022-12-04",
  "author": {
      "name": "@futabarei",
      "twitterIcon": "futabarei.jpg",
      "qiitaUrl": "https://qiita.com/futabarei",
      "twitterUrl": "https://twitter.com/futabarei"
  },
  "title": {
      "ja": "VRChatで使うアバターをHoudini (kineFX)でセットアップする",
      "en": "Setting up an avatar in Houdini (kineFX) for use with VRChat"
  },
  "articleUrl": "https://note.com/futafusa/n/n483c20da7398",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120402,
  "summary": {
      "ja": "この記事では、Houdiniを使用してVRChatのアバターをセットアップする方法について説明されています。著者は、Houdiniの機能を利用して、アバターのメッシュ情報、ボーン情報、アニメーション情報を管理し、アバター衣装の変更やボーンのウェイト調整を行います。また、別のモデルの衣装を現在のアバターに適用する方法についても言及されています。最終的に、マテリアルの設定とFBXファイルの書き出しについても解説しています",
      "en": "This article describes how to set up a VRChat avatar using Houdini. The author uses Houdini's capabilities to manage the avatar's mesh information, bone information, and animation information to change the avatar costume and adjust the bone weights. He also discusses how to apply another model's costume to the current avatar. Finally, material settings and FBX file export are also discussed"
  }
},
{
  "thumbnailUrl": "2022120502.jpg",
  "creationDate": "2022-12-05",
  "author": {
      "name": "@Harry21934944",
      "twitterIcon": "Harry21934944.jpg",
      "qiitaUrl": "https://qiita.com/Harry21934944",
      "twitterUrl": "https://twitter.com/Harry21934944"
  },
  "title": {
      "ja": "POPで作成したParticleのうち何割かを消したいと言われたときの対処方法",
      "en": "What to do when you are asked to erase a percentage of the Particles created by POP."
  },
  "articleUrl": "https://qiita.com/Harry21934944/items/db5b2fd3de115c2ea108",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120502,
  "summary": {
      "ja": "この記事では、HoudiniのParticle System（POP）で生成されたパーティクルの量を調整する方法について紹介しています。エフェクト作業中にパーティクルの数を半分に減らす必要がある場合、パーティクルにID属性を付与し、特定の割合でパーティクルを削除するスクリプトを記述する方法が説明されています。この方法により、柔軟にパーティクルの量を調整できるようになります",
      "en": "This article describes how to adjust the amount of particles generated by Houdini's Particle System (POP). If you need to reduce the number of particles by half while working on an effect, the article explains how to assign an ID attribute to the particles and write a script to remove particles at a specific rate. This method allows you to flexibly adjust the amount of particles"
  }
},
{
  "thumbnailUrl": "2022120602.jpg",
  "creationDate": "2022-12-06",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "金のまつぼっくりを利用してまつぼっくりのリース部分を作る",
      "en": "Make a wreath part of a pine cone using a golden pine cone"
  },
  "articleUrl": "https://nullnode.wixsite.com/houdinipsalm/post/%E3%81%BE%E3%81%A4%E3%81%BC%E3%81%A3%E3%81%8F%E3%82%8A%E3%81%AE%E3%83%AA%E3%83%BC%E3%82%B9%E9%83%A8%E5%88%86%E3%82%92%E4%BD%9C%E3%82%8B",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120602,
  "summary": {
      "ja": "この記事は、Houdiniを使用してまつぼっくりのリースを作るプロセスについて詳述しています。著者は、ノードの設定とマテリアルの選択について説明し、まつぼっくりの色を変更し、金色の飾りやリースの形状を作成する手順を紹介しています。さらに、リースに様々な装飾を加え、最終的にHoudiniで完成したリースのモデルを紹介しています",
      "en": "This article details the process of creating a lash wreath using Houdini. The author describes node setup and material selection, and walks through the process of changing the color of the lash, creating the golden ornaments and the shape of the wreath. He also adds various decorations to the wreath and shows the final model of the wreath in Houdini!"
  }
},
{
  "thumbnailUrl": "2022120702.jpg",
  "creationDate": "2022-12-07",
  "author": {
      "name": "@kit2cuz",
      "twitterIcon": "kit2cuz.jpg",
      "qiitaUrl": "https://qiita.com/kit2cuz",
      "twitterUrl": "https://twitter.com/kit2cuz"
  },
  "title": {
      "ja": "エッジに対してWrangleする",
      "en": "Wrangle for edges"
  },
  "articleUrl": "https://qiita.com/kit2cuz/items/fadcfa40322c3017bf4f",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120702,
  "summary": {
      "ja": "この記事では、HoudiniのWrangleノードを使用してエッジを処理する方法に焦点を当てています。エッジの扱いに関して、ハーフエッジの利用方法が説明されており、非共有エッジを探すためのスクリプト例が提供されています。さらに、カメラから見たモデルの輪郭エッジを特定しラインを作成する応用例も紹介されています。この手法は、Houdiniの高度な機能を使いこなすための一例として提供されています​",
      "en": "This article focuses on how to handle edges using the Wrangle node in Houdini. In terms of edge handling, the use of half edges is described and example scripts are provided to find non-shared edges. In addition, an application is presented that identifies the contour edges of a model as seen from the camera and creates lines. This method is provided as an example of how to use the advanced features of Houdini."
  }
},
{
  "thumbnailUrl": "2022120802.jpg",
  "creationDate": "2022-12-08",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "部屋と詰Houdiniと私",
      "en": "Room and Tsume Houdini and I"
  },
  "articleUrl": "https://kickbase.net/entry/tsume_houdini",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120802,
  "summary": {
      "ja": "この記事では、著者が主催する「Houdiniゆるゆる会」という勉強会について紹介されています。この会から派生した「詰Houdini」というイベントは、Houdiniを使用して様々なアプローチで問題に挑むことに重点を置いており、競争よりも協力と新しいアプローチの発見に重きを置いています。記事は、Houdiniを使った様々な手法についての反省と学びを共有しています​",
      "en": "This article describes a study group called \"Houdini Yuru Yuru Kai\" organized by the author. The \"Tsume Houdini\" event, derived from this meeting, focuses on using Houdini to tackle problems with different approaches, with an emphasis on cooperation and discovering new approaches rather than competition. The article shares reflections and learnings about different methods using Houdini"
  }
},
{
  "thumbnailUrl": "2022120902.jpg",
  "creationDate": "2022-12-09",
  "author": {
      "name": "@Borndigital_Yoshida",
      "twitterIcon": "Borndigital_Yoshida.jpg",
      "qiitaUrl": "https://qiita.com/Borndigital_Yoshida",
      "twitterUrl": "https://twitter.com/Borndigital_Yoshida"
  },
  "title": {
      "ja": "アニメーション付きUSDを出力する",
      "en": "Output USD with animation"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/13308533851929",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022120902,
  "summary": {
      "ja": "この記事では、Component Builderを用いてアニメーション付きUSDを出力する方法を解説しています。Component Builderはスタティックアセットの出力を目的としていますが、Cacheノードの追加と設定変更を行うことで、アニメーションを持ったUSDアセットを生成できることが説明されています",
      "en": "This article explains how to output animated USDs using Component Builder, which is intended to output static assets, but by adding Cache nodes and changing settings, it is possible to generate animated USD assets with animation by adding a Cache node and changing the settings."
  }
},
{
  "thumbnailUrl": "2022121002.jpg",
  "creationDate": "2022-12-10",
  "author": {
      "name": "@tI30961587",
      "twitterIcon": "tI30961587.jpg",
      "qiitaUrl": "https://qiita.com/tI30961587",
      "twitterUrl": "https://twitter.com/tI30961587"
  },
  "title": {
      "ja": "ドット積を使ってラバートイに雪を積もらせる",
      "en": "Snow on the rubber toys using dot stacking."
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/13244244318105",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121002,
  "summary": {
      "ja": "この記事は、ドット積を使用してHoudini内でラバートイに雪を積もらせる方法を紹介しています。ドット積の基本的な概念と計算方法から始まり、法線とY軸を使用してラバートイに雪を積もらせる具体的な手順が説明されています。最終的には、scatterノードとvdbボリュームを使用して、雪をリアルに見せる方法が解説されています",
      "en": "This article shows how to make a rubber toy accumulate snow within Houdini using dot product. Starting with the basic concepts and calculations of dot product, the article explains the specific steps to make a rubber toy accumulate snow using normals and the y-axis. Finally, it explains how to use scatter nodes and vdb volumes to make the snow look realistic!"
  }
},
{
  "thumbnailUrl": "2022121102.jpg",
  "creationDate": "2022-12-11",
  "author": {
      "name": "@Alidade",
      "twitterIcon": "Alidade.jpg",
      "qiitaUrl": "https://qiita.com/Alidade",
      "twitterUrl": "https://twitter.com/Alidade"
  },
  "title": {
      "ja": "SOP（ノード）のアイコンを作ろう計画",
      "en": "Plan to make SOP (node) icons"
  },
  "articleUrl": "https://qiita.com/Alidade/items/d8e30e59b69cd09c5c7c",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121102,
  "summary": {
      "ja": "この記事は、Houdiniのノードアイコンを自作するプロセスを説明しています。最初にHoudiniでアイコンにしたいオブジェクトを選び、それをスクリーンショットで取り、Illustratorで画像処理を行います。その後、作成したアイコンをHoudiniのAsset Managerに取り込み、使用する方法が紹介されています。記事の最後には、アイコン付きのHDAファイルと、記事中で作成された星型スパンコールのHDAがダウンロード可能です​",
      "en": "This article describes the process of creating your own node icons in Houdini. First, you select the object you want to make into an icon in Houdini, take a screenshot of it, and process the image in Illustrator. The article then shows how to import the created icon into Houdini's Asset Manager and use it. At the end of the article, you can download the HDA file with the icons and the star-shaped sequin HDA created in the article"
  }
},
{
  "thumbnailUrl": "2022121202.jpg",
  "creationDate": "2022-12-12",
  "author": {
      "name": "@Harry21934944",
      "twitterIcon": "Harry21934944.jpg",
      "qiitaUrl": "https://qiita.com/Harry21934944",
      "twitterUrl": "https://twitter.com/Harry21934944"
  },
  "title": {
      "ja": "キャラクターの足が地面に接したときに自動でPointを作成してEmitterを作る",
      "en": "Automatically create a Point and Emitter when the character's feet touch the ground."
  },
  "articleUrl": "https://qiita.com/Harry21934944/items/66d5cf593abcbbefd6f7",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121202,
  "summary": {
      "ja": "この記事では、Houdiniでキャラクターの歩行時に自動的に煙などのエフェクトを生成する技術について説明しています。具体的には、キャラクターの足のパーツを1つにまとめ、足が地面に接触した際に点を作成し、Emitterの形状を作成する手順が紹介されています。この過程では、Assemble, PointDeform, ConvexHull, Intersectなどの機能が使用され、点がヒットしない場合はKillされる手法が説明されています",
      "en": "This article describes a technique for automatically generating smoke and other effects when a character walks in Houdini. Specifically, the article presents a procedure for creating Emitter shapes by combining the parts of a character's feet into a single part and creating a point when the feet make contact with the ground. Functions such as Assemble, PointDeform, ConvexHull, and Intersect are used in this process, and the technique of Kill if the point is not hit is explained"
  }
},
{
  "thumbnailUrl": "2022121302.jpg",
  "creationDate": "2022-12-13",
  "author": {
      "name": "@Harry21934944",
      "twitterIcon": "Harry21934944.jpg",
      "qiitaUrl": "https://qiita.com/Harry21934944",
      "twitterUrl": "https://twitter.com/Harry21934944"
  },
  "title": {
      "ja": "PyroのシミュレーションでCamera外のシミュレーションを消してレゾを節約する",
      "en": "Pyro simulation to turn off simulation outside of Camera to save reso."
  },
  "articleUrl": "https://qiita.com/Harry21934944/items/9635f04cbf356790a757",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121302,
  "summary": {
      "ja": "この記事では、Pyroシミュレーションでカメラの視野外の部分を消去し、リソースを節約する方法について説明しています。カメラの動きとPyroシミュレーションを作成し、VolumeSOPでCameraFrustumを作成、GasFieldVOPで読み込む手順が示されています。VolumeSampleVOPとMultiplyを使用し、カメラ外のDensityを0にして消去するプロセスが解説されています",
      "en": "This article describes how to save resources by eliminating areas outside the camera's field of view in a Pyro simulation. It shows how to create a Pyro simulation with camera motion, create a CameraFrustum with VolumeSOP, and read it in with GasFieldVOP. The process is explained"
  }
},
{
  "thumbnailUrl": "2022121402.jpg",
  "creationDate": "2022-12-14",
  "author": {
      "name": "@kickbase",
      "twitterIcon": "kickbase.jpg",
      "qiitaUrl": "https://qiita.com/kickbase",
      "twitterUrl": "https://twitter.com/kickbase"
  },
  "title": {
      "ja": "部屋と詰Houdini",
      "en": "Room and Tsume Houdini"
  },
  "articleUrl": "https://kickbase.net/entry/tsume_houdini2",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121402,
  "summary": {
      "ja": "この記事では、「詰Houdini」という、Houdiniを使用したクリエイティブなチャレンジが紹介されています。参加者は、与えられたお題に対してさまざまなアプローチを用いて解決策を提示します。今回のお題は、「オブジェクトからの距離によって六角形グリッドのサイズが変形するシーンを作成する」でした。記事では、六角形グリッドの生成方法とスケールコントロールの実装について、異なる解法が紹介されています。この活動は、新しいアプローチの発見や学びを重視し、互いに賞賛を送り合うコラボレーションの場となっています。",
      "en": "This article presents a creative challenge using Houdini called \"Tsume Houdini\". Participants are asked to present a solution to a given problem using a variety of approaches. This year's challenge was to create a scene in which the size of the hexagonal grid transforms depending on the distance from the object. The article presents different solutions on how to generate a hexagonal grid and implement scale controls. This activity is a collaborative one, where the emphasis is on discovering and learning new approaches, and on praising each other."
  }
},
{
  "thumbnailUrl": "2022121502.jpg",
  "creationDate": "2022-12-15",
  "author": {
      "name": "@indyzone",
      "twitterIcon": "indyzone.jpg",
      "qiitaUrl": "https://qiita.com/indyzone",
      "twitterUrl": "https://twitter.com/indyzone"
  },
  "title": {
      "ja": "Houdini Python Viewer State イベントハンドラーの基本とマウスイベントを扱う",
      "en": "Houdini Python Viewer State Event Handler Basics and Handling Mouse Events"
  },
  "articleUrl": "https://bit.ly/3j3Iqx8",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121502,
  "summary": {
      "ja": "この記事では、HoudiniでPython Viewer Stateを使用してインタラクティブなツールを作成する方法について詳しく説明しています。Python Viewer StateをHDAに登録することで、ビューポート上での操作が可能になり、マウスやキーボードの入力に応じた処理を行う手順が示されています。ライフサイクルイベントハンドラーとUIイベントハンドラーに関する詳細な情報が提供されており、具体的な使用例も紹介されています​",
      "en": "This article details how to use Python Viewer States in Houdini to create interactive tools; by registering Python Viewer States with HDA, they can be manipulated on the viewport and can be used to control mouse and keyboard It shows the steps to process the input accordingly. Detailed information on lifecycle event handlers and UI event handlers is provided, as well as specific use cases."
  }
},
{
  "thumbnailUrl": "2022121602.jpg",
  "creationDate": "2022-12-16",
  "author": {
      "name": "@kurosawa",
      "twitterIcon": "kurosawa.jpg",
      "qiitaUrl": "https://qiita.com/kurosawa",
      "twitterUrl": "https://twitter.com/kurosawa"
  },
  "title": {
      "ja": "Unreal Engine向けFBX出力の話",
      "en": "FBX output for Unreal Engine"
  },
  "articleUrl": "https://note.com/thesaurus/n/nbf8040889c66",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121602,
  "summary": {
      "ja": "この記事では、Houdiniを使用してUnreal Engine向けのスタティックメッシュをFBX形式で出力する際のポイントについて説明しています。重要なのは、HoudiniとUnreal Engineの単位系の違いへの対応、頂点カラーの利用、マテリアルの設定、コリジョンの作成方法、LOD(Level of Detail)の設定、そしてUnreal Engine側の設定です。これらの要素は、FBXファイルのエクスポートをスムーズにし、エンジンでの使用を最適化するために重要です。",
      "en": "This article discusses the key points of using Houdini to output static meshes for the Unreal Engine in FBX format. The key elements are dealing with the differences between the Houdini and Unreal Engine unit systems, using vertex colors, material settings, how collisions are created, Level of Detail (LOD) settings, and Unreal Engine side settings. These elements are important to ensure smooth export of FBX files and optimize their use in the engine."
  }
},
{
  "thumbnailUrl": "2022121702.jpg",
  "creationDate": "2022-12-17",
  "author": {
      "name": "@tI30961587",
      "twitterIcon": "tI30961587.jpg",
      "qiitaUrl": "https://qiita.com/tI30961587",
      "twitterUrl": "https://twitter.com/tI30961587"
  },
  "title": {
      "ja": "ノードを使うかコードで書くか問題",
      "en": "Issue of whether to use nodes or write in code"
  },
  "articleUrl": "https://support.borndigital.co.jp/hc/ja/articles/13567469651353",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121702,
  "summary": {
      "ja": "この記事は、Houdiniでの機能実装において、ノードベースのアプローチとコード（特にWrangleを使用した）アプローチを比較しています。Houdiniはノードベースのツールであり、プログラミング知識がなくても扱えますが、より複雑な機能を実装する際にはコードを書く方が適している場合があります。この選択は、ユーザーのVEXに関する知識や特定のタスクにおける要件に依存します。",
      "en": "This article compares the node-based approach to implementing features in Houdini with the code (especially using Wrangle) approach. may be more suitable for implementing more complex features. This choice depends on the user's knowledge of VEX and the requirements of the particular task."
  }
},
{
  "thumbnailUrl": "2022121802.jpg",
  "creationDate": "2022-12-18",
  "author": {
      "name": "@Lethe_movie",
      "twitterIcon": "Lethe_movie.jpg",
      "qiitaUrl": "https://qiita.com/Lethe_movie",
      "twitterUrl": "https://twitter.com/Lethe_movie"
  },
  "title": {
      "ja": "目指せ回転マスター！Quaternion系VEX関数まとめ",
      "en": "Aim for Rotation Mastery! Summary of Quaternion VEX Functions"
  },
  "articleUrl": "https://qiita.com/Lethe_movie/items/36d3317032eba041cb0e",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121802,
  "summary": {
      "ja": "この記事は、Houdiniでの回転操作に焦点を当て、Quaternionを扱うVEX関数の紹介をしています。Quaternionの理解により、Houdini内での回転操作が容易になります。作者は回転計算にQuaternionではなくMatrixを好んで使用すると述べており、これはその使いやすさに由来します。記事では各Quaternion関数の使用方法と挙動について詳しく説明されています。",
      "en": "This article focuses on rotation manipulation in Houdini and introduces the VEX functions that deal with Quaternion; understanding Quaternion makes rotation manipulation within Houdini easier. The author states that he prefers to use Matrix rather than Quaternion for rotation calculations because of its ease of use. The article details the use and behavior of each Quaternion function."
  }
},
{
  "thumbnailUrl": "2022121902.jpg",
  "creationDate": "2022-12-19",
  "author": {
      "name": "@egzao1o9_CG",
      "twitterIcon": "egzao1o9_CG.jpg",
      "qiitaUrl": "https://qiita.com/egzao1o9_CG",
      "twitterUrl": "https://twitter.com/egzao1o9_CG"
  },
  "title": {
      "ja": "岩のマテリアル",
      "en": "Rock Materials"
  },
  "articleUrl": "https://qiita.com/egzao1o9_CG/items/4e9b3c850821b647c303",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022121902,
  "summary": {
      "ja": "この記事では、Houdiniを使用して岩のマテリアルを作成する方法について詳述されています。プロセスには、オブジェクトに質感を与えるためのベースカラーの作成、まだら模様の作成、岩のエッジの色変更、岩の窪みを暗くする処理、そして苔の生成が含まれます。このマテリアル作成プロセスは他の応用、例えば雪の表現などにも適用可能です。",
      "en": "This article details how to create rock materials using Houdini. The process includes creating a base color to give the object texture, creating speckles, changing the color of rock edges, darkening rock depressions, and generating moss. This material creation process can also be applied to other applications, such as the representation of snow."
  }
},
{
  "thumbnailUrl": "2022122002.jpg",
  "creationDate": "2022-12-20",
  "author": {
      "name": "@Muteriku",
      "twitterIcon": "Muteriku.jpg",
      "qiitaUrl": "https://qiita.com/Muteriku",
      "twitterUrl": "https://twitter.com/Muteriku"
  },
  "title": {
      "ja": "Pivot Painter の解説",
      "en": "Pivot Painter Description"
  },
  "articleUrl": "https://qiita.com/Muteriku/items/857e02ac746b091a73f3",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122002,
  "summary": {
      "ja": "この記事では、HoudiniのPivot PainterツールとそのUnreal Engineでの応用について説明しています。Pivot Painterはオブジェクトをサブオブジェクト単位で動かすためのデータ作成機構であり、インタラクティブでプロシージャルなアニメーションの作成を可能にします。このツールは、特定のマテリアルと一緒に使うことができ、多様なジオメトリを効率的に動かすことが可能です。記事では、Pivot Painterを用いて、データの作成、出力されるファイルの種類、Unreal Engineでのテクスチャ設定、およびシェーダーグラフの作成について詳しく説明しています。",
      "en": "This article describes Houdini's Pivot Painter tool and its application in the Unreal Engine, which is a data creation mechanism for moving objects on a sub-object basis, enabling the creation of interactive and procedural animations. The tool can be used with specific materials to efficiently move a wide variety of geometry. The article details data creation, output file types, texture settings in Unreal Engine, and shader graph creation using Pivot Painter."
  }
},
{
  "thumbnailUrl": "2022122102.jpg",
  "creationDate": "2022-12-21",
  "author": {
      "name": "@osouzai",
      "twitterIcon": "osouzai.jpg",
      "qiitaUrl": "https://qiita.com/osouzai",
      "twitterUrl": "https://twitter.com/osouzai"
  },
  "title": {
      "ja": "MOPsであそぼう",
      "en": "Let's play with MOPs"
  },
  "articleUrl": "https://qiita.com/osouzai/items/5c002e17877ff67b34f6",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122102,
  "summary": {
      "ja": "この記事は、Houdiniの有名なHDA「MOPs」を紹介しています。MOPsはオープンソースで開発されたツールで、モーショングラフィックス制作に特化しています。HoudiniでのAttributeの概念が重要で、MOPsを使うことで、Cinema 4DのMoGraphやMayaのMASHのような機能が簡単に実現できます。MOPsのダウンロード、設定方法も説明しており、作例を通してMOPsの使い方を紹介しています",
      "en": "This article introduces the famous HDA \"MOPs\" in Houdini, an open source tool developed specifically for motion graphics production. The book also explains how to download and set up MOPs, and shows how to use MOPs through examples."
  }
},
{
  "thumbnailUrl": "2022122202.jpg",
  "creationDate": "2022-12-22",
  "author": {
      "name": "@shin_t_o_",
      "twitterIcon": "shin_t_o_.jpg",
      "qiitaUrl": "https://qiita.com/shin_t_o_",
      "twitterUrl": "https://twitter.com/shin_t_o_"
  },
  "title": {
      "ja": "このattribute、どこで定義したんだっけ…をpythonで探す",
      "en": "Search for \"Where did I define this attribute...\" in python."
  },
  "articleUrl": "https://qiita.com/shin_t_o_/items/c7b4eeac532b52876bc2",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122202,
  "summary": {
      "ja": "この記事では、Houdini内の特定のattributeをPythonを使って探索する方法を紹介しています。記事は、HoudiniとPythonの組み合わせでattributeを探すモチベーションとロジックについて説明し、実行環境やPython SOP版のロジック、HDAの利用方法も紹介しています。Pythonコードの効率化についても触れています",
      "en": "This article shows how to use Python to search for a specific attribute in Houdini. The article explains the motivation and logic of searching for attributes in the combination of Houdini and Python, and also introduces the execution environment, the logic of the Python SOP version, and the use of HDA."
  }
},
{
  "thumbnailUrl": "2022122302.jpg",
  "creationDate": "2022-12-23",
  "author": {
      "name": "@ts_bros",
      "twitterIcon": "ts_bros.jpg",
      "qiitaUrl": "https://qiita.com/ts_bros",
      "twitterUrl": "https://twitter.com/ts_bros"
  },
  "title": {
      "ja": "Minutes of Grooming with Houdini",
      "en": "Minutes of Grooming with Houdini"
  },
  "articleUrl": "https://msjbinc.blogspot.com/2022/12/we-are-groom-generaters.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122302,
  "summary": {
      "ja": "この記事では、CGにおける毛や髪の毛の表現技術について、その進化と現代のGrooming技術に焦点を当てています。Groomingは、キャラクターやクリーチャーのFur/Hairを生成するプロセスを指し、Houdiniを使ったGroomingのRnD（研究開発）を紹介しています。様々なGroomingプロセスの例として、Standard ClumpやCustom Curl、Coil Based Hairなどが紹介されています",
      "en": "This article focuses on the technology of hair and hair representation in CG, its evolution and modern Grooming techniques.Grooming refers to the process of generating Fur/Hair for a character or creature, and RnD (Research and Development) of Grooming using Houdini ) of Grooming using Houdini. Examples of various Grooming processes are presented, such as Standard Clump, Custom Curl, Coil Based Hair, etc."
  }
},
{
  "thumbnailUrl": "2022122402.jpg",
  "creationDate": "2022-12-24",
  "author": {
      "name": "@ikatnek",
      "twitterIcon": "ikatnek.jpg",
      "qiitaUrl": "https://qiita.com/ikatnek",
      "twitterUrl": "https://twitter.com/ikatnek"
  },
  "title": {
      "ja": "日本語ドキュメントをローカルで動かす",
      "en": "Run Japanese documents locally"
  },
  "articleUrl": "https://ikatnek.blogspot.com/2022/12/hhelp2022.html",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122402,
  "summary": {
      "ja": "この記事では、Houdiniの日本語ドキュメントのサーバプロセス「hhelp」をローカルで実行する方法を紹介しています。この方法により、検索機能の向上やポップアップヘルプの日本語化が可能になります。ファイルのダウンロード、配置、設定ファイルの作成、hhelpプロセスの実行方法などが詳細に説明されており、ローカルで実行するメリットも述べられています",
      "en": "This article shows how to run the server process \"hhelp\" locally for Houdini's Japanese documentation. This method allows for improved search functionality and pop-up help in Japanese. It details how to download the files, deploy them, create the configuration file, and run the hhelp process, and also discusses the advantages of running it locally"
  }
},
{
  "thumbnailUrl": "2022122502.jpg",
  "creationDate": "2022-12-25",
  "author": {
      "name": "@jyouryuusui",
      "twitterIcon": "jyouryuusui.jpg",
      "qiitaUrl": "https://qiita.com/jyouryuusui",
      "twitterUrl": "https://twitter.com/jyouryuusui"
  },
  "title": {
      "ja": "KineFX Part3：SecondaryMotion",
      "en": "KineFX Part3：SecondaryMotion"
  },
  "articleUrl": "https://qiita.com/jyouryuusui/items/9573a9268eba839a0ff7",
  "categories": "Houdini",
  "tags": "SOP Python",
  "articleId": 2022122502,
  "summary": {
      "ja": "この記事では、HoudiniのKineFX機能の中でも特にセカンダリーモーションに焦点を当てています。Houdini 18.5で初めて導入されたKineFXの変更点や名前の変更、機能の移行について説明されています。セカンダリーモーション機能を使うことで、例えばしっぽをゆらゆらさせるなどの動きを簡単に実現できるようになりました。また、ラグドール機能についても触れられています。",
      "en": "This article focuses on Houdini's KineFX feature, specifically Secondary Motion, which was first introduced in Houdini 18.5 and describes the changes, name changes, and feature migration of KineFX. The Secondary Motion feature makes it easier to achieve, for example, wagging tails. The ragdoll function is also discussed."
  }
}






  
]
}